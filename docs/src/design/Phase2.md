# Phase 2: LLVM IR Integration

## Overview

In Phase 2, we achieve more flexible and high-performance Rust-Julia integration by directly manipulating LLVM IR. This phase retrieves LLVM IR generated by rustc and embeds it into Julia's `llvmcall`, bypassing C-compatible ABI limitations and enabling more advanced type systems and optimizations.

**Target Duration**: 4-6 months
**Deliverable**: LLVM IR integration, extended type system, ownership type support, optimization

---

## Implementation Task List

### Task 1: LLVM.jl Integration and Setup

**Priority**: Highest
**Estimate**: 1 week

#### Implementation Details

1. **Add Dependencies**

   ```toml
   # Project.toml
   [deps]
   LLVM = "929cbde3-209d-540e-8aea-1fcc83b56489"
   LLVM_jll = "dad2f222-ce93-54a1-a47d-0025e8a3acab"
   ```

2. **Initialize LLVM Module**

   ```julia
   # src/llvmintegration.jl
   using LLVM
   using LLVM.Interop

   # Manage LLVM contexts
   const llvm_contexts = Dict{String, LLVM.Context}()

   function get_llvm_context(name::String = "default")
       if !haskey(llvm_contexts, name)
           llvm_contexts[name] = Context()
       end
       llvm_contexts[name]
   end
   ```

3. **LLVM IR Loading Functionality**

   ```julia
   function parse_llvm_ir(ir_file::String)
       ctx = get_llvm_context()
       mod = parse(LLVM.Module, read(ir_file, String), ctx)
       mod
   end

   function parse_llvm_ir_string(ir_string::String)
       ctx = get_llvm_context()
       mod = parse(LLVM.Module, ir_string, ctx)
       mod
   end
   ```

---

### Task 2: Rust Compiler Integration

**Priority**: Highest
**Estimate**: 2 weeks

#### Implementation Details

1. **Rust Compiler Configuration**

   ```julia
   # src/rustcompiler.jl

   struct RustCompiler
       target_triple::String
       optimization_level::Int  # 0-3
       emit_debug_info::Bool
       crate_type::String  # "cdylib", "rlib", etc.
   end

   function RustCompiler(;
       target_triple::String = get_default_target(),
       optimization_level::Int = 2,
       emit_debug_info::Bool = false,
       crate_type::String = "cdylib"
   )
       RustCompiler(target_triple, optimization_level, emit_debug_info, crate_type)
   end

   function get_default_target()
       # Get target for current platform
       @static Sys.iswindows() ? "x86_64-pc-windows-msvc" :
       @static Sys.isapple() ? "x86_64-apple-darwin" :
       "x86_64-unknown-linux-gnu"
   end
   ```

2. **Compile Rust Code to LLVM IR**

   ```julia
   function compile_rust_to_llvm(
       compiler::RustCompiler,
       code::String;
       output_file::Union{String, Nothing} = nothing
   )
       # 1. Write to temporary file
       tmp_file = tempname() * ".rs"
       write(tmp_file, wrap_rust_code_for_llvm(code))

       # 2. Determine LLVM IR file path
       if output_file === nothing
           ir_file = tempname() * ".ll"
       else
           ir_file = output_file
       end

       # 3. Generate LLVM IR with rustc
       cmd = `rustc --emit llvm-ir
              --target $(compiler.target_triple)
              -C opt-level=$(compiler.optimization_level)
              $(compiler.emit_debug_info ? "-g" : "")
              -o $ir_file $tmp_file`

       try
           run(cmd)
       catch e
           error("Failed to compile Rust code: $e")
       end

       # 4. Load LLVM IR
       if !isfile(ir_file)
           error("LLVM IR file not generated: $ir_file")
       end

       mod = parse_llvm_ir(ir_file)

       # 5. Cleanup temporary files (optional)
       # rm(tmp_file, force=true)

       mod
   end

   function wrap_rust_code_for_llvm(code::String)
       # Wrap Rust code appropriately
       # Add extern "C" block or other settings as needed
       code
   end
   ```

3. **Incremental Compilation Support**

   ```julia
   # Cache compilation results
   const compilation_cache = Dict{String, LLVM.Module}()

   function compile_rust_to_llvm_cached(
       compiler::RustCompiler,
       code::String
   )
       code_hash = hash(code)
       cache_key = "$(code_hash)_$(compiler.optimization_level)"

       if haskey(compilation_cache, cache_key)
           return compilation_cache[cache_key]
       end

       mod = compile_rust_to_llvm(compiler, code)
       compilation_cache[cache_key] = mod
       mod
   end
   ```

---

### Task 3: LLVM IR Optimization

**Priority**: High
**Estimate**: 1 week

#### Implementation Details

1. **Optimization Pass Configuration**

   ```julia
   # src/llvmoptimization.jl

   function create_optimization_pipeline(level::Int = 2)
       pm = ModulePassManager()

       if level >= 1
           # Basic optimizations
           add_pass!(pm, Pass("mem2reg"))
           add_pass!(pm, Pass("instcombine"))
           add_pass!(pm, Pass("simplifycfg"))
       end

       if level >= 2
           # More aggressive optimizations
           add_pass!(pm, Pass("gvn"))
           add_pass!(pm, Pass("licm"))
           add_pass!(pm, Pass("loop-vectorize"))
       end

       if level >= 3
           # Maximum optimization
           add_pass!(pm, Pass("slp-vectorize"))
           add_pass!(pm, Pass("aggressive-instcombine"))
       end

       pm
   end

   function optimize_llvm_module(mod::LLVM.Module, level::Int = 2)
       pm = create_optimization_pipeline(level)
       run!(pm, mod)
       mod
   end
   ```

2. **Function-Level Optimization**

   ```julia
   function optimize_function(fn::LLVM.Function, level::Int = 2)
       fpm = FunctionPassManager(fn)

       if level >= 1
           add_pass!(fpm, Pass("mem2reg"))
           add_pass!(fpm, Pass("instcombine"))
       end

       if level >= 2
           add_pass!(fpm, Pass("gvn"))
       end

       initialize!(fpm)
       run!(fpm, fn)
       finalize!(fpm)
   end
   ```

---

### Task 4: LLVM IR Embedding in Staged Functions

**Priority**: Highest
**Estimate**: 2 weeks

#### Implementation Details

1. **RustInstance Definition**

   ```julia
   # src/rustinstances.jl

   struct RustCompilerInstance
       compiler::RustCompiler
       llvm_modules::Vector{LLVM.Module}
   end

   struct RustInstance{n}
   end

   const active_rust_instances = RustCompilerInstance[]

   function instance(::RustInstance{n}) where {n}
       active_rust_instances[n]
   end

   const __current_rust_compiler__ = RustInstance{1}()
   ```

2. **Staged Function Implementation**

   ```julia
   # src/rustcodegen.jl

   @generated function rustcall(
       CT::RustInstance,
       expr::Type{RustNNS{Tnns}},
       args...
   ) where {Tnns}
       C = instance(CT)

       # 1. Get function name
       func_name = get_function_name_from_nns(Tnns)

       # 2. Get Rust code (from type information or cache)
       rust_code = get_rust_code_for_function(func_name)

       # 3. Generate LLVM IR
       llvm_mod = compile_rust_to_llvm_cached(C.compiler, rust_code)

       # 4. Optimize
       optimize_llvm_module(llvm_mod, C.compiler.optimization_level)

       # 5. Get function
       fn = functions(llvm_mod)[func_name]

       if fn === nothing
           error("Function $func_name not found in LLVM module")
       end

       # 6. Get type information
       ret_type = get_return_type_from_llvm(fn)
       arg_types = get_argument_types_from_llvm(fn)

       # 7. Generate llvmcall expression
       Expr(:call, Core.Intrinsics.llvmcall,
           convert(Ptr{Cvoid}, fn),
           ret_type,
           Tuple{arg_types...},
           [:(args[$i]) for i in 1:length(arg_types)]...)
   end
   ```

3. **Type Information Extraction**

   ```julia
   function get_return_type_from_llvm(fn::LLVM.Function)
       ret_ty = return_type(fn)
       llvm_to_julia_type(ret_ty)
   end

   function get_argument_types_from_llvm(fn::LLVM.Function)
       [llvm_to_julia_type(param_type(fn, i))
        for i in 1:length(parameters(fn))]
   end

   function llvm_to_julia_type(llvm_ty::LLVM.Type)
       if isa(llvm_ty, LLVM.IntegerType)
           width = bits(llvm_ty)
           if width == 1
               return Bool
           elseif width == 8
               return Int8
           elseif width == 16
               return Int16
           elseif width == 32
               return Int32
           elseif width == 64
               return Int64
           end
       elseif isa(llvm_ty, LLVM.FloatingPointType)
           if isa(llvm_ty, LLVM.FloatType)
               return Float32
           elseif isa(llvm_ty, LLVM.DoubleType)
               return Float64
           end
       elseif isa(llvm_ty, LLVM.PointerType)
           return Ptr{Cvoid}  # More detailed type inference needed
       elseif isa(llvm_ty, LLVM.VoidType)
           return Cvoid
       end
       error("Unsupported LLVM type: $llvm_ty")
   end
   ```

---

### Task 5: Extended Type System Implementation

**Priority**: High
**Estimate**: 2 weeks

#### Implementation Details

1. **Ownership Type Support**

   ```julia
   # src/rusttypes.jl (extended)

   # Box<T> - Heap-allocated value
   struct RustBox{T}
       ptr::Ptr{Cvoid}

       function RustBox{T}(ptr::Ptr{Cvoid}) where {T}
           new(ptr)
       end
   end

   # Rc<T> - Reference-counted type
   struct RustRc{T}
       ptr::Ptr{Cvoid}
       # Reference count managed on Rust side
   end

   # Arc<T> - Atomic reference-counted type
   struct RustArc{T}
       ptr::Ptr{Cvoid}
       # Atomic reference count managed on Rust side
   end
   ```

2. **Collection Type Support**

   ```julia
   # Vec<T>
   struct RustVec{T}
       ptr::Ptr{Cvoid}
       len::UInt
       cap::UInt
   end

   # String
   struct RustString
       vec::RustVec{UInt8}
   end

   # &str (string slice)
   struct RustStr
       ptr::Ptr{UInt8}
       len::UInt
   end
   ```

3. **Extended Type Conversion**

   ```julia
   # src/typetranslation.jl (extended)

   function rusttype_to_julia_extended(rust_type::String)
       # Basic types
       if haskey(RUST_TYPE_MAP, Symbol(rust_type))
           return RUST_TYPE_MAP[Symbol(rust_type)]
       end

       # Box<T>
       if startswith(rust_type, "Box<")
           inner_type = extract_generic_type(rust_type, "Box")
           return RustBox{rusttype_to_julia_extended(inner_type)}
       end

       # Vec<T>
       if startswith(rust_type, "Vec<")
           inner_type = extract_generic_type(rust_type, "Vec")
           return RustVec{rusttype_to_julia_extended(inner_type)}
       end

       # Other types...
       error("Unsupported Rust type: $rust_type")
   end

   function extract_generic_type(type_str::String, container::String)
       # "Vec<i32>" -> "i32"
       # Implementation: Extract with regex or parser
   end
   ```

---

### Task 6: Basic Generics Support

**Priority**: Medium
**Estimate**: 2 weeks

#### Implementation Details

1. **Generics Type Representation**

   ```julia
   # src/rusttypes.jl

   struct RustGeneric{T, Args}
       # T: Base type (e.g., Vec)
       # Args: Tuple of type parameters
   end

   # Example: Vec<i32> -> RustGeneric{Val{:Vec}, Tuple{Int32}}
   ```

2. **Generics Function Compilation**

   ```julia
   function compile_generic_rust_function(
       compiler::RustCompiler,
       code::String,
       type_params::Dict{Symbol, Type}
   )
       # 1. Replace type parameters with concrete types
       specialized_code = specialize_generic_code(code, type_params)

       # 2. Compile
       compile_rust_to_llvm(compiler, specialized_code)
   end

   function specialize_generic_code(code::String, type_params::Dict{Symbol, Type})
       # Replace type parameters with concrete types
       # Example: T -> i32
       specialized = code
       for (param, concrete_type) in type_params
           rust_type = juliatype_to_rust(concrete_type)
           specialized = replace(specialized, "T" => rust_type)
       end
       specialized
   end
   ```

---

### Task 7: Memory Management Integration

**Priority**: High
**Estimate**: 1 week

#### Implementation Details

1. **Ownership Management**

   ```julia
   # src/memory.jl

   # Rust object lifecycle management
   const rust_object_registry = Dict{Ptr{Cvoid}, Any}()

   function register_rust_object(ptr::Ptr{Cvoid}, obj::Any)
       rust_object_registry[ptr] = obj
       finalizer(obj) do x
           # Call drop on Rust side
           drop_rust_object(ptr)
           delete!(rust_object_registry, ptr)
       end
   end

   function drop_rust_object(ptr::Ptr{Cvoid})
       # Call Rust drop function
       # Implementation: Call Rust drop via ccall
   end
   ```

2. **Arc<T> Integration with Julia GC**

   ```julia
   function create_rust_arc(T::Type, value)
       # Call Arc::new on Rust side
       arc_ptr = ccall((:rust_arc_new, lib), Ptr{Cvoid}, (Any,), value)

       # Manage on Julia side
       arc = RustArc{T}(arc_ptr)
       register_rust_object(arc_ptr, arc)
       arc
   end
   ```

---

### Task 8: Performance Optimization

**Priority**: Medium
**Estimate**: 1 week

#### Implementation Details

1. **Inlining Optimization**

   ```julia
   function optimize_for_inlining(mod::LLVM.Module)
       # Mark small functions as inline candidates
       for fn in functions(mod)
           if length(parameters(fn)) <= 3 &&
              !has_attributes(fn, "noinline")
               add_inline_attribute!(fn)
           end
       end
   end
   ```

2. **Cache Improvement**

   ```julia
   # Persist compilation results
   const persistent_cache = Dict{String, String}()  # code_hash -> ir_file_path

   function get_cached_llvm_ir(code_hash::String)
       if haskey(persistent_cache, code_hash)
           ir_file = persistent_cache[code_hash]
           if isfile(ir_file)
               return parse_llvm_ir(ir_file)
           end
       end
       nothing
   end
   ```

---

### Task 9: Test Suite Extension

**Priority**: High
**Estimate**: 1 week

#### Implementation Details

1. **LLVM IR Integration Tests**

   ```julia
   # test/llvm.jl
   @testset "LLVM IR integration" begin
       rust_code = """
       pub fn add(a: i32, b: i32) -> i32 {
           a + b
       }
       """

       mod = compile_rust_to_llvm(RustCompiler(), rust_code)
       @test mod !== nothing

       fn = functions(mod)["add"]
       @test fn !== nothing
   end
   ```

2. **Ownership Type Tests**

   ```julia
   # test/ownership.jl
   @testset "Ownership types" begin
       # Test Box, Rc, Arc
   end
   ```

---

## Implementation Details

### File Structure (Extended)

```
src/
├── LastCall.jl              # Main module
├── rustmacro.jl         # @rust macro (extended)
├── ruststr.jl           # rust"" and irust"" (extended)
├── rusttypes.jl         # Rust type definitions (extended)
├── typetranslation.jl   # Type conversion (extended)
├── rustcompiler.jl      # Rust compiler integration (new)
├── llvmintegration.jl  # LLVM integration (new)
├── llvmoptimization.jl # LLVM optimization (new)
├── rustcodegen.jl      # Code generation (new)
├── rustinstances.jl    # Compiler instances (new)
├── memory.jl           # Memory management (new)
└── exceptions.jl       # Error handling (extended)
```

### Main Function Signatures (Extended)

```julia
# rustcompiler.jl
RustCompiler(; kwargs...) -> RustCompiler
compile_rust_to_llvm(compiler, code; output_file) -> LLVM.Module
compile_rust_to_llvm_cached(compiler, code) -> LLVM.Module

# llvmintegration.jl
parse_llvm_ir(ir_file) -> LLVM.Module
parse_llvm_ir_string(ir_string) -> LLVM.Module
get_llvm_context(name) -> LLVM.Context

# llvmoptimization.jl
optimize_llvm_module(mod, level) -> LLVM.Module
optimize_function(fn, level) -> Nothing
create_optimization_pipeline(level) -> ModulePassManager

# rustcodegen.jl
rustcall(CT, expr, args...) -> (generated function)
get_return_type_from_llvm(fn) -> Type
get_argument_types_from_llvm(fn) -> Vector{Type}
llvm_to_julia_type(llvm_ty) -> Type

# memory.jl
register_rust_object(ptr, obj) -> Nothing
drop_rust_object(ptr) -> Nothing
create_rust_arc(T, value) -> RustArc{T}
```

---

## Migration from Phase 1

Extend Phase 1 features in Phase 2:

1. **@rust macro**: Migrate from ccall to llvmcall
2. **rust"" string literal**: Migrate from shared library to LLVM IR generation
3. **Type system**: Extend from basic types to ownership types and collection types

---

## Limitations

Phase 2 still has the following limitations:

1. **Explicit lifetime handling**: Lifetime parameters are not yet fully supported
2. **Borrow checker**: Compile-time checks are performed on Rust side
3. **Macro system**: Full proc-macro support is not yet available

---

## Next Steps (Transition to Phase 3)

After Phase 2 is complete, implement the following features in Phase 3:

1. rustc internal API integration
2. Full lifetime support
3. Borrow checker integration
4. Full macro system support

---

## Reference Implementation

- Refer to Cxx.jl's `codegen.jl`
- Refer to LLVM.jl documentation
- Investigate Rust LLVM IR output
