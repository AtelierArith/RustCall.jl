# About Julia's llvmcall

## Overview

`llvmcall` is a low-level feature in Julia that allows direct embedding of LLVM IR (Intermediate Representation) into Julia code. This is equivalent to Julia's "inline assembly" but operates at the LLVM IR level, providing the advantage of being higher-level and more optimizable.

## Basic Syntax

`llvmcall` has two forms:

### Form 1: String Form

```julia
llvmcall(ir_string, return_type, arg_types_tuple, args...)
```

**Parameters**:
- `ir_string`: LLVM IR code (string)
- `return_type`: Return type
- `arg_types_tuple`: Tuple of argument types
- `args...`: Actual arguments

**Example**:

```julia
function add_ints(x::Int32, y::Int32)
    llvmcall("""
        %3 = add i32 %1, %0
        ret i32 %3
    """, Int32, (Int32, Int32), x, y)
end

# Usage example
result = add_ints(10, 20)  # => 30
```

### Form 2: Pointer Form

```julia
llvmcall(function_pointer, return_type, arg_types_tuple, args...)
```

**Parameters**:
- `function_pointer`: Pointer to LLVM function (`Ptr{Cvoid}`)
- `return_type`: Return type
- `arg_types_tuple`: Tuple of argument types
- `args...`: Actual arguments

**Example**:

```julia
# Get pointer to LLVM function (usually generated externally)
f = get_llvm_function_pointer()

function call_llvm_function(x, y)
    llvmcall(f, Int32, (Int32, Int32), x, y)
end
```

## Differences Between the Two Forms

### String Form Behavior

1. **Wrapping**: Julia wraps the provided LLVM IR in an LLVM function with the specified return type and argument types
2. **Argument conversion**: Julia performs argument conversion (unboxing, etc.) similar to `ccall`
3. **Inlining**: The generated call instruction is inlined

### Pointer Form Behavior

1. **No wrapping**: Julia skips wrapping and proceeds directly to argument conversion and inlining
2. **More efficient**: This form is more efficient when a complete LLVM function already exists
3. **Used in Cxx.jl**: Cxx.jl uses this form to directly embed LLVM IR generated by Clang

## LLVM IR Syntax

### Basic Instructions

```llvm
; Addition
%result = add i32 %a, %b

; Subtraction
%result = sub i32 %a, %b

; Multiplication
%result = mul i32 %a, %b

; Division
%result = sdiv i32 %a, %b  ; Signed division
%result = udiv i32 %a, %b  ; Unsigned division

; Return
ret i32 %result
ret void  ; No return value
```

### Types

```llvm
i8    ; 8-bit integer
i16   ; 16-bit integer
i32   ; 32-bit integer
i64   ; 64-bit integer
float ; 32-bit floating point
double; 64-bit floating point
void  ; No return value
```

### Argument References

In the string form, arguments are referenced as `%0`, `%1`, `%2`, ...:
- `%0`: First argument
- `%1`: Second argument
- And so on

**Note**: The argument order may be reversed in LLVM IR (e.g., `%1` is the first argument, `%0` is the second argument). This is due to LLVM's calling convention.

## Usage Examples

### Example 1: Basic Arithmetic Operations

```julia
function multiply(x::Int32, y::Int32)
    llvmcall("""
        %result = mul i32 %1, %0
        ret i32 %result
    """, Int32, (Int32, Int32), x, y)
end

multiply(5, 7)  # => 35
```

### Example 2: Floating Point Operations

```julia
function add_floats(x::Float64, y::Float64)
    llvmcall("""
        %result = fadd double %1, %0
        ret double %result
    """, Float64, (Float64, Float64), x, y)
end

add_floats(3.14, 2.71)  # => 5.85
```

### Example 3: Conditional Branching

```julia
function max_int(x::Int32, y::Int32)
    llvmcall("""
        %cmp = icmp sgt i32 %1, %0
        %result = select i1 %cmp, i32 %1, i32 %0
        ret i32 %result
    """, Int32, (Int32, Int32), x, y)
end

max_int(10, 20)  # => 20
```

### Example 4: Pointer Operations

```julia
function load_and_add(ptr::Ptr{Int32}, value::Int32)
    llvmcall("""
        %loaded = load i32, i32* %1
        %result = add i32 %loaded, %0
        ret i32 %result
    """, Int32, (Ptr{Int32}, Int32), ptr, value)
end
```

### Example 5: Using Pointer Form (Cxx.jl Style)

```julia
# Generate LLVM function in staged function
@generated function call_cpp_function(args...)
    # Generate LLVM function (actual implementation omitted)
    f = generate_llvm_function(args)

    # Generate llvmcall in pointer form
    Expr(:call, Core.Intrinsics.llvmcall,
        convert(Ptr{Cvoid}, f),
        get_return_type(args),
        Tuple{map(get_type, args)...},
        [:(args[$i]) for i in 1:length(args)]...)
end
```

## Optimization Benefits

An important advantage of `llvmcall` is that optimizations are executed **after** LLVM IR is inlined into Julia's IR. This enables:

1. **Constant propagation**: Constants propagate across both Julia and LLVM IR
2. **Dead code elimination**: Unused code is removed
3. **Inlining**: Function calls are inlined
4. **Loop optimization**: Loop optimizations are applied

This means that unlike machine code inline assembly, the compiler can see the entire code and optimize it.

## Notes

### 1. Argument Order

The reference order of arguments in LLVM IR may differ from Julia's argument order. Typically, `%0` is the last argument, `%1` is the previous argument, and so on in reverse order.

**Recommendation**: Test and verify, or use debug output to confirm the order.

### 2. Type Matching

Types in LLVM IR must exactly match Julia types:

```julia
# Correct
llvmcall("...", Int32, (Int32, Int32), x, y)

# Wrong (types don't match)
llvmcall("...", Int64, (Int32, Int32), x, y)  # Return type differs
```

### 3. Memory Safety

`llvmcall` is a low-level operation and does not guarantee memory safety. Be very careful when performing pointer operations.

### 4. Platform Dependencies

Some LLVM IR instructions may be platform-dependent. Write platform-independent code whenever possible.

## Usage in Cxx.jl

Cxx.jl uses the pointer form of `llvmcall` to embed LLVM IR generated by Clang into Julia:

```julia
# Cxx.jl internal implementation (simplified)
function createReturn(C, builder, f, argt, llvmargt, llvmrt, rett, rt, ret, state)
    # ... LLVM IR generation ...

    # Generate llvmcall expression
    Expr(:call, Core.Intrinsics.llvmcall,
        convert(Ptr{Cvoid}, f),  # Pointer to LLVM function generated by Clang
        rett,                     # Return type
        Tuple{argt...},          # Argument type tuple
        args2...)                # Actual arguments
end
```

This approach allows C++ code to be compiled with Clang and the generated LLVM IR to be directly embedded into Julia.

## Planned Usage in LastCall.jl

LastCall.jl (Phase 2) will use a similar approach:

```julia
# LastCall.jl internal implementation (planned)
@generated function rustcall(CT::RustInstance, expr, args...)
    # 1. Compile Rust code to LLVM IR
    llvm_mod = compile_rust_to_llvm(rust_code)

    # 2. Get function
    fn = functions(llvm_mod)[func_name]

    # 3. Embed into llvmcall
    Expr(:call, Core.Intrinsics.llvmcall,
        convert(Ptr{Cvoid}, fn),
        ret_type,
        Tuple{arg_types...},
        args...)
end
```

## Debugging

### Checking LLVM IR

To check generated LLVM IR, run Julia's code generation in debug mode:

```julia
# Check Julia code generation
@code_llvm function_name(args...)

# More detailed information
@code_llvm debug=true function_name(args...)
```

### Handling Errors

When errors occur with `llvmcall`:

1. **Type mismatch**: Check if types in LLVM IR match Julia types
2. **Argument order**: Check if argument reference order is correct
3. **Syntax errors**: Check if LLVM IR syntax is correct

## Performance

Using `llvmcall` provides the following performance benefits:

1. **Reduced function call overhead**: Inlining reduces function call overhead
2. **Optimization application**: LLVM optimization passes are applied
3. **Type specialization**: Combined with staged functions, type-specialized code can be generated

## References

- [Julia Manual: LLVM Call](https://docs.julialang.org/en/v1/manual/performance-tips/#man-llvm-call)
- [LLVM Language Reference Manual](https://llvm.org/docs/LangRef.html)
- [Cxx.jl Implementation](https://github.com/JuliaInterop/Cxx.jl)

## Summary

`llvmcall` is a powerful tool for low-level optimization in Julia. In particular:

- **String form**: Convenient for directly embedding simple LLVM IR code
- **Pointer form**: Efficient when using already-generated LLVM functions (used in Cxx.jl, LastCall.jl)

Packages like Cxx.jl and LastCall.jl achieve high-performance interop by compiling external language code (C++, Rust) to LLVM IR and integrating it into Julia using the pointer form of `llvmcall`.
