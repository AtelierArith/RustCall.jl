# Cxx.jl Project Overview

## Project Purpose

**Cxx.jl** is a Foreign Function Interface (FFI) package for directly calling C++ code from the Julia language. It enables interoperability between Julia and C++, allowing seamless use of C++ libraries and code from Julia.

## Main Features

### 1. C++ Foreign Function Interface (FFI)

- **Direct C++ calls**: Directly call C++ functions, classes, and namespaces from Julia
- **`@cxx` macro**: Execute C++ code leveraging Julia syntax
  - Static function calls: `@cxx mynamespace::func(args...)`
  - Member calls: `@cxx m->foo(args...)`
  - Value references: `@cxx foo`
- **String literals**:
  - `cxx""`: Evaluate C++ code in global scope (namespace, class, function, global variable declarations, etc.)
  - `icxx""`: Evaluate C++ code in function scope (execute function calls or computations)

### 2. C++ REPL Feature

- Add C++ REPL panel to Julia REPL
- Switch to C++ REPL mode with `<` key
- Interactively execute and test C++ code

### 3. Advanced Features

- **C++ class instantiation**: Create C++ objects with `@cxxnew` macro
- **Shared library support**: Load existing C++ shared libraries (.so, .dylib, .dll)
- **C++ enum support**: Directly access C++ enums from Julia
- **Type conversion**: Automatically convert types between Julia and C++

## Technical Implementation

### Architecture

Cxx.jl leverages the following advanced Julia features:

1. **LLVM IR Integration**
   - Use `llvmcall` to directly embed LLVM IR into Julia code
   - Integrate LLVM IR generated by Clang into Julia's compilation pipeline
   - Optimizations are applied to both Julia and C++ code

2. **Staged Functions**
   - Use `@generated` functions to leverage type information
   - Select appropriate C++ functions at compile time based on types
   - Resolve function overloading at compile time rather than runtime

3. **Macro and Staged Function Coordination**
   - `@cxx` macro parses syntax and passes type information to staged functions
   - Staged functions generate Clang AST and compile to LLVM IR
   - Finally executed via `llvmcall`

### Implementation Details

- **Clang integration**: Use Clang's C++ parser and semantic analysis
- **Type system**: Bridge Julia's type system and C++'s type system
- **Memory management**: C++ object lifecycle management (`CppPtr`, `CppRef`, `CppValue`)

## Project Structure

```
Cxx.jl/
├── src/
│   ├── Cxx.jl              # Main module
│   ├── clangwrapper.jl     # Clang API wrapper
│   ├── clanginstances.jl   # Clang instance management
│   ├── codegen.jl          # LLVM IR code generation
│   ├── cxxmacro.jl         # @cxx macro implementation
│   ├── cxxstr.jl           # cxx"" and icxx"" string literals
│   ├── cxxtypes.jl         # C++ type Julia representation
│   ├── typetranslation.jl  # Type conversion logic
│   ├── initialization.jl   # Initialization processing
│   ├── exceptions.jl       # C++ exception handling
│   ├── utils.jl            # Utility functions
│   ├── show.jl             # Display functions
│   ├── std.jl              # C++ standard library helpers
│   ├── autowrap.jl         # Auto-wrapping functionality
│   └── CxxREPL/
│       └── replpane.jl     # C++ REPL implementation
├── deps/
│   ├── build.jl            # Build script
│   ├── build_libcxxffi.jl  # libcxxffi build
│   └── llvm_patches/       # Patches to LLVM
├── docs/                   # Documentation
└── test/                   # Test suite
```

## Current Status and Limitations

### Supported Versions

- **Julia**: 1.1.x to 1.3.x only (currently unsupported versions)
- **Newer Julia versions**: Recommend using [CxxWrap.jl](https://github.com/JuliaInterop/CxxWrap.jl)
- **Platforms**: 64-bit Linux, macOS, Windows

### Known Limitations

- Functions cannot be redefined (can be worked around by creating a new compiler instance)
- Windows support is in early stages
- Manual fixes may be needed on macOS Sonoma

## Usage Examples

### Basic Usage

```julia
using Cxx

# Embed C++ code
cxx"""
    void print_hello() {
        std::cout << "Hello from C++!" << std::endl;
    }
"""

# Call as Julia function
julia_function() = @cxx print_hello()
julia_function()  # Outputs "Hello from C++!"
```

### Using Classes

```julia
cxx"""
    class MyClass {
    public:
        int value;
        MyClass(int v) : value(v) {}
        int get_value() { return value; }
    };
"""

obj = @cxxnew MyClass(42)
result = @cxx obj->get_value()  # 42
```

### Using Shared Libraries

```julia
using Cxx
using Libdl

# Load shared library
Libdl.dlopen("path/to/libexample.so", Libdl.RTLD_GLOBAL)
addHeaderDir("path/to/headers", kind=C_System)
cxxinclude("example.h")

# Use C++ class
obj = @cxxnew ExampleClass()
```

## Build Requirements

### System Requirements

In addition to the [system requirements](https://github.com/JuliaLang/julia#required-build-tools-and-external-libraries) needed to build Julia:

- **Debian/Ubuntu**: `libedit-dev`, `libncurses5-dev`
- **RedHat/CentOS**: `libedit-devel`

### Build Method

```julia
pkg> build Cxx
```

## Related Projects

- **[CxxWrap.jl](https://github.com/JuliaInterop/CxxWrap.jl)**: C++ interop package for newer Julia versions (recommended)

## References

- [Official Documentation](https://JuliaInterop.github.io/Cxx.jl/stable)
- [GitHub Repository](https://github.com/JuliaInterop/Cxx.jl)
