var documenterSearchIndex = {"docs":
[{"location":"crate_bindings/#External-Crate-Bindings-(Phase-6)","page":"External Crate Bindings","title":"External Crate Bindings (Phase 6)","text":"RustCall.jl provides a Maturin-like feature for generating Julia bindings from external Rust crates. This allows you to develop Rust libraries with the #[julia] attribute and automatically generate Julia bindings.","category":"section"},{"location":"crate_bindings/#Overview","page":"External Crate Bindings","title":"Overview","text":"The feature consists of two components:\n\njuliacall_macros - A Rust proc-macro crate that provides the #[julia] attribute\n@rust_crate - A Julia macro that scans external crates and generates bindings","category":"section"},{"location":"crate_bindings/#Quick-Start","page":"External Crate Bindings","title":"Quick Start","text":"","category":"section"},{"location":"crate_bindings/#Rust-Side","page":"External Crate Bindings","title":"Rust Side","text":"Create a Rust crate with juliacall_macros:\n\n# Cargo.toml\n[package]\nname = \"my_library\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\njuliacall_macros = { path = \"/path/to/RustCall.jl/deps/juliacall_macros\" }\n# Or from crates.io (when published):\n# juliacall_macros = \"0.1\"\n\n// src/lib.rs\nuse juliacall_macros::julia;\n\n#[julia]\nfn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n#[julia]\npub struct Counter {\n    pub value: i32,\n}\n\n#[julia]\nimpl Counter {\n    #[julia]\n    pub fn new(initial: i32) -> Self {\n        Self { value: initial }\n    }\n\n    #[julia]\n    pub fn increment(&mut self) {\n        self.value += 1;\n    }\n\n    #[julia]\n    pub fn get(&self) -> i32 {\n        self.value\n    }\n}","category":"section"},{"location":"crate_bindings/#Julia-Side","page":"External Crate Bindings","title":"Julia Side","text":"using RustCall\n\n# Generate and load bindings\n@rust_crate \"/path/to/my_library\"\n\n# Use the generated module\nresult = MyLibrary.add(1, 2)  # => 3\n\nc = MyLibrary.Counter(0)\nMyLibrary.increment(c)\nMyLibrary.get(c)  # => 1\n\n# Struct fields support property access syntax\nc.value        # => 1 (calls get_value)\nc.value = 5    # calls set_value","category":"section"},{"location":"crate_bindings/#The-#[julia]-Attribute","page":"External Crate Bindings","title":"The #[julia] Attribute","text":"The #[julia] attribute simplifies FFI function definitions.","category":"section"},{"location":"crate_bindings/#For-Functions","page":"External Crate Bindings","title":"For Functions","text":"// Before: verbose FFI declaration\n#[no_mangle]\npub extern \"C\" fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n// After: simple #[julia] attribute\n#[julia]\nfn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\nThe #[julia] attribute automatically:\n\nAdds #[no_mangle]\nMakes the function pub extern \"C\"","category":"section"},{"location":"crate_bindings/#For-Structs","page":"External Crate Bindings","title":"For Structs","text":"#[julia]\npub struct Point {\n    pub x: f64,\n    pub y: f64,\n}\n\nThis generates:\n\n#[repr(C)] for C-compatible layout\nPoint_free(ptr) - Free function\nPoint_get_x(ptr) / Point_set_x(ptr, value) - Field accessors\nPoint_get_y(ptr) / Point_set_y(ptr, value) - Field accessors\n\nOn the Julia side, you can access struct fields naturally:\n\np = MyModule.Point(3.0, 4.0)\np.x      # => 3.0 (uses Point_get_x)\np.y      # => 4.0 (uses Point_get_y)\np.x = 5.0  # (uses Point_set_x)","category":"section"},{"location":"crate_bindings/#For-Impl-Blocks","page":"External Crate Bindings","title":"For Impl Blocks","text":"#[julia]\nimpl Counter {\n    #[julia]\n    pub fn new(initial: i32) -> Self {\n        Self { value: initial }\n    }\n\n    #[julia]\n    pub fn get(&self) -> i32 {\n        self.value\n    }\n}\n\nThis generates FFI wrappers:\n\nCounter_new(initial) - Returns *mut Counter\nCounter_get(ptr) - Takes *const Counter, returns i32","category":"section"},{"location":"crate_bindings/#Property-Access-Syntax","page":"External Crate Bindings","title":"Property Access Syntax","text":"Generated struct wrappers support Julia's property access syntax for natural field access:\n\n# Instead of calling accessor functions directly:\nget_x(p)\nset_x(p, 5.0)\n\n# You can use dot notation:\np.x        # Get field value\np.x = 5.0  # Set field value\n\nThis works for all FFI-compatible field types (i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, bool, usize, isize).\n\nYou can also use propertynames() to list available fields:\n\np = MyModule.Point(1.0, 2.0)\npropertynames(p)  # => (:x, :y)","category":"section"},{"location":"crate_bindings/#API-Reference","page":"External Crate Bindings","title":"API Reference","text":"","category":"section"},{"location":"crate_bindings/#scan_crate(path)","page":"External Crate Bindings","title":"scan_crate(path)","text":"Scan a Rust crate and extract #[julia] marked items.\n\ninfo = scan_crate(\"/path/to/crate\")\n\nprintln(\"Crate: \", info.name)\nprintln(\"Functions: \", length(info.julia_functions))\nprintln(\"Structs: \", length(info.julia_structs))","category":"section"},{"location":"crate_bindings/#generate_bindings(path;-kwargs...)","page":"External Crate Bindings","title":"generate_bindings(path; kwargs...)","text":"Generate Julia bindings for an external crate.\n\nbindings = generate_bindings(\"/path/to/crate\",\n    output_module_name = \"MyBindings\",\n    build_release = true,\n    cache_enabled = true\n)\n\neval(bindings)\n\n# Now MyBindings module is available\nMyBindings.add(1, 2)","category":"section"},{"location":"crate_bindings/#@rust_crate","page":"External Crate Bindings","title":"@rust_crate","text":"Macro form for easy one-line usage.\n\n# Basic usage\n@rust_crate \"/path/to/crate\"\n\n# With options\n@rust_crate \"/path/to/crate\" name=\"CustomName\" release=true cache=true","category":"section"},{"location":"crate_bindings/#Type-Definitions","page":"External Crate Bindings","title":"Type Definitions","text":"","category":"section"},{"location":"crate_bindings/#CrateInfo","page":"External Crate Bindings","title":"CrateInfo","text":"Information about a scanned Rust crate.\n\nField Type Description\nname String Crate name\npath String Absolute path\nversion String Crate version\ndependencies Vector{DependencySpec} Dependencies\njulia_functions Vector{RustFunctionSignature} #[julia] functions\njulia_structs Vector{RustStructInfo} #[julia] structs\nsource_files Vector{String} .rs file paths","category":"section"},{"location":"crate_bindings/#CrateBindingOptions","page":"External Crate Bindings","title":"CrateBindingOptions","text":"Options for binding generation.\n\nField Type Default Description\noutput_module_name Union{String, Nothing} nothing Override module name\noutput_path Union{String, Nothing} nothing Write generated code to file\nuse_wrapper_crate Bool true Create wrapper crate\nbuild_release Bool true Build in release mode\ncache_enabled Bool true Enable library caching","category":"section"},{"location":"crate_bindings/#Build-Process","page":"External Crate Bindings","title":"Build Process","text":"When you call @rust_crate, RustCall.jl:\n\nScans the crate - Parses all .rs files for #[julia] attributes\nChecks cache - If a cached library exists with matching hash, uses it\nBuilds the crate - If the crate already has cdylib crate-type, builds directly; otherwise creates a wrapper crate\nGenerates Julia module - Creates wrapper functions and struct definitions\nLoads the library - Loads the compiled .so/.dylib/.dll","category":"section"},{"location":"crate_bindings/#Caching","page":"External Crate Bindings","title":"Caching","text":"Compiled libraries are cached based on source code hash:\n\n# Clear the cache\nclear_cargo_cache()\n\n# Check cache size\nget_cargo_cache_size()","category":"section"},{"location":"crate_bindings/#Supported-Types","page":"External Crate Bindings","title":"Supported Types","text":"The following Rust types are supported in #[julia] functions:\n\nRust Type Julia Type\ni8, i16, i32, i64 Int8, Int16, Int32, Int64\nu8, u16, u32, u64 UInt8, UInt16, UInt32, UInt64\nf32, f64 Float32, Float64\nbool Bool\nusize, isize UInt, Int\n() Cvoid\n*const T, *mut T Ptr{T}","category":"section"},{"location":"crate_bindings/#Example:-Complete-Workflow","page":"External Crate Bindings","title":"Example: Complete Workflow","text":"","category":"section"},{"location":"crate_bindings/#1.-Create-Rust-Crate","page":"External Crate Bindings","title":"1. Create Rust Crate","text":"cargo new --lib my_math\ncd my_math","category":"section"},{"location":"crate_bindings/#2.-Configure-Cargo.toml","page":"External Crate Bindings","title":"2. Configure Cargo.toml","text":"[package]\nname = \"my_math\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\njuliacall_macros = { path = \"/path/to/RustCall.jl/deps/juliacall_macros\" }","category":"section"},{"location":"crate_bindings/#3.-Write-Rust-Code","page":"External Crate Bindings","title":"3. Write Rust Code","text":"// src/lib.rs\nuse juliacall_macros::julia;\n\n#[julia]\nfn factorial(n: u64) -> u64 {\n    (1..=n).product()\n}\n\n#[julia]\nfn fibonacci(n: u32) -> u64 {\n    match n {\n        0 => 0,\n        1 => 1,\n        _ => {\n            let mut a = 0u64;\n            let mut b = 1u64;\n            for _ in 2..=n {\n                let c = a + b;\n                a = b;\n                b = c;\n            }\n            b\n        }\n    }\n}","category":"section"},{"location":"crate_bindings/#4.-Use-in-Julia","page":"External Crate Bindings","title":"4. Use in Julia","text":"using RustCall\n\n@rust_crate \"/path/to/my_math\"\n\nfactorial(UInt64(10))  # => 3628800\nfibonacci(UInt32(20))  # => 6765","category":"section"},{"location":"crate_bindings/#Precompilation-Support","page":"External Crate Bindings","title":"Precompilation Support","text":"For package development, you can generate bindings to a file that will be precompiled with your package, improving startup time.","category":"section"},{"location":"crate_bindings/#Generating-Bindings-to-a-File","page":"External Crate Bindings","title":"Generating Bindings to a File","text":"using RustCall\n\n# Generate bindings and write to a file\nwrite_bindings_to_file(\n    \"deps/my_rust_crate\",              # Path to Rust crate\n    \"src/generated/MyRustBindings.jl\", # Output file\n    output_module_name = \"MyRust\",\n    relative_lib_path = \"../deps/lib\"  # Path relative to the output file\n)","category":"section"},{"location":"crate_bindings/#Package-Development-Workflow","page":"External Crate Bindings","title":"Package Development Workflow","text":"Set up your package structure:\nMyPackage/\n├── Project.toml\n├── src/\n│   ├── MyPackage.jl\n│   └── generated/\n│       └── MyRustBindings.jl  # Generated bindings\n├── deps/\n│   ├── my_rust_crate/         # Your Rust crate\n│   └── lib/                   # Compiled library\n└── test/\nGenerate bindings during development:\nusing RustCall\nwrite_bindings_to_file(\n    \"deps/my_rust_crate\",\n    \"src/generated/MyRustBindings.jl\",\n    output_module_name = \"MyRust\",\n    relative_lib_path = \"../deps/lib\"\n)\nInclude in your package:\n# In src/MyPackage.jl\nmodule MyPackage\n\ninclude(\"generated/MyRustBindings.jl\")\nusing .MyRust\n\n# Re-export functions if desired\nexport add, multiply\n\nend\nThe generated file uses @__DIR__ for library paths, ensuring it works when the package is installed elsewhere.","category":"section"},{"location":"crate_bindings/#API-Reference-2","page":"External Crate Bindings","title":"API Reference","text":"","category":"section"},{"location":"crate_bindings/#write_bindings_to_file","page":"External Crate Bindings","title":"write_bindings_to_file","text":"write_bindings_to_file(\n    crate_path::String,\n    output_path::String;\n    output_module_name = nothing,\n    build_release = true,\n    relative_lib_path = nothing\n) -> String\n\nParameter Type Description\ncrate_path String Path to the Rust crate\noutput_path String Path for the generated Julia file\noutput_module_name String Name for the generated module\nbuild_release Bool Build in release mode\nrelative_lib_path String Path for library relative to output file","category":"section"},{"location":"crate_bindings/#emit_crate_module_code","page":"External Crate Bindings","title":"emit_crate_module_code","text":"emit_crate_module_code(\n    info::CrateInfo,\n    lib_path::String;\n    module_name = nothing,\n    use_relative_path = false\n) -> String\n\nReturns the generated Julia module code as a string.","category":"section"},{"location":"crate_bindings/#Troubleshooting","page":"External Crate Bindings","title":"Troubleshooting","text":"","category":"section"},{"location":"crate_bindings/#Crate-not-building","page":"External Crate Bindings","title":"Crate not building","text":"Ensure your crate has:\n\ncrate-type = [\"cdylib\"] in [lib] section\njuliacall_macros as a dependency\nValid Rust code that compiles","category":"section"},{"location":"crate_bindings/#Functions-not-found","page":"External Crate Bindings","title":"Functions not found","text":"Check that:\n\nFunctions have the #[julia] attribute\nFunction signatures use FFI-compatible types\nThe crate builds without errors","category":"section"},{"location":"crate_bindings/#Type-errors","page":"External Crate Bindings","title":"Type errors","text":"Ensure you're using the correct Julia types that match the Rust function signatures.","category":"section"},{"location":"crate_bindings/#Precompilation-issues","page":"External Crate Bindings","title":"Precompilation issues","text":"If you encounter precompilation issues:\n\nEnsure the library path is correct (use relative_lib_path for portable packages)\nCheck that the library was copied to the correct location\nVerify the generated code compiles without errors","category":"section"},{"location":"precompilation/#Precompilation-Support","page":"Precompilation","title":"Precompilation Support","text":"RustCall.jl supports Julia's precompilation system, enabling faster startup times for packages that use Rust bindings.","category":"section"},{"location":"precompilation/#Overview","page":"Precompilation","title":"Overview","text":"When you use @rust_crate in a Julia package, the bindings can be precompiled along with your package. This avoids runtime compilation and significantly reduces startup time.","category":"section"},{"location":"precompilation/#Benefits","page":"Precompilation","title":"Benefits","text":"Faster startup: Precompiled bindings load instantly\nDeployment-ready: No compilation needed at runtime\nReproducible builds: Same bindings every time\nPackageCompiler.jl compatible: Works with standalone applications","category":"section"},{"location":"precompilation/#How-It-Works","page":"Precompilation","title":"How It Works","text":"","category":"section"},{"location":"precompilation/#Runtime-vs-Precompile-Time","page":"Precompilation","title":"Runtime vs Precompile Time","text":"Without precompilation (using @rust_crate directly):\n\nJulia loads your package\n@rust_crate scans the Rust crate\nRust code is compiled (if not cached)\nBindings are generated and evaluated\n\nWith precompilation (using write_bindings_to_file):\n\nDuring development: Generate bindings file once\nDuring precompilation: Julia compiles the bindings module\nAt runtime: Precompiled bindings load instantly","category":"section"},{"location":"precompilation/#The-Generation-Process","page":"Precompilation","title":"The Generation Process","text":"Rust Crate               Julia Bindings File\n    │                           │\n    ├── Cargo.toml              │\n    ├── src/                    │\n    │   └── lib.rs ──────────►  MyBindings.jl\n    │                           │\n    └── target/                 │\n        └── release/            │\n            └── lib*.so ◄───────┘","category":"section"},{"location":"precompilation/#Usage-Guide","page":"Precompilation","title":"Usage Guide","text":"","category":"section"},{"location":"precompilation/#Step-1:-Project-Structure","page":"Precompilation","title":"Step 1: Project Structure","text":"Set up your package with this structure:\n\nMyPackage/\n├── Project.toml\n├── src/\n│   ├── MyPackage.jl          # Main module\n│   └── generated/\n│       └── RustBindings.jl   # Generated bindings (gitignore this)\n├── deps/\n│   ├── my_rust_crate/        # Your Rust crate\n│   │   ├── Cargo.toml\n│   │   └── src/lib.rs\n│   └── lib/                  # Compiled library location\n│       └── libmy_rust_crate.{so,dylib,dll}\n└── build.jl                  # Build script","category":"section"},{"location":"precompilation/#Step-2:-Build-Script","page":"Precompilation","title":"Step 2: Build Script","text":"Create a build.jl to generate bindings:\n\n# deps/build.jl\nusing RustCall\n\n# Path to Rust crate\ncrate_path = joinpath(@__DIR__, \"my_rust_crate\")\n\n# Output path for generated bindings\nbindings_path = joinpath(dirname(@__DIR__), \"src\", \"generated\", \"RustBindings.jl\")\n\n# Generate bindings\nwrite_bindings_to_file(\n    crate_path,\n    bindings_path,\n    output_module_name = \"RustBindings\",\n    build_release = true,\n    relative_lib_path = \"../../deps/lib\"\n)","category":"section"},{"location":"precompilation/#Step-3:-Package-Module","page":"Precompilation","title":"Step 3: Package Module","text":"Include the generated bindings in your package:\n\n# src/MyPackage.jl\nmodule MyPackage\n\n# Include generated bindings\ninclude(\"generated/RustBindings.jl\")\nusing .RustBindings\n\n# Re-export functions\nexport add, multiply, MyStruct\n\n# Your Julia code here...\n\nend","category":"section"},{"location":"precompilation/#Step-4:-Build-During-Development","page":"Precompilation","title":"Step 4: Build During Development","text":"Run the build script during development:\n\nusing Pkg\nPkg.build(\"MyPackage\")\n\nOr manually:\n\ninclude(\"deps/build.jl\")","category":"section"},{"location":"precompilation/#PackageCompiler.jl-Integration","page":"Precompilation","title":"PackageCompiler.jl Integration","text":"RustCall.jl works with PackageCompiler.jl for creating standalone applications.","category":"section"},{"location":"precompilation/#Creating-a-System-Image","page":"Precompilation","title":"Creating a System Image","text":"using PackageCompiler\n\ncreate_sysimage(\n    :MyPackage,\n    sysimage_path = \"my_sysimage.so\",\n    precompile_execution_file = \"precompile_script.jl\"\n)","category":"section"},{"location":"precompilation/#Creating-an-App","page":"Precompilation","title":"Creating an App","text":"using PackageCompiler\n\ncreate_app(\n    \".\",                    # Package directory\n    \"build\",               # Output directory\n    executables = [\"main\" => \"main.jl\"]\n)","category":"section"},{"location":"precompilation/#Important-Considerations","page":"Precompilation","title":"Important Considerations","text":"Library Path: Use relative_lib_path to ensure the compiled library is found relative to the bindings file\nCopy Library: Ensure the compiled .so/.dylib/.dll is included in the app bundle\nPrecompile Script: Include calls to your Rust-backed functions in the precompile script\n\nExample precompile script:\n\n# precompile_script.jl\nusing MyPackage\n\n# Warm up the functions\nMyPackage.add(Int32(1), Int32(2))\nMyPackage.multiply(1.0, 2.0)","category":"section"},{"location":"precompilation/#Cache-Behavior","page":"Precompilation","title":"Cache Behavior","text":"","category":"section"},{"location":"precompilation/#During-Development","page":"Precompilation","title":"During Development","text":"FirstCall.jl caches compiled libraries in ~/.julia/rustcall_cache/\nCache is keyed by source code hash\nRebuilding only happens when source changes","category":"section"},{"location":"precompilation/#During-Precompilation","page":"Precompilation","title":"During Precompilation","text":"Generated bindings reference a fixed library path\nLibrary must exist at the specified path\nNo runtime compilation occurs","category":"section"},{"location":"precompilation/#Cache-Functions","page":"Precompilation","title":"Cache Functions","text":"# Clear the cache\nclear_cache()\n\n# Check cache size\nget_cache_size()\n\n# List cached libraries\nlist_cached_libraries()\n\n# Clean up old cache entries\ncleanup_old_cache(max_age_days=30)","category":"section"},{"location":"precompilation/#Troubleshooting","page":"Precompilation","title":"Troubleshooting","text":"","category":"section"},{"location":"precompilation/#Library-Not-Found","page":"Precompilation","title":"Library Not Found","text":"Error: could not load library \"...\" at runtime\n\nSolutions:\n\nVerify relative_lib_path points to the correct location\nCheck that the library was copied during build\nEnsure the library has correct permissions\n\n# Debug: Check the library path\nbindings_dir = dirname(pathof(MyPackage))\nlib_path = joinpath(bindings_dir, \"..\", \"deps\", \"lib\", \"libmy_crate.so\")\n@info \"Library exists?\" isfile(lib_path)","category":"section"},{"location":"precompilation/#Precompilation-Fails","page":"Precompilation","title":"Precompilation Fails","text":"Error: LoadError during precompilation\n\nSolutions:\n\nEnsure __init__() function loads the library correctly\nCheck that library path uses @__DIR__ for portability\nVerify the generated code syntax","category":"section"},{"location":"precompilation/#Version-Mismatch","page":"Precompilation","title":"Version Mismatch","text":"Symptom: Functions behave unexpectedly after updating Rust code\n\nSolution: Regenerate bindings after modifying Rust code:\n\nPkg.build(\"MyPackage\")","category":"section"},{"location":"precompilation/#Platform-Specific-Issues","page":"Precompilation","title":"Platform-Specific Issues","text":"macOS:\n\nLibrary extension is .dylib\nMay need to handle code signing\n\nLinux:\n\nLibrary extension is .so\nCheck LD_LIBRARY_PATH if needed\n\nWindows:\n\nLibrary extension is .dll\nPlace DLLs in the same directory as the Julia process or in PATH","category":"section"},{"location":"precompilation/#Best-Practices","page":"Precompilation","title":"Best Practices","text":"Gitignore generated files: Add src/generated/ to .gitignore\nVersion your Rust code: Keep Rust crate under version control\nCI/CD integration: Run Pkg.build() in CI to generate fresh bindings\nTest precompilation: Include precompilation in your test suite\nDocument dependencies: Note Rust toolchain requirements in README","category":"section"},{"location":"precompilation/#Example:-Complete-Package","page":"Precompilation","title":"Example: Complete Package","text":"Here's a complete example of a precompilable package:\n\n# Project.toml\nname = \"MyRustPackage\"\nuuid = \"...\"\nversion = \"0.1.0\"\n\n[deps]\nRustCall = \"...\"\n\n[extras]\nTest = \"...\"\n\n[targets]\ntest = [\"Test\"]\n\n# deps/build.jl\nusing RustCall\n\nwrite_bindings_to_file(\n    joinpath(@__DIR__, \"rust_crate\"),\n    joinpath(dirname(@__DIR__), \"src\", \"generated\", \"Bindings.jl\"),\n    output_module_name = \"Bindings\",\n    relative_lib_path = \"../../deps/lib\"\n)\n\n# src/MyRustPackage.jl\nmodule MyRustPackage\n\ninclude(\"generated/Bindings.jl\")\nusing .Bindings\n\nexport rust_add, rust_multiply\n\nrust_add(a, b) = Bindings.add(Int32(a), Int32(b))\nrust_multiply(a, b) = Bindings.multiply(Float64(a), Float64(b))\n\nend","category":"section"},{"location":"precompilation/#See-Also","page":"Precompilation","title":"See Also","text":"External Crate Bindings - Full API reference\nJulia Precompilation - Official Julia documentation\nPackageCompiler.jl - Creating standalone applications","category":"section"},{"location":"status/#Project-Status","page":"Project Status","title":"Project Status","text":"Last updated: 2026-02-07","category":"section"},{"location":"status/#Summary","page":"Project Status","title":"Summary","text":"Item Current State\nCore FFI (rust\"\"\", @rust, @irust) ✅ Implemented\nLLVM integration (@rust_llvm) ✅ Implemented (experimental path)\nCargo dependency integration ✅ Implemented\nStruct/object mapping ✅ Implemented\n#[julia] attribute support ✅ Implemented\nExternal crate bindings (@rust_crate) ✅ Implemented\nHot reload support ✅ Implemented\nRoot Julia tests ✅ Present (test/runtests.jl)\nCI (Julia + Rust proc-macro checks) ✅ Configured","category":"section"},{"location":"status/#Codebase-Snapshot","page":"Project Status","title":"Codebase Snapshot","text":"Based on the repository state on 2026-02-07:\n\nArea Files Approx. Lines\nJulia source (src/*.jl) 22 12,750\nJulia tests (test/*.jl) 28 5,769\nBenchmarks (benchmark/*.jl) 5 1,455\nRust helpers (deps/rust_helpers/src/lib.rs) 1 626\nProc-macro crate (deps/juliacall_macros) 5 Rust files 1,256","category":"section"},{"location":"status/#Architecture-Map","page":"Project Status","title":"Architecture Map","text":"","category":"section"},{"location":"status/#Julia-entry-points","page":"Project Status","title":"Julia entry points","text":"src/RustCall.jl: module entrypoint, exports, initialization.\nsrc/ruststr.jl: rust\"\"\" processing, compilation/load integration.\nsrc/rustmacro.jl: @rust, @irust, call expansion.","category":"section"},{"location":"status/#Compilation-and-code-generation","page":"Project Status","title":"Compilation and code generation","text":"src/compiler.jl: rustc invocation and compile orchestration.\nsrc/codegen.jl: ccall generation utilities.\nsrc/llvmintegration.jl, src/llvmcodegen.jl, src/llvmoptimization.jl: LLVM path.","category":"section"},{"location":"status/#Type-and-runtime-layer","page":"Project Status","title":"Type and runtime layer","text":"src/types.jl: Rust wrapper types (RustResult, RustOption, ownership types).\nsrc/typetranslation.jl: Rust/Julia type mapping.\nsrc/exceptions.jl: error conversion and diagnostics.\nsrc/memory.jl: ownership helper interop.","category":"section"},{"location":"status/#Cargo/crate-workflows","page":"Project Status","title":"Cargo/crate workflows","text":"src/dependencies.jl, src/dependency_resolution.jl: dependency parsing/resolution.\nsrc/cargoproject.jl, src/cargobuild.jl: Cargo project/build flow.\nsrc/julia_functions.jl: #[julia] parsing/transform/wrapper support.\nsrc/crate_bindings.jl: crate scanning, binding generation, @rust_crate.\nsrc/hot_reload.jl: crate hot reload support.","category":"section"},{"location":"status/#Caching-and-generics","page":"Project Status","title":"Caching and generics","text":"src/cache.jl: compiled artifact cache.\nsrc/generics.jl: monomorphization and generic function support.","category":"section"},{"location":"status/#Test-and-CI-Status","page":"Project Status","title":"Test and CI Status","text":"","category":"section"},{"location":"status/#Julia-tests","page":"Project Status","title":"Julia tests","text":"Root entry point: test/runtests.jl\nCoverage includes cache, ownership, arrays, generics, error handling, LLVM path, external crates, #[julia], crate bindings, hot reload, and regressions.","category":"section"},{"location":"status/#Rust-proc-macro-tests","page":"Project Status","title":"Rust proc-macro tests","text":"Location: deps/juliacall_macros/tests/\nCI runs cargo fmt --check, cargo clippy --all-targets --all-features -- -D warnings, and cargo test --all-features.","category":"section"},{"location":"status/#GitHub-Actions","page":"Project Status","title":"GitHub Actions","text":"Workflow: .github/workflows/CI.yml\nMatrix includes Julia tests across Linux/macOS/Windows and Rust proc-macro checks across toolchains/OSes.","category":"section"},{"location":"status/#Tooling-Requirements","page":"Project Status","title":"Tooling Requirements","text":"Julia 1.12+ (see Project.toml compat)\nRust toolchain (rustc, cargo)\n\nFor ownership/runtime helper features, run:\n\nusing Pkg\nPkg.build(\"RustCall\")","category":"section"},{"location":"status/#Near-Term-Priorities","page":"Project Status","title":"Near-Term Priorities","text":"Stabilize and document @rust_llvm behavior across more type patterns.\nContinue regression hardening for crate binding and hot reload workflows.\nPrepare distribution tasks (Julia General registry flow, crates.io publication for proc-macro tooling).","category":"section"},{"location":"design/Phase1/#Phase-1:-Basic-Implementation-via-C-Compatible-ABI-(MVP)","page":"Phase 1","title":"Phase 1: Basic Implementation via C-Compatible ABI (MVP)","text":"","category":"section"},{"location":"design/Phase1/#Overview","page":"Phase 1","title":"Overview","text":"In Phase 1, we implement basic functionality to call Rust functions from Julia using a C-compatible ABI (Application Binary Interface). This phase focuses on basic types and function calls, without using advanced Rust features (generics, traits, ownership system, etc.).\n\nTarget Duration: 2-3 months Deliverable: Basic @rust macro, type mapping, string literals, error handling\n\n","category":"section"},{"location":"design/Phase1/#Implementation-Task-List","page":"Phase 1","title":"Implementation Task List","text":"","category":"section"},{"location":"design/Phase1/#Task-1:-Project-Structure-Setup","page":"Phase 1","title":"Task 1: Project Structure Setup","text":"Priority: Highest Estimate: 1 day","category":"section"},{"location":"design/Phase1/#Implementation-Details","page":"Phase 1","title":"Implementation Details","text":"Create Project Directory\nRustCall.jl/\n├── Project.toml\n├── README.md\n├── src/\n│   ├── RustCall.jl\n│   ├── rustmacro.jl\n│   ├── ruststr.jl\n│   ├── rusttypes.jl\n│   ├── typetranslation.jl\n│   ├── exceptions.jl\n│   └── utils.jl\n├── deps/\n│   ├── build.jl\n│   └── build_librustffi.jl\n├── test/\n│   ├── runtests.jl\n│   ├── basic.jl\n│   ├── types.jl\n│   └── strings.jl\n└── docs/\n    └── src/\n        └── index.md\nCreate Project.toml\nname = \"Rust\"\nuuid = \"...\" # Generated UUID\nversion = \"0.1.0\"\n\n[deps]\nLibdl = \"8f399da3-3557-5675-b5ff-fb832c97cbdb\"\nREPL = \"3fa0cd96-eef1-5676-8a61-b3b8758bbffb\"\n\n[extras]\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\n[targets]\ntest = [\"Test\"]\nBasic Module Structure\n# src/RustCall.jl\n__precompile__(true)\nmodule Rust\n\nmodule RustCore\n    # Internal implementation\nend\n\n# Public API\nexport @rust, @rust_str, @irust_str\n# ...\n\nend\n\n","category":"section"},{"location":"design/Phase1/#Task-2:-Basic-Type-System-Implementation","page":"Phase 1","title":"Task 2: Basic Type System Implementation","text":"Priority: Highest Estimate: 1 week","category":"section"},{"location":"design/Phase1/#Implementation-Details-2","page":"Phase 1","title":"Implementation Details","text":"Julia Representation of Rust Types\n# src/rusttypes.jl\n\n# Basic type mapping\nconst RUST_TYPE_MAP = Dict(\n    :i8 => Int8,\n    :i16 => Int16,\n    :i32 => Int32,\n    :i64 => Int64,\n    :u8 => UInt8,\n    :u16 => UInt16,\n    :u32 => UInt32,\n    :u64 => UInt64,\n    :f32 => Float32,\n    :f64 => Float64,\n    :bool => Bool,\n    :usize => UInt,  # Platform-dependent\n    :isize => Int,   # Platform-dependent\n)\n\n# Pointer type\nstruct RustPtr{T}\n    ptr::Ptr{Cvoid}\nend\n\n# Reference type (treated as Ref on Julia side)\nstruct RustRef{T}\n    ptr::Ptr{Cvoid}\nend\n\n# Result type\nstruct RustResult{T, E}\n    is_ok::Bool\n    value::Union{T, E}\n\n    function RustResult{T, E}(is_ok::Bool, value) where {T, E}\n        new(is_ok, value)\n    end\nend\n\n# Option type\nstruct RustOption{T}\n    is_some::Bool\n    value::Union{T, Nothing}\n\n    function RustOption{T}(is_some::Bool, value) where {T}\n        new(is_some, value)\n    end\nend\nType Conversion Functions\n# src/typetranslation.jl\n\n\"\"\"\nConvert Rust type name (Symbol) to Julia type\n\"\"\"\nfunction rusttype_to_julia(rust_type::Symbol)\n    get(RUST_TYPE_MAP, rust_type) do\n        error(\"Unsupported Rust type: $rust_type\")\n    end\nend\n\n\"\"\"\nConvert Julia type to Rust type name (String)\n\"\"\"\nfunction juliatype_to_rust(julia_type::Type)\n    for (rust_sym, julia_typ) in RUST_TYPE_MAP\n        if julia_typ == julia_type\n            return string(rust_sym)\n        end\n    end\n    error(\"Unsupported Julia type: $julia_type\")\nend\n\n\"\"\"\nParse Rust function signature to extract type information\n\"\"\"\nfunction parse_rust_signature(sig::String)\n    # Example: \"fn add(a: i32, b: i32) -> i32\"\n    # Implementation: Parse with regex or parser\n    # Return: (function name, array of argument types, return type)\nend\n\n","category":"section"},{"location":"design/Phase1/#Task-3:-Basic-Implementation-of-@rust-Macro","page":"Phase 1","title":"Task 3: Basic Implementation of @rust Macro","text":"Priority: Highest Estimate: 1 week","category":"section"},{"location":"design/Phase1/#Implementation-Details-3","page":"Phase 1","title":"Implementation Details","text":"Basic Macro Structure\n# src/rustmacro.jl\n\n\"\"\"\n    @rust expr\n\nCall a Rust function from Julia using C-compatible ABI.\n\nExamples:\n    @rust add(10, 20)\n    @rust mymodule::myfunction(x, y)\n\"\"\"\nmacro rust(expr)\n    rust_impl(__module__, expr)\nend\n\nfunction rust_impl(mod, expr)\n    if isexpr(expr, :call)\n        build_rust_call(mod, expr)\n    elseif isexpr(expr, Symbol(\"::\"))\n        build_rust_namespace_ref(mod, expr)\n    else\n        error(\"Unsupported Rust expression: $expr\")\n    end\nend\nFunction Call Construction\nfunction build_rust_call(mod, expr)\n    if !isexpr(expr, :call)\n        error(\"Expected a function call, got: $expr\")\n    end\n\n    fname = expr.args[1]\n    args = expr.args[2:end]\n\n    # Get function name\n    func_name = isa(fname, Symbol) ? string(fname) : error(\"Function name must be a Symbol\")\n\n    # Get current library\n    lib_name = get_current_lib_name()\n\n    # Infer type information (determined at runtime)\n    # Note: In Phase 1, type information may need to be explicitly specified\n\n    # Generate ccall\n    quote\n        ccall((Symbol($func_name), $lib_name),\n              Any,  # Return type (to be improved later)\n              ($(map(_ -> :Any, args)...),),  # Argument types (to be improved later)\n              $(map(esc, args)...))\n    end\nend\nLibrary Management\n# src/utils.jl\n\n# Manage currently loaded Rust libraries\nconst loaded_libraries = Dict{String, Ptr{Cvoid}}()\nconst current_lib_name = Ref{String}(\"\")\n\nfunction get_current_lib_name()\n    if isempty(current_lib_name[])\n        error(\"No Rust library loaded. Use rust\\\"\\\" to load a library first.\")\n    end\n    current_lib_name[]\nend\n\nfunction set_current_lib_name(name::String)\n    current_lib_name[] = name\nend\n\nfunction register_library(name::String, lib::Ptr{Cvoid})\n    loaded_libraries[name] = lib\n    set_current_lib_name(name)\nend\n\n","category":"section"},{"location":"design/Phase1/#Task-4:-Implementation-of-rust\"\"-String-Literal","page":"Phase 1","title":"Task 4: Implementation of rust\"\" String Literal","text":"Priority: High Estimate: 1 week","category":"section"},{"location":"design/Phase1/#Implementation-Details-4","page":"Phase 1","title":"Implementation Details","text":"Macro Implementation\n# src/ruststr.jl\n\n\"\"\"\n    rust\"C++ code\"\n\nCompile and load Rust code as a shared library.\nThe code will be wrapped in a C-compatible interface.\n\nExample:\n    rust\\\"\"\"\n        #[no_mangle]\n        pub extern \"C\" fn add(a: i32, b: i32) -> i32 {\n            a + b\n        }\n    \\\"\"\"\n\"\"\"\nmacro rust_str(str, args...)\n    process_rust_string(str, true, __source__)\nend\nRust Code Compilation\nfunction process_rust_string(str::String, global_scope::Bool, source)\n    # 1. Write to temporary file\n    tmp_file = tempname() * \".rs\"\n    write(tmp_file, wrap_rust_code(str))\n\n    # 2. Compile\n    lib_path = compile_rust_file(tmp_file)\n\n    # 3. Load shared library\n    lib = Libdl.dlopen(lib_path, Libdl.RTLD_GLOBAL)\n\n    # 4. Register library\n    lib_name = basename(lib_path)\n    register_library(lib_name, lib)\n\n    # 5. Register functions (optional)\n    register_functions_from_lib(lib)\n\n    nothing\nend\n\nfunction wrap_rust_code(code::String)\n    # Wrap Rust code as needed\n    # Example: Add extern \"C\" block, etc.\n    code\nend\n\nfunction compile_rust_file(rs_file::String)\n    lib_ext = @static Sys.iswindows() ? \".dll\" : (@static Sys.isapple() ? \".dylib\" : \".so\")\n    lib_path = rs_file * lib_ext\n\n    # Compile with rustc\n    cmd = `rustc --crate-type cdylib -o $lib_path $rs_file`\n    run(cmd)\n\n    if !isfile(lib_path)\n        error(\"Failed to compile Rust file: $rs_file\")\n    end\n\n    lib_path\nend\nAutomatic Function Registration (Optional)\nfunction register_functions_from_lib(lib::Ptr{Cvoid})\n    # Detect exported functions from shared library\n    # Note: This requires complex implementation (using tools like objdump, nm)\n    # Manual registration is acceptable in Phase 1\nend\n\n","category":"section"},{"location":"design/Phase1/#Task-5:-Implementation-of-irust\"\"-String-Literal-(Limited-Version)","page":"Phase 1","title":"Task 5: Implementation of irust\"\" String Literal (Limited Version)","text":"Priority: Medium Estimate: 3 days","category":"section"},{"location":"design/Phase1/#Implementation-Details-5","page":"Phase 1","title":"Implementation Details","text":"Macro Implementation\n\"\"\"\n    irust\"Rust code\"\n\nExecute Rust code at function scope.\nNote: This is limited in Phase 1 and may require\ncompilation to a separate function.\n\nExample:\n    function myfunc(x)\n        irust\\\"\"\"\n            let result = $(x) * 2;\n            result\n        \\\"\"\"\n    end\n\"\"\"\nmacro irust_str(str, args...)\n    process_irust_string(str, __source__)\nend\nLimited Version Implementation\nfunction process_irust_string(str::String, source)\n    # In Phase 1, irust\"\" has the following limitations:\n    # 1. Single expression only\n    # 2. Return value must be basic type only\n    # 3. Compiled as a function\n\n    # Generate temporary Rust function\n    func_name = \"irust_func_$(hash(str))\"\n    rust_code = \"\"\"\n    #[no_mangle]\n    pub extern \"C\" fn $func_name($(extract_args(str))) -> $(extract_return_type(str)) {\n        $str\n    }\n    \"\"\"\n\n    # Compile and execute\n    # (Implementation similar to rust\"\")\nend\n\n","category":"section"},{"location":"design/Phase1/#Task-6:-Result-Type-Support","page":"Phase 1","title":"Task 6: Result Type Support","text":"Priority: High Estimate: 1 week","category":"section"},{"location":"design/Phase1/#Implementation-Details-6","page":"Phase 1","title":"Implementation Details","text":"Result Type Definition (Repeated)\n# src/rusttypes.jl\n\nstruct RustResult{T, E}\n    is_ok::Bool\n    value::Union{T, E}\nend\n\n# Convenience functions\nfunction unwrap(result::RustResult{T, E}) where {T, E}\n    if result.is_ok\n        return result.value::T\n    else\n        error(\"Unwrap failed: $(result.value::E)\")\n    end\nend\n\nfunction unwrap_or(result::RustResult{T, E}, default::T) where {T, E}\n    result.is_ok ? result.value::T : default\nend\nHandling Result Type on Rust Side\n// Example on Rust side\n#[repr(C)]\npub struct RustResult<T, E> {\n    pub is_ok: bool,\n    pub value: *mut c_void,  // Pointer to T or E\n}\n\n#[no_mangle]\npub extern \"C\" fn divide(a: f64, b: f64) -> RustResult<f64, *const i8> {\n    if b == 0.0 {\n        let err_msg = CString::new(\"Division by zero\").unwrap();\n        RustResult {\n            is_ok: false,\n            value: err_msg.into_raw() as *mut c_void,\n        }\n    } else {\n        RustResult {\n            is_ok: true,\n            value: Box::into_raw(Box::new(a / b)) as *mut c_void,\n        }\n    }\n}\nUsage on Julia Side\n# Macro extension to automatically handle Result type\nfunction build_rust_call_with_result(mod, expr, result_type)\n    # For functions returning Result type, provide option to automatically unwrap\n    # Or explicitly return Result type\nend\n\n","category":"section"},{"location":"design/Phase1/#Task-7:-Error-Handling","page":"Phase 1","title":"Task 7: Error Handling","text":"Priority: High Estimate: 3 days","category":"section"},{"location":"design/Phase1/#Implementation-Details-7","page":"Phase 1","title":"Implementation Details","text":"Error Type Definition\n# src/exceptions.jl\n\nstruct RustError <: Exception\n    message::String\n    code::Int32\nend\n\nBase.showerror(io::IO, e::RustError) = print(io, \"RustError: $(e.message) (code: $(e.code))\")\nResult Type to Exception Conversion\nfunction result_to_exception(result::RustResult{T, E}) where {T, E}\n    if !result.is_ok\n        error_msg = result.value\n        throw(RustError(string(error_msg), 0))\n    end\n    result.value::T\nend\n\n","category":"section"},{"location":"design/Phase1/#Task-8:-Test-Suite-Creation","page":"Phase 1","title":"Task 8: Test Suite Creation","text":"Priority: High Estimate: 1 week","category":"section"},{"location":"design/Phase1/#Implementation-Details-8","page":"Phase 1","title":"Implementation Details","text":"Basic Tests\n# test/basic.jl\nusing Rust\nusing Test\n\n@testset \"Basic Rust function calls\" begin\n    rust\"\"\"\n    #[no_mangle]\n    pub extern \"C\" fn add(a: i32, b: i32) -> i32 {\n        a + b\n    }\n    \"\"\"\n\n    @test @rust add(10, 20) == 30\nend\nType Tests\n# test/types.jl\n@testset \"Type mappings\" begin\n    # Test mapping for each type\nend\nString Literal Tests\n# test/strings.jl\n@testset \"String literals\" begin\n    # Test rust\"\" and irust\"\"\nend\n\n","category":"section"},{"location":"design/Phase1/#Implementation-Details-9","page":"Phase 1","title":"Implementation Details","text":"","category":"section"},{"location":"design/Phase1/#File-Structure","page":"Phase 1","title":"File Structure","text":"src/\n├── RustCall.jl              # Main module\n├── rustmacro.jl         # @rust macro\n├── ruststr.jl           # rust\"\" and irust\"\"\n├── rusttypes.jl         # Rust type definitions\n├── typetranslation.jl   # Type conversion\n├── exceptions.jl        # Error handling\n└── utils.jl             # Utilities","category":"section"},{"location":"design/Phase1/#Main-Function-Signatures","page":"Phase 1","title":"Main Function Signatures","text":"# rustmacro.jl\nrust_impl(mod, expr) -> Expr\nbuild_rust_call(mod, expr) -> Expr\nbuild_rust_namespace_ref(mod, expr) -> Expr\n\n# ruststr.jl\nprocess_rust_string(str, global_scope, source) -> Nothing\ncompile_rust_file(rs_file) -> String\nwrap_rust_code(code) -> String\n\n# typetranslation.jl\nrusttype_to_julia(rust_type) -> Type\njuliatype_to_rust(julia_type) -> String\nparse_rust_signature(sig) -> Tuple\n\n# utils.jl\nget_current_lib_name() -> String\nset_current_lib_name(name) -> Nothing\nregister_library(name, lib) -> Nothing\n\n","category":"section"},{"location":"design/Phase1/#Limitations","page":"Phase 1","title":"Limitations","text":"Phase 1 has the following limitations:\n\nType inference limitations: Type information may need to be explicitly specified for functions\nNo generics support: Rust generics cannot be used\nNo traits support: Rust traits cannot be used\nOwnership system: Detailed ownership management is not possible (only basic pointers/references)\nirust\"\" limitations: Execution in function scope is limited\n\n","category":"section"},{"location":"design/Phase1/#Next-Steps-(Transition-to-Phase-2)","page":"Phase 1","title":"Next Steps (Transition to Phase 2)","text":"After Phase 1 is complete, implement the following features in Phase 2:\n\nLLVM IR integration\nMore advanced type system\nGenerics support\nOwnership system integration\n\n","category":"section"},{"location":"design/Phase1/#Reference-Implementation","page":"Phase 1","title":"Reference Implementation","text":"Refer to Cxx.jl's cxxmacro.jl and cxxstr.jl\nRefer to Julia's ccall documentation\nRefer to Rust FFI guide","category":"section"},{"location":"performance/#Performance-Guide","page":"Performance Guide","title":"Performance Guide","text":"RustCall.jl provides multiple features to optimize performance when calling Rust code from Julia. This guide explains best practices and optimization tips for improving performance.","category":"section"},{"location":"performance/#Table-of-Contents","page":"Performance Guide","title":"Table of Contents","text":"Compilation Caching\nLLVM Optimization\nFunction Call Optimization\nMemory Management\nBenchmark Results\nPerformance Tuning Tips","category":"section"},{"location":"performance/#Compilation-Caching","page":"Performance Guide","title":"Compilation Caching","text":"RustCall.jl automatically caches compiled Rust libraries. This eliminates the need to recompile the same code and significantly reduces startup time.","category":"section"},{"location":"performance/#How-Caching-Works","page":"Performance Guide","title":"How Caching Works","text":"Cache Key: Generated from code hash, compiler settings, and target triple\nCache Location: ~/.julia/compiled/vX.Y/RustCall/\nAutomatic Verification: Automatically checks cache integrity","category":"section"},{"location":"performance/#Cache-Management","page":"Performance Guide","title":"Cache Management","text":"using RustCall\n\n# Check cache size\nsize = get_cache_size()\nprintln(\"Cache size: $(size / 1024 / 1024) MB\")\n\n# List cached libraries\nlibraries = list_cached_libraries()\nprintln(\"Cached libraries: $(length(libraries))\")\n\n# Cleanup old cache (older than 30 days)\ncleanup_old_cache(30)\n\n# Clear cache completely\nclear_cache()","category":"section"},{"location":"performance/#Cache-Best-Practices","page":"Performance Guide","title":"Cache Best Practices","text":"During Development: Keep cache enabled to reduce recompilation time\nProduction: Warm up cache beforehand to avoid first-run delays\nCI/CD: Save and restore cache to reduce build time","category":"section"},{"location":"performance/#LLVM-Optimization","page":"Performance Guide","title":"LLVM Optimization","text":"RustCall.jl supports optimization at the LLVM IR level. Using the @rust_llvm macro enables more advanced optimizations.","category":"section"},{"location":"performance/#Optimization-Level-Settings","page":"Performance Guide","title":"Optimization Level Settings","text":"using RustCall\n\n# Create optimization configuration\nconfig = OptimizationConfig(\n    level=3,  # 0-3 (3 is most optimized)\n    enable_vectorization=true,\n    enable_loop_unrolling=true,\n    enable_licm=true\n)\n\nrust_code = \"\"\"\n#[no_mangle]\npub extern \"C\" fn compute(x: f64) -> f64 {\n    x * x + 1.0\n}\n\"\"\"\n\n# Compile Rust to LLVM IR and load module\nwrapped = RustCall.wrap_rust_code(rust_code)\ncompiler = RustCall.get_default_compiler()\nir_path = RustCall.compile_rust_to_llvm_ir(wrapped; compiler=compiler)\nrust_mod = RustCall.load_llvm_ir(ir_path; source_code=wrapped)\nmod = rust_mod.mod\n\n# Apply optimization\noptimize_module!(mod; config=config)","category":"section"},{"location":"performance/#Optimization-Presets","page":"Performance Guide","title":"Optimization Presets","text":"# Speed-optimized\noptimize_for_speed!(mod)\n\n# Size-optimized\noptimize_for_size!(mod)","category":"section"},{"location":"performance/#Optimization-Level-Selection","page":"Performance Guide","title":"Optimization Level Selection","text":"Level 0: No optimization (for debugging)\nLevel 1: Basic optimizations\nLevel 2: Standard optimizations (default)\nLevel 3: Maximum optimization (may take longer to compile)","category":"section"},{"location":"performance/#Function-Call-Optimization","page":"Performance Guide","title":"Function Call Optimization","text":"","category":"section"},{"location":"performance/#@rust-vs-@rust_llvm","page":"Performance Guide","title":"@rust vs @rust_llvm","text":"@rust: Standard call via ccall. Highly stable, recommended for most cases\n@rust_llvm: Call via LLVM IR integration (experimental). Has optimization potential but limitations with some types\n\n# Standard call (recommended)\nresult = @rust add(Int32(10), Int32(20))::Int32\n\n# LLVM integration call (experimental)\nresult = @rust_llvm add(Int32(10), Int32(20))","category":"section"},{"location":"performance/#Type-Inference-Optimization","page":"Performance Guide","title":"Type Inference Optimization","text":"Explicit type specification can reduce type inference overhead:\n\n# With type inference (slightly slower)\nresult = @rust add(10, 20)\n\n# Explicit type specification (recommended)\nresult = @rust add(Int32(10), Int32(20))::Int32","category":"section"},{"location":"performance/#Function-Registration-Optimization","page":"Performance Guide","title":"Function Registration Optimization","text":"Frequently called functions can be optimized by registering them beforehand:\n\n# Register function for LLVM path\ncompile_and_register_rust_function(\"\"\"\n#[no_mangle]\npub extern \"C\" fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\"\"\", \"add\")\n\n# Call through LLVM path\nresult = @rust_llvm add(Int32(10), Int32(20))","category":"section"},{"location":"performance/#Memory-Management","page":"Performance Guide","title":"Memory Management","text":"","category":"section"},{"location":"performance/#Efficient-Use-of-Ownership-Types","page":"Performance Guide","title":"Efficient Use of Ownership Types","text":"Ownership types (RustBox, RustRc, RustArc, RustVec) prevent memory leaks when used appropriately:\n\n# Temporary allocations are automatically cleaned up\nbox = RustBox(Int32(42))\n# Automatically dropped after use\n\n# Explicit drop (when early release is needed)\ndrop!(box)","category":"section"},{"location":"performance/#Efficient-Use-of-RustVec","page":"Performance Guide","title":"Efficient Use of RustVec","text":"RustVec is a type for manipulating Rust's Vec<T> from Julia. Best practices when handling large amounts of data:\n\n# Create RustVec from Julia array\njulia_vec = Int32[1, 2, 3, 4, 5]\nrust_vec = create_rust_vec(julia_vec)\n\n# Efficient bulk copy (recommended)\nresult = Vector{Int32}(undef, length(rust_vec))\ncopy_to_julia!(rust_vec, result)\n\n# Or use to_julia_vector\nresult = to_julia_vector(rust_vec)\n\n# Element-by-element access (not recommended for large data)\nfor i in 1:length(rust_vec)\n    value = rust_vec[i]  # FFI call occurs\nend\n\n# Explicitly drop after use\ndrop!(rust_vec)","category":"section"},{"location":"performance/#RustVec-vs-Julia-Array-Selection","page":"Performance Guide","title":"RustVec vs Julia Array Selection","text":"Scenario Recommendation\nComputation within Julia Julia arrays\nInput to Rust functions RustVec\nOutput from Rust functions RustVec → Convert to Julia array\nTemporary storage of large data Julia arrays (managed by GC)\nData manipulation on Rust side RustVec","category":"section"},{"location":"performance/#Avoiding-Memory-Leaks","page":"Performance Guide","title":"Avoiding Memory Leaks","text":"# Pattern 1: Use try-finally\nbox = RustBox(Int32(42))\ntry\n    # Use\n    value = box.ptr\nfinally\n    drop!(box)  # Ensure cleanup\nend\n\n# Pattern 2: Leverage local scope\nfunction compute()\n    box = RustBox(Int32(42))\n    # Use\n    return result\n    # box is automatically dropped\nend","category":"section"},{"location":"performance/#Benchmark-Results","page":"Performance Guide","title":"Benchmark Results","text":"","category":"section"},{"location":"performance/#Basic-Operations","page":"Performance Guide","title":"Basic Operations","text":"The following benchmarks were run on Julia 1.12, Rust 1.92.0, macOS:\n\nOperation Julia Native @rust @rust_llvm\ni32 addition 1.0x 1.2x 1.1x\ni64 addition 1.0x 1.2x 1.1x\nf64 addition 1.0x 1.3x 1.2x\ni32 multiplication 1.0x 1.2x 1.1x\nf64 multiplication 1.0x 1.3x 1.2x","category":"section"},{"location":"performance/#Complex-Computations","page":"Performance Guide","title":"Complex Computations","text":"Computation Julia Native @rust @rust_llvm\nFibonacci (n=30) 1.0x 1.1x 1.0x\nSum Range (1..1000) 1.0x 1.2x 1.1x","category":"section"},{"location":"performance/#Ownership-Type-Operations","page":"Performance Guide","title":"Ownership Type Operations","text":"Operation Average Time Notes\nRustBox create+drop ~170 ns Single value allocation/release\nRustRc create+drop ~180 ns With reference counting\nRustRc clone+drop ~180 ns Clone operation\nRustArc create+drop ~190 ns Atomic reference counting\nRustArc clone+drop ~200 ns Thread-safe","category":"section"},{"location":"performance/#RustVec-Operations","page":"Performance Guide","title":"RustVec Operations","text":"Operation Average Time Notes\nRustVec(1000 elements) create ~1 μs Conversion from Julia array\nRustVec copytojulia!(1000 elements) ~500 ns Efficient bulk copy\nRustVec element access ~50 ns/element Includes FFI call\nRustVec push! ~100 ns When no reallocation occurs\n\nNote: These results may vary by environment. Actual performance can vary significantly depending on hardware, OS, and Julia/Rust versions.","category":"section"},{"location":"performance/#Running-Benchmarks","page":"Performance Guide","title":"Running Benchmarks","text":"# Basic benchmarks\njulia --project benchmark/benchmarks.jl\n\n# LLVM integration benchmarks\njulia --project benchmark/benchmarks_llvm.jl\n\n# Ownership type benchmarks\njulia --threads=4 --project benchmark/benchmarks_ownership.jl\n\n# Array operation benchmarks\njulia --project benchmark/benchmarks_arrays.jl\n\n# Generics benchmarks\njulia --project benchmark/benchmarks_generics.jl","category":"section"},{"location":"performance/#Performance-Tuning-Tips","page":"Performance Guide","title":"Performance Tuning Tips","text":"","category":"section"},{"location":"performance/#1.-Reducing-Compilation-Time","page":"Performance Guide","title":"1. Reducing Compilation Time","text":"Leverage cache: Don't recompile the same code\nAdjust optimization level: Level 1-2 during development, Level 3 in production\nDisable debug info: emit_debug_info=false\n\ncompiler = RustCompiler(\n    optimization_level=2,  # 2 is sufficient during development\n    emit_debug_info=false\n)\nset_default_compiler(compiler)","category":"section"},{"location":"performance/#2.-Improving-Runtime-Performance","page":"Performance Guide","title":"2. Improving Runtime Performance","text":"Explicit types: Reduce type inference overhead\nRegister functions: Pre-register frequently called functions\nBatch processing: Combine multiple calls\n\n# Inefficient: Type inference every time in loop\nfor i in 1:1000\n    result = @rust add(i, i+1)  # Type inference runs every time\nend\n\n# Efficient: Explicit types\nfor i in 1:1000\n    result = @rust add(Int32(i), Int32(i+1))::Int32\nend","category":"section"},{"location":"performance/#3.-Optimizing-Memory-Usage","page":"Performance Guide","title":"3. Optimizing Memory Usage","text":"Appropriate use of ownership types: Drop immediately when no longer needed\nAppropriate choice of Rc/Arc: Use Rc for single-threaded, Arc for multi-threaded\nCache cleanup: Regularly delete old cache","category":"section"},{"location":"performance/#4.-Parallel-Processing-Optimization","page":"Performance Guide","title":"4. Parallel Processing Optimization","text":"using Base.Threads\n\n# Use Arc to share data between threads\nshared_data = RustArc(Int32(0))\n\n# Work on multiple threads\n@threads for i in 1:1000\n    local_arc = clone(shared_data)\n    # Work\n    drop!(local_arc)\nend","category":"section"},{"location":"performance/#5.-Profiling","page":"Performance Guide","title":"5. Profiling","text":"Use Julia's profiling tools to identify bottlenecks:\n\nusing Profile\n\n# Start profiling\nProfile.clear()\n@profile for i in 1:1000\n    @rust add(Int32(i), Int32(i+1))\nend\n\n# Display results\nProfile.print()","category":"section"},{"location":"performance/#Troubleshooting","page":"Performance Guide","title":"Troubleshooting","text":"","category":"section"},{"location":"performance/#When-Performance-is-Lower-Than-Expected","page":"Performance Guide","title":"When Performance is Lower Than Expected","text":"Check cache: Verify cache is working correctly\nCheck optimization level: Verify optimization level is set appropriately\nExplicit types: Reduce type inference overhead\nProfiling: Identify bottlenecks","category":"section"},{"location":"performance/#When-Memory-Usage-is-High","page":"Performance Guide","title":"When Memory Usage is High","text":"Check ownership types: Verify they are being dropped appropriately\nCache cleanup: Delete old cache\nRc/Arc usage: Avoid unnecessary clones","category":"section"},{"location":"performance/#Summary","page":"Performance Guide","title":"Summary","text":"To optimize RustCall.jl performance:\n\n✅ Leverage cache: Reduce compilation time\n✅ Adjust optimization level: Select optimization level according to use case\n✅ Explicit types: Reduce type inference overhead\n✅ Memory management: Use ownership types appropriately\n✅ Profiling: Identify and optimize bottlenecks\n\nBy following these best practices, you can maximize the performance of applications using RustCall.jl.","category":"section"},{"location":"design/LLVMCALL/#About-Julia's-llvmcall","page":"LLVM Call","title":"About Julia's llvmcall","text":"","category":"section"},{"location":"design/LLVMCALL/#Overview","page":"LLVM Call","title":"Overview","text":"llvmcall is a low-level feature in Julia that allows direct embedding of LLVM IR (Intermediate Representation) into Julia code. This is equivalent to Julia's \"inline assembly\" but operates at the LLVM IR level, providing the advantage of being higher-level and more optimizable.","category":"section"},{"location":"design/LLVMCALL/#Basic-Syntax","page":"LLVM Call","title":"Basic Syntax","text":"llvmcall has two forms:","category":"section"},{"location":"design/LLVMCALL/#Form-1:-String-Form","page":"LLVM Call","title":"Form 1: String Form","text":"llvmcall(ir_string, return_type, arg_types_tuple, args...)\n\nParameters:\n\nir_string: LLVM IR code (string)\nreturn_type: Return type\narg_types_tuple: Tuple of argument types\nargs...: Actual arguments\n\nExample:\n\nfunction add_ints(x::Int32, y::Int32)\n    llvmcall(\"\"\"\n        %3 = add i32 %1, %0\n        ret i32 %3\n    \"\"\", Int32, (Int32, Int32), x, y)\nend\n\n# Usage example\nresult = add_ints(10, 20)  # => 30","category":"section"},{"location":"design/LLVMCALL/#Form-2:-Pointer-Form","page":"LLVM Call","title":"Form 2: Pointer Form","text":"llvmcall(function_pointer, return_type, arg_types_tuple, args...)\n\nParameters:\n\nfunction_pointer: Pointer to LLVM function (Ptr{Cvoid})\nreturn_type: Return type\narg_types_tuple: Tuple of argument types\nargs...: Actual arguments\n\nExample:\n\n# Get pointer to LLVM function (usually generated externally)\nf = get_llvm_function_pointer()\n\nfunction call_llvm_function(x, y)\n    llvmcall(f, Int32, (Int32, Int32), x, y)\nend","category":"section"},{"location":"design/LLVMCALL/#Differences-Between-the-Two-Forms","page":"LLVM Call","title":"Differences Between the Two Forms","text":"","category":"section"},{"location":"design/LLVMCALL/#String-Form-Behavior","page":"LLVM Call","title":"String Form Behavior","text":"Wrapping: Julia wraps the provided LLVM IR in an LLVM function with the specified return type and argument types\nArgument conversion: Julia performs argument conversion (unboxing, etc.) similar to ccall\nInlining: The generated call instruction is inlined","category":"section"},{"location":"design/LLVMCALL/#Pointer-Form-Behavior","page":"LLVM Call","title":"Pointer Form Behavior","text":"No wrapping: Julia skips wrapping and proceeds directly to argument conversion and inlining\nMore efficient: This form is more efficient when a complete LLVM function already exists\nUsed in Cxx.jl: Cxx.jl uses this form to directly embed LLVM IR generated by Clang","category":"section"},{"location":"design/LLVMCALL/#LLVM-IR-Syntax","page":"LLVM Call","title":"LLVM IR Syntax","text":"","category":"section"},{"location":"design/LLVMCALL/#Basic-Instructions","page":"LLVM Call","title":"Basic Instructions","text":"; Addition\n%result = add i32 %a, %b\n\n; Subtraction\n%result = sub i32 %a, %b\n\n; Multiplication\n%result = mul i32 %a, %b\n\n; Division\n%result = sdiv i32 %a, %b  ; Signed division\n%result = udiv i32 %a, %b  ; Unsigned division\n\n; Return\nret i32 %result\nret void  ; No return value","category":"section"},{"location":"design/LLVMCALL/#Types","page":"LLVM Call","title":"Types","text":"i8    ; 8-bit integer\ni16   ; 16-bit integer\ni32   ; 32-bit integer\ni64   ; 64-bit integer\nfloat ; 32-bit floating point\ndouble; 64-bit floating point\nvoid  ; No return value","category":"section"},{"location":"design/LLVMCALL/#Argument-References","page":"LLVM Call","title":"Argument References","text":"In the string form, arguments are referenced as %0, %1, %2, ...:\n\n%0: First argument\n%1: Second argument\nAnd so on\n\nNote: The argument order may be reversed in LLVM IR (e.g., %1 is the first argument, %0 is the second argument). This is due to LLVM's calling convention.","category":"section"},{"location":"design/LLVMCALL/#Usage-Examples","page":"LLVM Call","title":"Usage Examples","text":"","category":"section"},{"location":"design/LLVMCALL/#Example-1:-Basic-Arithmetic-Operations","page":"LLVM Call","title":"Example 1: Basic Arithmetic Operations","text":"function multiply(x::Int32, y::Int32)\n    llvmcall(\"\"\"\n        %result = mul i32 %1, %0\n        ret i32 %result\n    \"\"\", Int32, (Int32, Int32), x, y)\nend\n\nmultiply(5, 7)  # => 35","category":"section"},{"location":"design/LLVMCALL/#Example-2:-Floating-Point-Operations","page":"LLVM Call","title":"Example 2: Floating Point Operations","text":"function add_floats(x::Float64, y::Float64)\n    llvmcall(\"\"\"\n        %result = fadd double %1, %0\n        ret double %result\n    \"\"\", Float64, (Float64, Float64), x, y)\nend\n\nadd_floats(3.14, 2.71)  # => 5.85","category":"section"},{"location":"design/LLVMCALL/#Example-3:-Conditional-Branching","page":"LLVM Call","title":"Example 3: Conditional Branching","text":"function max_int(x::Int32, y::Int32)\n    llvmcall(\"\"\"\n        %cmp = icmp sgt i32 %1, %0\n        %result = select i1 %cmp, i32 %1, i32 %0\n        ret i32 %result\n    \"\"\", Int32, (Int32, Int32), x, y)\nend\n\nmax_int(10, 20)  # => 20","category":"section"},{"location":"design/LLVMCALL/#Example-4:-Pointer-Operations","page":"LLVM Call","title":"Example 4: Pointer Operations","text":"function load_and_add(ptr::Ptr{Int32}, value::Int32)\n    llvmcall(\"\"\"\n        %loaded = load i32, i32* %1\n        %result = add i32 %loaded, %0\n        ret i32 %result\n    \"\"\", Int32, (Ptr{Int32}, Int32), ptr, value)\nend","category":"section"},{"location":"design/LLVMCALL/#Example-5:-Using-Pointer-Form-(Cxx.jl-Style)","page":"LLVM Call","title":"Example 5: Using Pointer Form (Cxx.jl Style)","text":"# Generate LLVM function in staged function\n@generated function call_cpp_function(args...)\n    # Generate LLVM function (actual implementation omitted)\n    f = generate_llvm_function(args)\n\n    # Generate llvmcall in pointer form\n    Expr(:call, Core.Intrinsics.llvmcall,\n        convert(Ptr{Cvoid}, f),\n        get_return_type(args),\n        Tuple{map(get_type, args)...},\n        [:(args[$i]) for i in 1:length(args)]...)\nend","category":"section"},{"location":"design/LLVMCALL/#Optimization-Benefits","page":"LLVM Call","title":"Optimization Benefits","text":"An important advantage of llvmcall is that optimizations are executed after LLVM IR is inlined into Julia's IR. This enables:\n\nConstant propagation: Constants propagate across both Julia and LLVM IR\nDead code elimination: Unused code is removed\nInlining: Function calls are inlined\nLoop optimization: Loop optimizations are applied\n\nThis means that unlike machine code inline assembly, the compiler can see the entire code and optimize it.","category":"section"},{"location":"design/LLVMCALL/#Notes","page":"LLVM Call","title":"Notes","text":"","category":"section"},{"location":"design/LLVMCALL/#1.-Argument-Order","page":"LLVM Call","title":"1. Argument Order","text":"The reference order of arguments in LLVM IR may differ from Julia's argument order. Typically, %0 is the last argument, %1 is the previous argument, and so on in reverse order.\n\nRecommendation: Test and verify, or use debug output to confirm the order.","category":"section"},{"location":"design/LLVMCALL/#2.-Type-Matching","page":"LLVM Call","title":"2. Type Matching","text":"Types in LLVM IR must exactly match Julia types:\n\n# Correct\nllvmcall(\"...\", Int32, (Int32, Int32), x, y)\n\n# Wrong (types don't match)\nllvmcall(\"...\", Int64, (Int32, Int32), x, y)  # Return type differs","category":"section"},{"location":"design/LLVMCALL/#3.-Memory-Safety","page":"LLVM Call","title":"3. Memory Safety","text":"llvmcall is a low-level operation and does not guarantee memory safety. Be very careful when performing pointer operations.","category":"section"},{"location":"design/LLVMCALL/#4.-Platform-Dependencies","page":"LLVM Call","title":"4. Platform Dependencies","text":"Some LLVM IR instructions may be platform-dependent. Write platform-independent code whenever possible.","category":"section"},{"location":"design/LLVMCALL/#Usage-in-Cxx.jl","page":"LLVM Call","title":"Usage in Cxx.jl","text":"Cxx.jl uses the pointer form of llvmcall to embed LLVM IR generated by Clang into Julia:\n\n# Cxx.jl internal implementation (simplified)\nfunction createReturn(C, builder, f, argt, llvmargt, llvmrt, rett, rt, ret, state)\n    # ... LLVM IR generation ...\n\n    # Generate llvmcall expression\n    Expr(:call, Core.Intrinsics.llvmcall,\n        convert(Ptr{Cvoid}, f),  # Pointer to LLVM function generated by Clang\n        rett,                     # Return type\n        Tuple{argt...},          # Argument type tuple\n        args2...)                # Actual arguments\nend\n\nThis approach allows C++ code to be compiled with Clang and the generated LLVM IR to be directly embedded into Julia.","category":"section"},{"location":"design/LLVMCALL/#Planned-Usage-in-RustCall.jl","page":"LLVM Call","title":"Planned Usage in RustCall.jl","text":"RustCall.jl (Phase 2) will use a similar approach:\n\n# RustCall.jl internal implementation (planned)\n@generated function rustcall(CT::RustInstance, expr, args...)\n    # 1. Compile Rust code to LLVM IR\n    llvm_mod = compile_rust_to_llvm(rust_code)\n\n    # 2. Get function\n    fn = functions(llvm_mod)[func_name]\n\n    # 3. Embed into llvmcall\n    Expr(:call, Core.Intrinsics.llvmcall,\n        convert(Ptr{Cvoid}, fn),\n        ret_type,\n        Tuple{arg_types...},\n        args...)\nend","category":"section"},{"location":"design/LLVMCALL/#Debugging","page":"LLVM Call","title":"Debugging","text":"","category":"section"},{"location":"design/LLVMCALL/#Checking-LLVM-IR","page":"LLVM Call","title":"Checking LLVM IR","text":"To check generated LLVM IR, run Julia's code generation in debug mode:\n\n# Check Julia code generation\n@code_llvm function_name(args...)\n\n# More detailed information\n@code_llvm debug=true function_name(args...)","category":"section"},{"location":"design/LLVMCALL/#Handling-Errors","page":"LLVM Call","title":"Handling Errors","text":"When errors occur with llvmcall:\n\nType mismatch: Check if types in LLVM IR match Julia types\nArgument order: Check if argument reference order is correct\nSyntax errors: Check if LLVM IR syntax is correct","category":"section"},{"location":"design/LLVMCALL/#Performance","page":"LLVM Call","title":"Performance","text":"Using llvmcall provides the following performance benefits:\n\nReduced function call overhead: Inlining reduces function call overhead\nOptimization application: LLVM optimization passes are applied\nType specialization: Combined with staged functions, type-specialized code can be generated","category":"section"},{"location":"design/LLVMCALL/#References","page":"LLVM Call","title":"References","text":"Julia Manual: LLVM Call\nLLVM Language Reference Manual\nCxx.jl Implementation","category":"section"},{"location":"design/LLVMCALL/#Summary","page":"LLVM Call","title":"Summary","text":"llvmcall is a powerful tool for low-level optimization in Julia. In particular:\n\nString form: Convenient for directly embedding simple LLVM IR code\nPointer form: Efficient when using already-generated LLVM functions (used in Cxx.jl, RustCall.jl)\n\nPackages like Cxx.jl and RustCall.jl achieve high-performance interop by compiling external language code (C++, Rust) to LLVM IR and integrating it into Julia using the pointer form of llvmcall.","category":"section"},{"location":"struct_mapping/#Struct-Mapping-with-#[derive(JuliaStruct)]","page":"Struct Mapping","title":"Struct Mapping with #[derive(JuliaStruct)]","text":"RustCall.jl provides automatic struct mapping through the #[derive(JuliaStruct)] attribute, which allows you to seamlessly use Rust structs as first-class Julia objects.","category":"section"},{"location":"struct_mapping/#Overview","page":"Struct Mapping","title":"Overview","text":"When you add #[derive(JuliaStruct)] to a Rust struct, RustCall.jl automatically:\n\nGenerates Julia bindings for the struct\nCreates field accessors (getters and setters)\nGenerates trait implementations (Clone, Debug, etc.) when requested\nManages memory lifecycle with automatic finalizers","category":"section"},{"location":"struct_mapping/#Basic-Usage","page":"Struct Mapping","title":"Basic Usage","text":"","category":"section"},{"location":"struct_mapping/#Simple-Struct","page":"Struct Mapping","title":"Simple Struct","text":"rust\"\"\"\n#[derive(JuliaStruct)]\npub struct Point2D {\n    x: f64,\n    y: f64,\n}\n\nimpl Point2D {\n    pub fn new(x: f64, y: f64) -> Self {\n        Point2D { x, y }\n    }\n\n    pub fn distance(&self) -> f64 {\n        (self.x * self.x + self.y * self.y).sqrt()\n    }\n}\n\"\"\"\n\n# Create a Point2D instance\np = Point2D(3.0, 4.0)\n\n# Access fields directly\nprintln(p.x)  # => 3.0\nprintln(p.y)  # => 4.0\n\n# Modify fields\np.y = 5.0\nprintln(p.y)  # => 5.0\n\n# Call methods\ndist = p.distance()\nprintln(dist)  # => 5.830951894845301","category":"section"},{"location":"struct_mapping/#With-Clone-Support","page":"Struct Mapping","title":"With Clone Support","text":"rust\"\"\"\n#[derive(JuliaStruct, Clone)]\npub struct PersonInfo {\n    name: String,\n    age: i32,\n}\n\nimpl PersonInfo {\n    pub fn new(name: String, age: i32) -> Self {\n        PersonInfo { name, age }\n    }\n\n    pub fn get_name(&self) -> String {\n        self.name.clone()\n    }\n}\n\"\"\"\n\n# Create a person\nperson = PersonInfo(\"Alice\", 30)\n\n# Clone the person\nperson2 = copy(person)  # Uses Rust's Clone trait\n\n# Both are independent objects\nperson.age = 31\nprintln(person.age)   # => 31\nprintln(person2.age)  # => 30","category":"section"},{"location":"struct_mapping/#Derive-Options","page":"Struct Mapping","title":"Derive Options","text":"The #[derive(JuliaStruct)] attribute supports additional derive options:","category":"section"},{"location":"struct_mapping/#Supported-Traits","page":"Struct Mapping","title":"Supported Traits","text":"Clone: Enables copy() function in Julia\nDebug: (Reserved for future use)\nPartialEq: (Reserved for future use)\nEq: (Reserved for future use)\nPartialOrd: (Reserved for future use)\nOrd: (Reserved for future use)\nHash: (Reserved for future use)\nDefault: (Reserved for future use)","category":"section"},{"location":"struct_mapping/#Example-with-Multiple-Traits","page":"Struct Mapping","title":"Example with Multiple Traits","text":"rust\"\"\"\n#[derive(JuliaStruct, Clone)]\npub struct Config {\n    host: String,\n    port: i32,\n    timeout: f64,\n}\n\nimpl Config {\n    pub fn new(host: String, port: i32, timeout: f64) -> Self {\n        Config { host, port, timeout }\n    }\n}\n\"\"\"\n\nconfig = Config(\"localhost\", 8080, 30.0)\nconfig2 = copy(config)  # Clone support","category":"section"},{"location":"struct_mapping/#Field-Access","page":"Struct Mapping","title":"Field Access","text":"","category":"section"},{"location":"struct_mapping/#Automatic-Getters-and-Setters","page":"Struct Mapping","title":"Automatic Getters and Setters","text":"When #[derive(JuliaStruct)] is present, RustCall.jl automatically generates:\n\nGetters: Access fields using obj.field_name\nSetters: Modify fields using obj.field_name = value\n\nrust\"\"\"\n#[derive(JuliaStruct)]\npub struct Rectangle {\n    width: f64,\n    height: f64,\n}\n\nimpl Rectangle {\n    pub fn new(width: f64, height: f64) -> Self {\n        Rectangle { width, height }\n    }\n\n    pub fn area(&self) -> f64 {\n        self.width * self.height\n    }\n}\n\"\"\"\n\nrect = Rectangle(10.0, 20.0)\n\n# Get field values\nw = rect.width   # => 10.0\nh = rect.height  # => 20.0\n\n# Set field values\nrect.width = 15.0\nrect.height = 25.0\n\n# Calculate area\nrect_area = rect.area()  # => 375.0","category":"section"},{"location":"struct_mapping/#Field-Type-Mapping","page":"Struct Mapping","title":"Field Type Mapping","text":"Field types are automatically mapped from Rust to Julia:\n\nRust Type Julia Type Notes\ni32 Int32 \ni64 Int64 \nf32 Float32 \nf64 Float64 \nbool Bool \nString RustString Owned string\n&str RustStr String slice","category":"section"},{"location":"struct_mapping/#Generic-Structs","page":"Struct Mapping","title":"Generic Structs","text":"Generic structs are also supported:\n\nrust\"\"\"\n#[derive(JuliaStruct)]\npub struct Pair<T> {\n    first: T,\n    second: T,\n}\n\nimpl<T> Pair<T> {\n    pub fn new(first: T, second: T) -> Self {\n        Pair { first, second }\n    }\n}\n\"\"\"\n\n# Create a Pair with Int32\npair_int = Pair{Int32}(10, 20)\nprintln(pair_int.first)   # => 10\nprintln(pair_int.second)  # => 20\n\n# Create a Pair with Float64\npair_float = Pair{Float64}(3.14, 2.71)\nprintln(pair_float.first)   # => 3.14\nprintln(pair_float.second)  # => 2.71\n\nnote: Future Feature\nGeneric struct support is planned for a future release.","category":"section"},{"location":"struct_mapping/#Memory-Management","page":"Struct Mapping","title":"Memory Management","text":"Structs created with #[derive(JuliaStruct)] are automatically managed by Julia's garbage collector. When a Julia object is reclaimed, its corresponding Rust memory is automatically freed.","category":"section"},{"location":"struct_mapping/#Method-Binding","page":"Struct Mapping","title":"Method Binding","text":"All pub fn methods in impl blocks are automatically bound:\n\nrust\"\"\"\n#[derive(JuliaStruct)]\npub struct Calculator {\n    value: f64,\n}\n\nimpl Calculator {\n    pub fn new(value: f64) -> Self {\n        Calculator { value }\n    }\n\n    pub fn add(&mut self, x: f64) {\n        self.value += x;\n    }\n\n    pub fn multiply(&mut self, x: f64) {\n        self.value *= x;\n    }\n\n    pub fn get_value(&self) -> f64 {\n        self.value\n    }\n\n    pub fn reset(&mut self) {\n        self.value = 0.0;\n    }\n}\n\"\"\"\n\ncalc = Calculator(10.0)\ncalc.add(5.0)\ncalc.multiply(2.0)\nprintln(calc.get_value())  # => 30.0\ncalc.reset()\nprintln(calc.get_value())  # => 0.0","category":"section"},{"location":"struct_mapping/#Static-Methods","page":"Struct Mapping","title":"Static Methods","text":"Static methods (methods without self) are also supported:\n\nrust\"\"\"\n#[derive(JuliaStruct)]\npub struct MathUtils;\n\nimpl MathUtils {\n    pub fn add(a: f64, b: f64) -> f64 {\n        a + b\n    }\n\n    pub fn multiply(a: f64, b: f64) -> f64 {\n        a * b\n    }\n}\n\"\"\"\n\n# Create an instance and call methods\nutils = MathUtils()\nresult1 = utils.add(3.0, 4.0)      # => 7.0\nresult2 = utils.multiply(3.0, 4.0) # => 12.0\n\nnote: Future Feature\nUnit struct (struct without fields) support is planned for a future release.","category":"section"},{"location":"struct_mapping/#Best-Practices","page":"Struct Mapping","title":"Best Practices","text":"","category":"section"},{"location":"struct_mapping/#1.-Always-Use-#[derive(JuliaStruct)]","page":"Struct Mapping","title":"1. Always Use #[derive(JuliaStruct)]","text":"For structs that you want to use in Julia, always add the attribute:\n\n#[derive(JuliaStruct)]  // ✅ Good\npub struct MyStruct {\n    // ...\n}","category":"section"},{"location":"struct_mapping/#2.-Use-Clone-for-Expensive-Operations","page":"Struct Mapping","title":"2. Use Clone for Expensive Operations","text":"If you need to copy structs frequently, derive Clone:\n\n#[derive(JuliaStruct, Clone)]  // ✅ Good for copyable structs\npub struct Config {\n    // ...\n}","category":"section"},{"location":"struct_mapping/#3.-Keep-Structs-Simple","page":"Struct Mapping","title":"3. Keep Structs Simple","text":"Prefer simple field types that map well to Julia:\n\n#[derive(JuliaStruct)]\npub struct Point {\n    x: f64,  // ✅ Good: simple type\n    y: f64,\n}","category":"section"},{"location":"struct_mapping/#4.-Use-Methods-for-Complex-Operations","page":"Struct Mapping","title":"4. Use Methods for Complex Operations","text":"For complex operations, use methods instead of exposing internal state:\n\n#[derive(JuliaStruct)]\npub struct BankAccount {\n    balance: f64,\n}\n\nimpl BankAccount {\n    pub fn new(balance: f64) -> Self {\n        BankAccount { balance }\n    }\n\n    pub fn withdraw(&mut self, amount: f64) -> Result<f64, String> {\n        if amount > self.balance {\n            Err(\"Insufficient funds\".to_string())\n        } else {\n            self.balance -= amount;\n            Ok(self.balance)\n        }\n    }\n\n    pub fn get_balance(&self) -> f64 {\n        self.balance\n    }\n}","category":"section"},{"location":"struct_mapping/#Limitations","page":"Struct Mapping","title":"Limitations","text":"","category":"section"},{"location":"struct_mapping/#Current-Limitations","page":"Struct Mapping","title":"Current Limitations","text":"Nested structs: Nested structs are not yet fully supported\nComplex generics: Very complex generic constraints may not work\nLifetime parameters: Lifetime parameters are not supported\nAssociated types: Associated types in traits are not supported","category":"section"},{"location":"struct_mapping/#Workarounds","page":"Struct Mapping","title":"Workarounds","text":"For nested structs, use pointers or references:\n\n#[derive(JuliaStruct)]\npub struct Outer {\n    inner: *mut Inner,  // Use pointer instead of direct nesting\n}\n\n#[derive(JuliaStruct)]\npub struct Inner {\n    value: i32,\n}","category":"section"},{"location":"struct_mapping/#Examples","page":"Struct Mapping","title":"Examples","text":"","category":"section"},{"location":"struct_mapping/#Complete-Example:-2D-Vector","page":"Struct Mapping","title":"Complete Example: 2D Vector","text":"rust\"\"\"\n#[derive(JuliaStruct, Clone)]\npub struct Vec2DD {\n    x: f64,\n    y: f64,\n}\n\nimpl Vec2DD {\n    pub fn new(x: f64, y: f64) -> Self {\n        Vec2DD { x, y }\n    }\n\n    pub fn zero() -> Self {\n        Vec2DD { x: 0.0, y: 0.0 }\n    }\n\n    pub fn add(&self, other: &Vec2DD) -> Vec2DD {\n        Vec2DD {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n\n    pub fn scale(&mut self, factor: f64) {\n        self.x *= factor;\n        self.y *= factor;\n    }\n\n    pub fn magnitude(&self) -> f64 {\n        (self.x * self.x + self.y * self.y).sqrt()\n    }\n\n    pub fn normalize(&mut self) {\n        let mag = self.magnitude();\n        if mag > 0.0 {\n            self.scale(1.0 / mag);\n        }\n    }\n}\n\"\"\"\n\n# Create vectors\nv1 = Vec2DD(3.0, 4.0)\nv2 = Vec2DD(1.0, 2.0)\n\n# Access fields\nprintln(\"v1: ($(v1.x), $(v1.y))\")  # => v1: (3.0, 4.0)\n\n# Modify fields\nv1.x = 5.0\nprintln(\"v1: ($(v1.x), $(v1.y))\")  # => v1: (5.0, 4.0)\n\n# Call methods\nv3 = v1.add(v2)\nprintln(\"v3: ($(v3.x), $(v3.y))\")  # => v3: (6.0, 6.0)\n\n# Static method\nv_zero = Vec2DD.zero()\nprintln(\"zero: ($(v_zero.x), $(v_zero.y))\")  # => zero: (0.0, 0.0)\n\n# Clone\nv4 = copy(v1)\nv4.scale(2.0)\nprintln(\"v1 magnitude: $(v1.magnitude())\")  # => v1 magnitude: 6.4031242374328485\nprintln(\"v4 magnitude: $(v4.magnitude())\")  # => v4 magnitude: 12.806248474865697\n\nnote: Future Feature\nMethods returning custom struct types are planned for a future release.","category":"section"},{"location":"struct_mapping/#Troubleshooting","page":"Struct Mapping","title":"Troubleshooting","text":"","category":"section"},{"location":"struct_mapping/#Struct-Not-Found","page":"Struct Mapping","title":"Struct Not Found","text":"If you get an error that the struct is not found, make sure:\n\nThe struct is marked with pub\nThe struct has #[derive(JuliaStruct)]\nThe struct is defined in the rust\"\" block\n\n// ❌ Bad: missing pub\nstruct MyStruct { ... }\n\n// ✅ Good\n#[derive(JuliaStruct)]\npub struct MyStruct { ... }","category":"section"},{"location":"struct_mapping/#Field-Access-Errors","page":"Struct Mapping","title":"Field Access Errors","text":"If field access doesn't work:\n\nMake sure the struct has #[derive(JuliaStruct)]\nCheck that field names match exactly\nVerify field types are supported","category":"section"},{"location":"struct_mapping/#Clone-Not-Working","page":"Struct Mapping","title":"Clone Not Working","text":"If copy() doesn't work:\n\nAdd Clone to the derive list: #[derive(JuliaStruct, Clone)]\nMake sure all fields implement Clone in Rust","category":"section"},{"location":"struct_mapping/#See-Also","page":"Struct Mapping","title":"See Also","text":"Tutorial: General tutorial on using RustCall.jl\nExamples: More examples of RustCall.jl usage\nAPI Reference: Complete API documentation\nGenerics: Using generics with RustCall.jl","category":"section"},{"location":"design/Phase2/#Phase-2:-LLVM-IR-Integration","page":"Phase 2","title":"Phase 2: LLVM IR Integration","text":"","category":"section"},{"location":"design/Phase2/#Overview","page":"Phase 2","title":"Overview","text":"In Phase 2, we achieve more flexible and high-performance Rust-Julia integration by directly manipulating LLVM IR. This phase retrieves LLVM IR generated by rustc and embeds it into Julia's llvmcall, bypassing C-compatible ABI limitations and enabling more advanced type systems and optimizations.\n\nTarget Duration: 4-6 months Deliverable: LLVM IR integration, extended type system, ownership type support, optimization\n\n","category":"section"},{"location":"design/Phase2/#Implementation-Task-List","page":"Phase 2","title":"Implementation Task List","text":"","category":"section"},{"location":"design/Phase2/#Task-1:-LLVM.jl-Integration-and-Setup","page":"Phase 2","title":"Task 1: LLVM.jl Integration and Setup","text":"Priority: Highest Estimate: 1 week","category":"section"},{"location":"design/Phase2/#Implementation-Details","page":"Phase 2","title":"Implementation Details","text":"Add Dependencies\n# Project.toml\n[deps]\nLLVM = \"929cbde3-209d-540e-8aea-1fcc83b56489\"\nLLVM_jll = \"dad2f222-ce93-54a1-a47d-0025e8a3acab\"\nInitialize LLVM Module\n# src/llvmintegration.jl\nusing LLVM\nusing LLVM.Interop\n\n# Manage LLVM contexts\nconst llvm_contexts = Dict{String, LLVM.Context}()\n\nfunction get_llvm_context(name::String = \"default\")\n    if !haskey(llvm_contexts, name)\n        llvm_contexts[name] = Context()\n    end\n    llvm_contexts[name]\nend\nLLVM IR Loading Functionality\nfunction parse_llvm_ir(ir_file::String)\n    ctx = get_llvm_context()\n    mod = parse(LLVM.Module, read(ir_file, String), ctx)\n    mod\nend\n\nfunction parse_llvm_ir_string(ir_string::String)\n    ctx = get_llvm_context()\n    mod = parse(LLVM.Module, ir_string, ctx)\n    mod\nend\n\n","category":"section"},{"location":"design/Phase2/#Task-2:-Rust-Compiler-Integration","page":"Phase 2","title":"Task 2: Rust Compiler Integration","text":"Priority: Highest Estimate: 2 weeks","category":"section"},{"location":"design/Phase2/#Implementation-Details-2","page":"Phase 2","title":"Implementation Details","text":"Rust Compiler Configuration\n# src/rustcompiler.jl\n\nstruct RustCompiler\n    target_triple::String\n    optimization_level::Int  # 0-3\n    emit_debug_info::Bool\n    crate_type::String  # \"cdylib\", \"rlib\", etc.\nend\n\nfunction RustCompiler(;\n    target_triple::String = get_default_target(),\n    optimization_level::Int = 2,\n    emit_debug_info::Bool = false,\n    crate_type::String = \"cdylib\"\n)\n    RustCompiler(target_triple, optimization_level, emit_debug_info, crate_type)\nend\n\nfunction get_default_target()\n    # Get target for current platform\n    @static Sys.iswindows() ? \"x86_64-pc-windows-msvc\" :\n    @static Sys.isapple() ? \"x86_64-apple-darwin\" :\n    \"x86_64-unknown-linux-gnu\"\nend\nCompile Rust Code to LLVM IR\nfunction compile_rust_to_llvm(\n    compiler::RustCompiler,\n    code::String;\n    output_file::Union{String, Nothing} = nothing\n)\n    # 1. Write to temporary file\n    tmp_file = tempname() * \".rs\"\n    write(tmp_file, wrap_rust_code_for_llvm(code))\n\n    # 2. Determine LLVM IR file path\n    if output_file === nothing\n        ir_file = tempname() * \".ll\"\n    else\n        ir_file = output_file\n    end\n\n    # 3. Generate LLVM IR with rustc\n    cmd = `rustc --emit llvm-ir\n           --target $(compiler.target_triple)\n           -C opt-level=$(compiler.optimization_level)\n           $(compiler.emit_debug_info ? \"-g\" : \"\")\n           -o $ir_file $tmp_file`\n\n    try\n        run(cmd)\n    catch e\n        error(\"Failed to compile Rust code: $e\")\n    end\n\n    # 4. Load LLVM IR\n    if !isfile(ir_file)\n        error(\"LLVM IR file not generated: $ir_file\")\n    end\n\n    mod = parse_llvm_ir(ir_file)\n\n    # 5. Cleanup temporary files (optional)\n    # rm(tmp_file, force=true)\n\n    mod\nend\n\nfunction wrap_rust_code_for_llvm(code::String)\n    # Wrap Rust code appropriately\n    # Add extern \"C\" block or other settings as needed\n    code\nend\nIncremental Compilation Support\n# Cache compilation results\nconst compilation_cache = Dict{String, LLVM.Module}()\n\nfunction compile_rust_to_llvm_cached(\n    compiler::RustCompiler,\n    code::String\n)\n    code_hash = hash(code)\n    cache_key = \"$(code_hash)_$(compiler.optimization_level)\"\n\n    if haskey(compilation_cache, cache_key)\n        return compilation_cache[cache_key]\n    end\n\n    mod = compile_rust_to_llvm(compiler, code)\n    compilation_cache[cache_key] = mod\n    mod\nend\n\n","category":"section"},{"location":"design/Phase2/#Task-3:-LLVM-IR-Optimization","page":"Phase 2","title":"Task 3: LLVM IR Optimization","text":"Priority: High Estimate: 1 week","category":"section"},{"location":"design/Phase2/#Implementation-Details-3","page":"Phase 2","title":"Implementation Details","text":"Optimization Pass Configuration\n# src/llvmoptimization.jl\n\nfunction create_optimization_pipeline(level::Int = 2)\n    pm = ModulePassManager()\n\n    if level >= 1\n        # Basic optimizations\n        add_pass!(pm, Pass(\"mem2reg\"))\n        add_pass!(pm, Pass(\"instcombine\"))\n        add_pass!(pm, Pass(\"simplifycfg\"))\n    end\n\n    if level >= 2\n        # More aggressive optimizations\n        add_pass!(pm, Pass(\"gvn\"))\n        add_pass!(pm, Pass(\"licm\"))\n        add_pass!(pm, Pass(\"loop-vectorize\"))\n    end\n\n    if level >= 3\n        # Maximum optimization\n        add_pass!(pm, Pass(\"slp-vectorize\"))\n        add_pass!(pm, Pass(\"aggressive-instcombine\"))\n    end\n\n    pm\nend\n\nfunction optimize_llvm_module(mod::LLVM.Module, level::Int = 2)\n    pm = create_optimization_pipeline(level)\n    run!(pm, mod)\n    mod\nend\nFunction-Level Optimization\nfunction optimize_function(fn::LLVM.Function, level::Int = 2)\n    fpm = FunctionPassManager(fn)\n\n    if level >= 1\n        add_pass!(fpm, Pass(\"mem2reg\"))\n        add_pass!(fpm, Pass(\"instcombine\"))\n    end\n\n    if level >= 2\n        add_pass!(fpm, Pass(\"gvn\"))\n    end\n\n    initialize!(fpm)\n    run!(fpm, fn)\n    finalize!(fpm)\nend\n\n","category":"section"},{"location":"design/Phase2/#Task-4:-LLVM-IR-Embedding-in-Staged-Functions","page":"Phase 2","title":"Task 4: LLVM IR Embedding in Staged Functions","text":"Priority: Highest Estimate: 2 weeks","category":"section"},{"location":"design/Phase2/#Implementation-Details-4","page":"Phase 2","title":"Implementation Details","text":"RustInstance Definition\n# src/rustinstances.jl\n\nstruct RustCompilerInstance\n    compiler::RustCompiler\n    llvm_modules::Vector{LLVM.Module}\nend\n\nstruct RustInstance{n}\nend\n\nconst active_rust_instances = RustCompilerInstance[]\n\nfunction instance(::RustInstance{n}) where {n}\n    active_rust_instances[n]\nend\n\nconst __current_rust_compiler__ = RustInstance{1}()\nStaged Function Implementation\n# src/rustcodegen.jl\n\n@generated function rustcall(\n    CT::RustInstance,\n    expr::Type{RustNNS{Tnns}},\n    args...\n) where {Tnns}\n    C = instance(CT)\n\n    # 1. Get function name\n    func_name = get_function_name_from_nns(Tnns)\n\n    # 2. Get Rust code (from type information or cache)\n    rust_code = get_rust_code_for_function(func_name)\n\n    # 3. Generate LLVM IR\n    llvm_mod = compile_rust_to_llvm_cached(C.compiler, rust_code)\n\n    # 4. Optimize\n    optimize_llvm_module(llvm_mod, C.compiler.optimization_level)\n\n    # 5. Get function\n    fn = functions(llvm_mod)[func_name]\n\n    if fn === nothing\n        error(\"Function $func_name not found in LLVM module\")\n    end\n\n    # 6. Get type information\n    ret_type = get_return_type_from_llvm(fn)\n    arg_types = get_argument_types_from_llvm(fn)\n\n    # 7. Generate llvmcall expression\n    Expr(:call, Core.Intrinsics.llvmcall,\n        convert(Ptr{Cvoid}, fn),\n        ret_type,\n        Tuple{arg_types...},\n        [:(args[$i]) for i in 1:length(arg_types)]...)\nend\nType Information Extraction\nfunction get_return_type_from_llvm(fn::LLVM.Function)\n    ret_ty = return_type(fn)\n    llvm_to_julia_type(ret_ty)\nend\n\nfunction get_argument_types_from_llvm(fn::LLVM.Function)\n    [llvm_to_julia_type(param_type(fn, i))\n     for i in 1:length(parameters(fn))]\nend\n\nfunction llvm_to_julia_type(llvm_ty::LLVM.Type)\n    if isa(llvm_ty, LLVM.IntegerType)\n        width = bits(llvm_ty)\n        if width == 1\n            return Bool\n        elseif width == 8\n            return Int8\n        elseif width == 16\n            return Int16\n        elseif width == 32\n            return Int32\n        elseif width == 64\n            return Int64\n        end\n    elseif isa(llvm_ty, LLVM.FloatingPointType)\n        if isa(llvm_ty, LLVM.FloatType)\n            return Float32\n        elseif isa(llvm_ty, LLVM.DoubleType)\n            return Float64\n        end\n    elseif isa(llvm_ty, LLVM.PointerType)\n        return Ptr{Cvoid}  # More detailed type inference needed\n    elseif isa(llvm_ty, LLVM.VoidType)\n        return Cvoid\n    end\n    error(\"Unsupported LLVM type: $llvm_ty\")\nend\n\n","category":"section"},{"location":"design/Phase2/#Task-5:-Extended-Type-System-Implementation","page":"Phase 2","title":"Task 5: Extended Type System Implementation","text":"Priority: High Estimate: 2 weeks","category":"section"},{"location":"design/Phase2/#Implementation-Details-5","page":"Phase 2","title":"Implementation Details","text":"Ownership Type Support\n# src/rusttypes.jl (extended)\n\n# Box<T> - Heap-allocated value\nstruct RustBox{T}\n    ptr::Ptr{Cvoid}\n\n    function RustBox{T}(ptr::Ptr{Cvoid}) where {T}\n        new(ptr)\n    end\nend\n\n# Rc<T> - Reference-counted type\nstruct RustRc{T}\n    ptr::Ptr{Cvoid}\n    # Reference count managed on Rust side\nend\n\n# Arc<T> - Atomic reference-counted type\nstruct RustArc{T}\n    ptr::Ptr{Cvoid}\n    # Atomic reference count managed on Rust side\nend\nCollection Type Support\n# Vec<T>\nstruct RustVec{T}\n    ptr::Ptr{Cvoid}\n    len::UInt\n    cap::UInt\nend\n\n# String\nstruct RustString\n    vec::RustVec{UInt8}\nend\n\n# &str (string slice)\nstruct RustStr\n    ptr::Ptr{UInt8}\n    len::UInt\nend\nExtended Type Conversion\n# src/typetranslation.jl (extended)\n\nfunction rusttype_to_julia_extended(rust_type::String)\n    # Basic types\n    if haskey(RUST_TYPE_MAP, Symbol(rust_type))\n        return RUST_TYPE_MAP[Symbol(rust_type)]\n    end\n\n    # Box<T>\n    if startswith(rust_type, \"Box<\")\n        inner_type = extract_generic_type(rust_type, \"Box\")\n        return RustBox{rusttype_to_julia_extended(inner_type)}\n    end\n\n    # Vec<T>\n    if startswith(rust_type, \"Vec<\")\n        inner_type = extract_generic_type(rust_type, \"Vec\")\n        return RustVec{rusttype_to_julia_extended(inner_type)}\n    end\n\n    # Other types...\n    error(\"Unsupported Rust type: $rust_type\")\nend\n\nfunction extract_generic_type(type_str::String, container::String)\n    # \"Vec<i32>\" -> \"i32\"\n    # Implementation: Extract with regex or parser\nend\n\n","category":"section"},{"location":"design/Phase2/#Task-6:-Basic-Generics-Support","page":"Phase 2","title":"Task 6: Basic Generics Support","text":"Priority: Medium Estimate: 2 weeks","category":"section"},{"location":"design/Phase2/#Implementation-Details-6","page":"Phase 2","title":"Implementation Details","text":"Generics Type Representation\n# src/rusttypes.jl\n\nstruct RustGeneric{T, Args}\n    # T: Base type (e.g., Vec)\n    # Args: Tuple of type parameters\nend\n\n# Example: Vec<i32> -> RustGeneric{Val{:Vec}, Tuple{Int32}}\nGenerics Function Compilation\nfunction compile_generic_rust_function(\n    compiler::RustCompiler,\n    code::String,\n    type_params::Dict{Symbol, Type}\n)\n    # 1. Replace type parameters with concrete types\n    specialized_code = specialize_generic_code(code, type_params)\n\n    # 2. Compile\n    compile_rust_to_llvm(compiler, specialized_code)\nend\n\nfunction specialize_generic_code(code::String, type_params::Dict{Symbol, Type})\n    # Replace type parameters with concrete types\n    # Example: T -> i32\n    specialized = code\n    for (param, concrete_type) in type_params\n        rust_type = juliatype_to_rust(concrete_type)\n        specialized = replace(specialized, \"T\" => rust_type)\n    end\n    specialized\nend\n\n","category":"section"},{"location":"design/Phase2/#Task-7:-Memory-Management-Integration","page":"Phase 2","title":"Task 7: Memory Management Integration","text":"Priority: High Estimate: 1 week","category":"section"},{"location":"design/Phase2/#Implementation-Details-7","page":"Phase 2","title":"Implementation Details","text":"Ownership Management\n# src/memory.jl\n\n# Rust object lifecycle management\nconst rust_object_registry = Dict{Ptr{Cvoid}, Any}()\n\nfunction register_rust_object(ptr::Ptr{Cvoid}, obj::Any)\n    rust_object_registry[ptr] = obj\n    finalizer(obj) do x\n        # Call drop on Rust side\n        drop_rust_object(ptr)\n        delete!(rust_object_registry, ptr)\n    end\nend\n\nfunction drop_rust_object(ptr::Ptr{Cvoid})\n    # Call Rust drop function\n    # Implementation: Call Rust drop via ccall\nend\nArc<T> Integration with Julia GC\nfunction create_rust_arc(T::Type, value)\n    # Call Arc::new on Rust side\n    arc_ptr = ccall((:rust_arc_new, lib), Ptr{Cvoid}, (Any,), value)\n\n    # Manage on Julia side\n    arc = RustArc{T}(arc_ptr)\n    register_rust_object(arc_ptr, arc)\n    arc\nend\n\n","category":"section"},{"location":"design/Phase2/#Task-8:-Performance-Optimization","page":"Phase 2","title":"Task 8: Performance Optimization","text":"Priority: Medium Estimate: 1 week","category":"section"},{"location":"design/Phase2/#Implementation-Details-8","page":"Phase 2","title":"Implementation Details","text":"Inlining Optimization\nfunction optimize_for_inlining(mod::LLVM.Module)\n    # Mark small functions as inline candidates\n    for fn in functions(mod)\n        if length(parameters(fn)) <= 3 &&\n           !has_attributes(fn, \"noinline\")\n            add_inline_attribute!(fn)\n        end\n    end\nend\nCache Improvement\n# Persist compilation results\nconst persistent_cache = Dict{String, String}()  # code_hash -> ir_file_path\n\nfunction get_cached_llvm_ir(code_hash::String)\n    if haskey(persistent_cache, code_hash)\n        ir_file = persistent_cache[code_hash]\n        if isfile(ir_file)\n            return parse_llvm_ir(ir_file)\n        end\n    end\n    nothing\nend\n\n","category":"section"},{"location":"design/Phase2/#Task-9:-Test-Suite-Extension","page":"Phase 2","title":"Task 9: Test Suite Extension","text":"Priority: High Estimate: 1 week","category":"section"},{"location":"design/Phase2/#Implementation-Details-9","page":"Phase 2","title":"Implementation Details","text":"LLVM IR Integration Tests\n# test/llvm.jl\n@testset \"LLVM IR integration\" begin\n    rust_code = \"\"\"\n    pub fn add(a: i32, b: i32) -> i32 {\n        a + b\n    }\n    \"\"\"\n\n    mod = compile_rust_to_llvm(RustCompiler(), rust_code)\n    @test mod !== nothing\n\n    fn = functions(mod)[\"add\"]\n    @test fn !== nothing\nend\nOwnership Type Tests\n# test/ownership.jl\n@testset \"Ownership types\" begin\n    # Test Box, Rc, Arc\nend\n\n","category":"section"},{"location":"design/Phase2/#Implementation-Details-10","page":"Phase 2","title":"Implementation Details","text":"","category":"section"},{"location":"design/Phase2/#File-Structure-(Extended)","page":"Phase 2","title":"File Structure (Extended)","text":"src/\n├── RustCall.jl              # Main module\n├── rustmacro.jl         # @rust macro (extended)\n├── ruststr.jl           # rust\"\" and irust\"\" (extended)\n├── rusttypes.jl         # Rust type definitions (extended)\n├── typetranslation.jl   # Type conversion (extended)\n├── rustcompiler.jl      # Rust compiler integration (new)\n├── llvmintegration.jl  # LLVM integration (new)\n├── llvmoptimization.jl # LLVM optimization (new)\n├── rustcodegen.jl      # Code generation (new)\n├── rustinstances.jl    # Compiler instances (new)\n├── memory.jl           # Memory management (new)\n└── exceptions.jl       # Error handling (extended)","category":"section"},{"location":"design/Phase2/#Main-Function-Signatures-(Extended)","page":"Phase 2","title":"Main Function Signatures (Extended)","text":"# rustcompiler.jl\nRustCompiler(; kwargs...) -> RustCompiler\ncompile_rust_to_llvm(compiler, code; output_file) -> LLVM.Module\ncompile_rust_to_llvm_cached(compiler, code) -> LLVM.Module\n\n# llvmintegration.jl\nparse_llvm_ir(ir_file) -> LLVM.Module\nparse_llvm_ir_string(ir_string) -> LLVM.Module\nget_llvm_context(name) -> LLVM.Context\n\n# llvmoptimization.jl\noptimize_llvm_module(mod, level) -> LLVM.Module\noptimize_function(fn, level) -> Nothing\ncreate_optimization_pipeline(level) -> ModulePassManager\n\n# rustcodegen.jl\nrustcall(CT, expr, args...) -> (generated function)\nget_return_type_from_llvm(fn) -> Type\nget_argument_types_from_llvm(fn) -> Vector{Type}\nllvm_to_julia_type(llvm_ty) -> Type\n\n# memory.jl\nregister_rust_object(ptr, obj) -> Nothing\ndrop_rust_object(ptr) -> Nothing\ncreate_rust_arc(T, value) -> RustArc{T}\n\n","category":"section"},{"location":"design/Phase2/#Migration-from-Phase-1","page":"Phase 2","title":"Migration from Phase 1","text":"Extend Phase 1 features in Phase 2:\n\n@rust macro: Migrate from ccall to llvmcall\nrust\"\" string literal: Migrate from shared library to LLVM IR generation\nType system: Extend from basic types to ownership types and collection types\n\n","category":"section"},{"location":"design/Phase2/#Limitations","page":"Phase 2","title":"Limitations","text":"Phase 2 still has the following limitations:\n\nExplicit lifetime handling: Lifetime parameters are not yet fully supported\nBorrow checker: Compile-time checks are performed on Rust side\nMacro system: Full proc-macro support is not yet available\n\n","category":"section"},{"location":"design/Phase2/#Next-Steps-(Transition-to-Phase-3)","page":"Phase 2","title":"Next Steps (Transition to Phase 3)","text":"After Phase 2 is complete, implement the following features in Phase 3:\n\nrustc internal API integration\nFull lifetime support\nBorrow checker integration\nFull macro system support\n\n","category":"section"},{"location":"design/Phase2/#Reference-Implementation","page":"Phase 2","title":"Reference Implementation","text":"Refer to Cxx.jl's codegen.jl\nRefer to LLVM.jl documentation\nInvestigate Rust LLVM IR output","category":"section"},{"location":"generics/#Generics-Support-in-RustCall.jl","page":"Generics","title":"Generics Support in RustCall.jl","text":"RustCall.jl now supports calling generic Rust functions from Julia. This document explains how to use this feature.","category":"section"},{"location":"generics/#Overview","page":"Generics","title":"Overview","text":"Generic functions in Rust use type parameters (e.g., fn identity<T>(x: T) -> T). RustCall.jl automatically:\n\nDetects generic functions in rust\"\" blocks\nMonomorphizes them with specific type parameters when called\nCaches the monomorphized instances for reuse","category":"section"},{"location":"generics/#Basic-Usage","page":"Generics","title":"Basic Usage","text":"","category":"section"},{"location":"generics/#Automatic-Detection","page":"Generics","title":"Automatic Detection","text":"When you define a generic function in a rust\"\" block, RustCall.jl automatically detects and registers it:\n\n\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn identity<T>(x: T) -> T {\n    x\n}\n\"\"\"\n\n# The function is automatically registered as generic\n# When you call it, it's automatically monomorphized\nresult = @rust identity(Int32(42))::Int32  # => 42\nresult = @rust identity(Float64(3.14))::Float64  # => 3.14","category":"section"},{"location":"generics/#Manual-Registration","page":"Generics","title":"Manual Registration","text":"You can also manually register generic functions:\n\nusing RustCall\n\ncode = \"\"\"\n#[no_mangle]\npub extern \"C\" fn add<T>(a: T, b: T) -> T {\n    a + b\n}\n\"\"\"\n\nregister_generic_function(\"add\", code, [:T])\n\n# Call with different types\nresult = call_generic_function(\"add\", Int32(10), Int32(20))  # => 30","category":"section"},{"location":"generics/#How-It-Works","page":"Generics","title":"How It Works","text":"","category":"section"},{"location":"generics/#1.-Type-Parameter-Inference","page":"Generics","title":"1. Type Parameter Inference","text":"When you call a generic function, RustCall.jl infers type parameters from the argument types:\n\n# For function: fn identity<T>(x: T) -> T\n# Called with: identity(Int32(42))\n# Type parameter T is inferred as Int32","category":"section"},{"location":"generics/#2.-Monomorphization","page":"Generics","title":"2. Monomorphization","text":"The generic function is specialized (monomorphized) with the inferred types:\n\n// Original: fn identity<T>(x: T) -> T { x }\n// Specialized: fn identity_i32(x: i32) -> i32 { x }","category":"section"},{"location":"generics/#3.-Compilation-and-Caching","page":"Generics","title":"3. Compilation and Caching","text":"The specialized function is compiled and cached. Subsequent calls with the same type parameters reuse the cached version.","category":"section"},{"location":"generics/#Advanced-Usage","page":"Generics","title":"Advanced Usage","text":"","category":"section"},{"location":"generics/#Multiple-Type-Parameters","page":"Generics","title":"Multiple Type Parameters","text":"rust\"\"\"\n#[no_mangle]\npub extern \"C\" fn first<T, U>(a: T, b: U) -> T {\n    a\n}\n\"\"\"\n\n# Type parameters are inferred from arguments\nresult = @rust first(Int32(10), Float64(3.14))::Int32  # => 10","category":"section"},{"location":"generics/#Explicit-Type-Parameters","page":"Generics","title":"Explicit Type Parameters","text":"You can also explicitly specify type parameters:\n\n# Define the code\ncode = \"\"\"\n#[no_mangle]\npub extern \"C\" fn identity<T>(x: T) -> T {\n    x\n}\n\"\"\"\n\n# Register generic function\nregister_generic_function(\"identity\", code, [:T])\n\n# Explicitly monomorphize\ntype_params = Dict(:T => Int32)\ninfo = monomorphize_function(\"identity\", type_params)\n\n# Call using @rust macro (recommended way)\n# Note: After monomorphization, you can call it directly\nresult = @rust identity(Int32(42))::Int32  # => 42","category":"section"},{"location":"generics/#Trait-Bounds-Support","page":"Generics","title":"Trait Bounds Support","text":"RustCall.jl now supports parsing trait bounds in generic functions. This includes:\n\nInline bounds: fn foo<T: Copy + Clone, U: Debug>(x: T) -> U\nWhere clauses: fn foo<T, U>(x: T) -> U where T: Copy, U: Debug\nGeneric trait bounds: fn foo<T: Add<Output = T>>(x: T) -> T\nMixed format: Combining inline bounds and where clauses","category":"section"},{"location":"generics/#Using-Trait-Bounds","page":"Generics","title":"Using Trait Bounds","text":"When registering a generic function, trait bounds are automatically parsed and stored:\n\nusing RustCall\n\n# Define a function with trait bounds\ncode = \"\"\"\npub fn identity<T: Copy + Clone>(x: T) -> T {\n    x\n}\n\"\"\"\n\n# Parse the generic function (constraints are automatically extracted)\ninfo = parse_generic_function(code, \"identity\")\nprintln(info.constraints)  # Dict(:T => TypeConstraints([Copy, Clone]))","category":"section"},{"location":"generics/#Manually-Specifying-Constraints","page":"Generics","title":"Manually Specifying Constraints","text":"You can also manually specify constraints when registering a generic function:\n\nusing RustCall\n\ncode = \"\"\"\npub fn add<T>(a: T, b: T) -> T {\n    a + b\n}\n\"\"\"\n\n# Using TypeConstraints (recommended)\nconstraints = Dict(:T => TypeConstraints([\n    TraitBound(\"Copy\", String[]),\n    TraitBound(\"Add\", [\"Output = T\"])\n]))\nregister_generic_function(\"add\", code, [:T], constraints)\n\n# Or using the legacy string format (backward compatible)\nregister_generic_function(\"add_legacy\", code, [:T], Dict(:T => \"Copy + Add<Output = T>\"))","category":"section"},{"location":"generics/#Converting-Constraints-to-Rust-Syntax","page":"Generics","title":"Converting Constraints to Rust Syntax","text":"You can convert parsed constraints back to Rust syntax:\n\nusing RustCall\n\nconstraints = Dict(:T => TypeConstraints([\n    TraitBound(\"Copy\", String[]),\n    TraitBound(\"Clone\", String[])\n]))\nrust_str = constraints_to_rust_string(constraints)\nprintln(rust_str)  # \"T: Copy + Clone\"","category":"section"},{"location":"generics/#Limitations","page":"Generics","title":"Limitations","text":"","category":"section"},{"location":"generics/#Trait-Bounds-Validation","page":"Generics","title":"Trait Bounds Validation","text":"While trait bounds are now properly parsed and stored, runtime validation (checking if a Julia type satisfies Rust trait bounds) is not yet implemented. The bounds are stored for:\n\nDocumentation and introspection\nFuture code generation improvements\nError reporting when trait bounds are not satisfied","category":"section"},{"location":"generics/#Complex-Type-Inference","page":"Generics","title":"Complex Type Inference","text":"Type parameter inference is currently simplified:\n\nOne type parameter maps to one argument (for single-parameter functions)\nMultiple type parameters map to multiple arguments in order\n\nMore complex inference (e.g., inferring from return type) is not yet supported.","category":"section"},{"location":"generics/#API-Reference","page":"Generics","title":"API Reference","text":"","category":"section"},{"location":"generics/#Types","page":"Generics","title":"Types","text":"TraitBound(trait_name, type_params) - Represents a single trait bound (e.g., Copy, Add<Output = T>)\nTypeConstraints(bounds) - Represents all trait bounds for a type parameter\nGenericFunctionInfo - Information about a generic Rust function","category":"section"},{"location":"generics/#Functions","page":"Generics","title":"Functions","text":"","category":"section"},{"location":"generics/#Generic-Function-Management","page":"Generics","title":"Generic Function Management","text":"register_generic_function(func_name, code, type_params, constraints=Dict()) - Register a generic function\nis_generic_function(func_name) - Check if a function is generic\ncall_generic_function(func_name, args...) - Call a generic function (auto-monomorphizes)\nmonomorphize_function(func_name, type_params) - Explicitly monomorphize a function\nspecialize_generic_code(code, type_params) - Specialize generic code with type parameters\ninfer_type_parameters(func_name, arg_types) - Infer type parameters from argument types","category":"section"},{"location":"generics/#Trait-Bounds-Parsing","page":"Generics","title":"Trait Bounds Parsing","text":"parse_single_trait(trait_str) - Parse a single trait bound string (e.g., \"Copy\", \"Add<Output = T>\")\nparse_trait_bounds(bounds_str) - Parse multiple trait bounds (e.g., \"Copy + Clone\")\nparse_inline_constraints(type_params_str) - Parse inline type parameters with constraints\nparse_where_clause(code) - Parse a where clause from Rust code\nparse_generic_function(code, func_name) - Parse a generic function and extract type parameters with constraints\nmerge_constraints(c1, c2) - Merge two constraint dictionaries\nconstraints_to_rust_string(constraints) - Convert constraints back to Rust syntax","category":"section"},{"location":"generics/#Registries","page":"Generics","title":"Registries","text":"GENERIC_FUNCTION_REGISTRY - Maps function names to GenericFunctionInfo\nMONOMORPHIZED_FUNCTIONS - Maps (function_name, type_params_tuple) to FunctionInfo","category":"section"},{"location":"generics/#Examples","page":"Generics","title":"Examples","text":"","category":"section"},{"location":"generics/#Example-1:-Simple-Generic-Function","page":"Generics","title":"Example 1: Simple Generic Function","text":"rust\"\"\"\n#[no_mangle]\npub extern \"C\" fn identity<T>(x: T) -> T {\n    x\n}\n\"\"\"\n\n# Automatically monomorphized and called\nresult1 = @rust identity(Int32(42))::Int32  # => 42\nresult2 = @rust identity(Float64(3.14))::Float64  # => 3.14\nprintln(\"Int32 result: $result1\")\nprintln(\"Float64 result: $result2\")","category":"section"},{"location":"generics/#Example-2:-Multiple-Type-Parameters","page":"Generics","title":"Example 2: Multiple Type Parameters","text":"rust\"\"\"\n#[no_mangle]\npub extern \"C\" fn first<T, U>(a: T, b: U) -> T {\n    a\n}\n\"\"\"\n\nresult = @rust first(Int32(10), Float64(20.0))::Int32  # => 10\nprintln(\"Result: $result\")","category":"section"},{"location":"generics/#Example-3:-Manual-Registration-and-Monomorphization","page":"Generics","title":"Example 3: Manual Registration and Monomorphization","text":"code = \"\"\"\n#[no_mangle]\npub extern \"C\" fn multiply<T>(a: T, b: T) -> T {\n    a * b\n}\n\"\"\"\n\nregister_generic_function(\"multiply\", code, [:T])\n\n# Call with automatic monomorphization\nresult = call_generic_function(\"multiply\", Int32(5), Int32(6))  # => 30\nprintln(\"Result: $result\")","category":"section"},{"location":"generics/#Implementation-Details","page":"Generics","title":"Implementation Details","text":"","category":"section"},{"location":"generics/#Code-Specialization","page":"Generics","title":"Code Specialization","text":"The specialize_generic_code function:\n\nReplaces type parameters (T, U, etc.) with concrete Rust types (i32, f64, etc.)\nRemoves generic parameter lists (<T>)\nPreserves function structure and attributes","category":"section"},{"location":"generics/#Monomorphization-Process","page":"Generics","title":"Monomorphization Process","text":"Check cache for existing monomorphized instance\nIf not cached, specialize the code\nReplace function name with specialized name (e.g., identity_i32)\nEnsure #[no_mangle] and extern \"C\" are present\nCompile the specialized function\nLoad and cache the compiled library\nReturn FunctionInfo for the monomorphized function","category":"section"},{"location":"generics/#Caching-Strategy","page":"Generics","title":"Caching Strategy","text":"Monomorphized functions are cached by:\n\nFunction name\nType parameters tuple (sorted for consistency)\n\nThis ensures that calling the same generic function with the same types reuses the compiled instance.","category":"section"},{"location":"generics/#See-Also","page":"Generics","title":"See Also","text":"Tutorial - General tutorial\nExamples - More examples\ntest/test_generics.jl - Test suite with examples","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page provides the API documentation for RustCall.jl.","category":"section"},{"location":"api/#Macros","page":"API Reference","title":"Macros","text":"","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#Result-and-Option-Types","page":"API Reference","title":"Result and Option Types","text":"","category":"section"},{"location":"api/#Ownership-Types","page":"API Reference","title":"Ownership Types","text":"","category":"section"},{"location":"api/#Pointer-Types","page":"API Reference","title":"Pointer Types","text":"","category":"section"},{"location":"api/#String-Types","page":"API Reference","title":"String Types","text":"","category":"section"},{"location":"api/#Error-Types","page":"API Reference","title":"Error Types","text":"","category":"section"},{"location":"api/#Type-Conversion-Functions","page":"API Reference","title":"Type Conversion Functions","text":"","category":"section"},{"location":"api/#Result/Option-Operations","page":"API Reference","title":"Result/Option Operations","text":"","category":"section"},{"location":"api/#String-Conversion-Functions","page":"API Reference","title":"String Conversion Functions","text":"","category":"section"},{"location":"api/#Error-Handling","page":"API Reference","title":"Error Handling","text":"","category":"section"},{"location":"api/#Compiler-Functions","page":"API Reference","title":"Compiler Functions","text":"","category":"section"},{"location":"api/#Ownership-Type-Operations","page":"API Reference","title":"Ownership Type Operations","text":"","category":"section"},{"location":"api/#RustVec-Operations","page":"API Reference","title":"RustVec Operations","text":"","category":"section"},{"location":"api/#Cache-Management","page":"API Reference","title":"Cache Management","text":"","category":"section"},{"location":"api/#LLVM-Optimization","page":"API Reference","title":"LLVM Optimization","text":"","category":"section"},{"location":"api/#LLVM-Function-Registration","page":"API Reference","title":"LLVM Function Registration","text":"","category":"section"},{"location":"api/#Generics-Support","page":"API Reference","title":"Generics Support","text":"","category":"section"},{"location":"api/#Generic-Constraints","page":"API Reference","title":"Generic Constraints","text":"","category":"section"},{"location":"api/#External-Library-Integration","page":"API Reference","title":"External Library Integration","text":"","category":"section"},{"location":"api/#Dependency-Management","page":"API Reference","title":"Dependency Management","text":"","category":"section"},{"location":"api/#Cargo-Project-Management","page":"API Reference","title":"Cargo Project Management","text":"","category":"section"},{"location":"api/#Crate-Bindings","page":"API Reference","title":"Crate Bindings","text":"","category":"section"},{"location":"api/#Hot-Reload","page":"API Reference","title":"Hot Reload","text":"","category":"section"},{"location":"api/#Type-System","page":"API Reference","title":"Type System","text":"","category":"section"},{"location":"api/#Type-Mapping-Constants","page":"API Reference","title":"Type Mapping Constants","text":"The following constants define the mapping between Rust types and Julia types:\n\n# Rust to Julia type mapping\nconst RUST_TO_JULIA_TYPE_MAP = Dict{Symbol, Type}(\n    :i8 => Int8,\n    :i16 => Int16,\n    :i32 => Int32,\n    :i64 => Int64,\n    :u8 => UInt8,\n    :u16 => UInt16,\n    :u32 => UInt32,\n    :u64 => UInt64,\n    :f32 => Float32,\n    :f64 => Float64,\n    :bool => Bool,\n    :usize => UInt,\n    :isize => Int,\n    Symbol(\"()\") => Cvoid,\n)\n\n# Julia to Rust type mapping\nconst JULIA_TO_RUST_TYPE_MAP = Dict{Type, String}(\n    Int8 => \"i8\",\n    Int16 => \"i16\",\n    Int32 => \"i32\",\n    Int64 => \"i64\",\n    UInt8 => \"u8\",\n    UInt16 => \"u16\",\n    UInt32 => \"u32\",\n    UInt64 => \"u64\",\n    Float32 => \"f32\",\n    Float64 => \"f64\",\n    Bool => \"bool\",\n    Cvoid => \"()\",\n)","category":"section"},{"location":"api/#Internal-Registries","page":"API Reference","title":"Internal Registries","text":"The following registries are used internally by RustCall.jl:\n\nThe following registries and constants are not exported but are available for advanced usage.\n\nNote: These constants are internal implementation details. They are documented here for completeness but should not be accessed directly by users.","category":"section"},{"location":"api/#Utility-Functions","page":"API Reference","title":"Utility Functions","text":"","category":"section"},{"location":"api/#Testing-and-Debugging","page":"API Reference","title":"Testing and Debugging","text":"These functions are exported for testing purposes but are considered internal. They are wrappers around internal implementation functions.","category":"section"},{"location":"api/#Internal-Functions-and-Types","page":"API Reference","title":"Internal Functions and Types","text":"The following functions and types are internal implementation details and are not part of the public API. They are documented here for completeness but should not be used directly by users.","category":"section"},{"location":"api/#RustCall.@rust","page":"API Reference","title":"RustCall.@rust","text":"@rust expr\n\nCall a Rust function from Julia.\n\nSyntax\n\n@rust func(args...) - Call a function with automatic type inference\n@rust func(args...)::RetType - Call with explicit return type\n@rust lib::func(args...) - Call from a specific library\n\nExamples\n\n# Simple call (types inferred from arguments)\n@rust add(10i32, 20i32)\n\n# With explicit return type\n@rust add(10, 20)::Int32\n\n# From specific library\n@rust mylib::multiply(3.0, 4.0)\n\n\n\n\n\n","category":"macro"},{"location":"api/#RustCall.@rust_str","page":"API Reference","title":"RustCall.@rust_str","text":"@rust_str(code)\n\nCompile Rust code and load it as a shared library.\n\nExample\n\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\"\"\"\n\n\n\n\n\n","category":"macro"},{"location":"api/#RustCall.@irust","page":"API Reference","title":"RustCall.@irust","text":"@irust(code, args...)\n@irust(code)\n\nExecute Rust code at function scope.\n\nThis macro compiles Rust code into a temporary function and calls it. Julia variables can be referenced using $var syntax or passed as arguments.\n\nFeatures\n\nAutomatic variable binding with $var syntax\nImproved type inference from code\nBetter error messages\n\nExamples\n\n# Using $var syntax (recommended)\nfunction myfunc(x)\n    @irust(\"$x * 2\")\nend\n\n# Using explicit arguments (legacy, still supported)\nfunction myfunc(x)\n    @irust(\"arg1 * 2\", x)\nend\n\n# Multiple variables\nfunction add_and_multiply(a, b, c)\n    @irust(\"$a + $b * $c\")\nend\n\nFor more complex cases, use rust\"\"\" to define functions explicitly.\n\n\n\n\n\n","category":"macro"},{"location":"api/#RustCall.@irust_str","page":"API Reference","title":"RustCall.@irust_str","text":"@irust_str(code)\n\nString literal form of @irust. Use @irust(\"code\", args...) for better syntax.\n\nExample\n\n@irust_str(\"arg1 * 2\")  # Note: arguments must be passed separately\n\n\n\n\n\n","category":"macro"},{"location":"api/#RustCall.@rust_llvm","page":"API Reference","title":"RustCall.@rust_llvm","text":"@rust_llvm func_name(args...)\n\nCall a Rust function using LLVM IR integration (Phase 2). This uses @generated functions to produce optimized code at compile time.\n\nExample\n\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn add_optimized(a: i32, b: i32) -> i32 {\n    a + b\n}\n\"\"\"\n\n# Use llvmcall path (experimental)\nresult = @rust_llvm add_optimized(10, 20)\n\n\n\n\n\n","category":"macro"},{"location":"api/#RustCall.RustResult","page":"API Reference","title":"RustCall.RustResult","text":"RustResult{T, E}\n\nRepresents Rust's Result<T, E> type.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.RustOption","page":"API Reference","title":"RustCall.RustOption","text":"RustOption{T}\n\nRepresents Rust's Option<T> type.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.RustBox","page":"API Reference","title":"RustCall.RustBox","text":"RustBox{T}\n\nRepresents Rust's Box<T> type - a heap-allocated value with single ownership. The memory is owned by this wrapper and should be dropped when no longer needed.\n\nMemory Management\n\nRustBox owns its data and is responsible for calling drop\nUse drop! to explicitly release the memory\nFinalizers can be attached for automatic cleanup\n\nExample\n\n# Create a Box (typically from Rust)\nbox = RustBox{Int32}(ptr)\n\n# Access the value\nvalue = deref(box)\n\n# Drop when done\ndrop!(box)\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.RustRc","page":"API Reference","title":"RustCall.RustRc","text":"RustRc{T}\n\nRepresents Rust's Rc<T> type - a reference-counted pointer (single-threaded). Multiple RustRc instances can share ownership of the same data.\n\nMemory Management\n\nReference counting is managed by Rust\nJulia side should call clone to create new references\nCall drop! to decrement reference count\n\nNote\n\nRc<T> is not thread-safe. For multi-threaded scenarios, use RustArc{T}.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.RustArc","page":"API Reference","title":"RustCall.RustArc","text":"RustArc{T}\n\nRepresents Rust's Arc<T> type - an atomically reference-counted pointer (thread-safe). Multiple RustArc instances can share ownership across threads.\n\nMemory Management\n\nAtomic reference counting is managed by Rust\nSafe to share across Julia tasks/threads\nCall drop! to decrement reference count\n\nExample\n\n# Create an Arc (from Rust)\narc = RustArc{MyData}(ptr)\n\n# Clone for another owner\narc2 = clone(arc)\n\n# Safe to use in different tasks\n@spawn begin\n    # Use arc2\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.RustVec","page":"API Reference","title":"RustCall.RustVec","text":"RustVec{T}\n\nRepresents Rust's Vec<T> type - a growable array.\n\nFields\n\nptr: Pointer to the data\nlen: Number of elements\ncap: Capacity (number of elements that can be stored without reallocation)\n\nMemory Management\n\nThe vector owns its data\nUse drop! to release memory when done\n\nExample\n\n# Create from Rust\nvec = RustVec{Int32}(ptr, len, cap)\n\n# Access length\nlength(vec)  # => len\n\n# Convert to Julia array (copies data)\njulia_arr = collect(vec)\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.RustSlice","page":"API Reference","title":"RustCall.RustSlice","text":"RustSlice{T}\n\nRepresents Rust's slice type &[T] - a borrowed view into a contiguous sequence.\n\nFields\n\nptr: Pointer to the first element\nlen: Number of elements\n\nNote\n\nThis is a borrowed reference; the underlying data must outlive the slice.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.RustPtr","page":"API Reference","title":"RustCall.RustPtr","text":"RustPtr{T}\n\nA pointer to a Rust value of type T. Corresponds to *const T or *mut T in Rust.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.RustRef","page":"API Reference","title":"RustCall.RustRef","text":"RustRef{T}\n\nA reference to a Rust value of type T. Corresponds to &T or &mut T in Rust. Note: In C ABI, references are passed as pointers.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.RustString","page":"API Reference","title":"RustCall.RustString","text":"RustString\n\nRepresents Rust's owned String type. This is a wrapper around a pointer to a Rust String. The memory is managed by Rust (via Box or similar).\n\nMemory Management\n\nWhen a Rust function returns a String, it should be freed using drop_rust_string or similar function provided by the Rust side.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.RustStr","page":"API Reference","title":"RustCall.RustStr","text":"RustStr\n\nRepresents Rust's string slice &str. This is a borrowed reference, so the memory is managed elsewhere.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.RustError","page":"API Reference","title":"RustCall.RustError","text":"RustError <: Exception\n\nException type for Rust-related errors.\n\nFields\n\nmessage::String: Error message\ncode::Int32: Optional error code (default: 0)\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.CompilationError","page":"API Reference","title":"RustCall.CompilationError","text":"CompilationError <: Exception\n\nException type for Rust compilation errors.\n\nFields\n\nmessage::String: Formatted error message\nraw_stderr::String: Raw stderr output from rustc\nsource_code::String: The Rust source code that failed to compile\ncommand::String: The rustc command that was executed\nfile_path::String: Source file path (if available)\nline_number::Int: Line number where error occurred (if available)\ncontext::Dict{String, Any}: Additional debugging context\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.RuntimeError","page":"API Reference","title":"RustCall.RuntimeError","text":"RuntimeError <: Exception\n\nException type for Rust runtime errors.\n\nFields\n\nmessage::String: Error message\nfunction_name::String: Name of the function that failed\nstack_trace::String: Optional stack trace (default: \"\")\narguments::Vector{Any}: Function arguments that caused the error\nlibrary_name::String: Name of the library containing the function\ncontext::Dict{String, Any}: Additional debugging context\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.CargoBuildError","page":"API Reference","title":"RustCall.CargoBuildError","text":"CargoBuildError <: Exception\n\nException type for Cargo build failures.\n\nFields\n\nmessage::String: Error message\nstderr::String: Raw stderr output from cargo\nproject_path::String: Path to the Cargo project that failed to build\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.DependencyResolutionError","page":"API Reference","title":"RustCall.DependencyResolutionError","text":"DependencyResolutionError <: Exception\n\nException type for dependency resolution failures.\n\nFields\n\ndependency::String: Name of the problematic dependency\nmessage::String: Error message describing the resolution failure\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.rusttype_to_julia","page":"API Reference","title":"RustCall.rusttype_to_julia","text":"rusttype_to_julia(rust_type::Symbol) -> Type\n\nConvert a Rust type name to the corresponding Julia type.\n\nExamples\n\nrusttype_to_julia(:i32)  # => Int32\nrusttype_to_julia(:f64)  # => Float64\nrusttype_to_julia(:bool) # => Bool\n\n\n\n\n\nrusttype_to_julia(rust_type::String) -> Type\n\nConvert a Rust type name string to the corresponding Julia type. Handles pointer types like *const i32 and *mut i32. Also handles string types like String and &str.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.juliatype_to_rust","page":"API Reference","title":"RustCall.juliatype_to_rust","text":"juliatype_to_rust(julia_type::Type) -> String\n\nConvert a Julia type to the corresponding Rust type name.\n\nExamples\n\njuliatype_to_rust(Int32)   # => \"i32\"\njuliatype_to_rust(Float64) # => \"f64\"\njuliatype_to_rust(Bool)    # => \"bool\"\njuliatype_to_rust(String)  # => \"*const u8\" (for FFI)\njuliatype_to_rust(Cstring) # => \"*const u8\"\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.unwrap","page":"API Reference","title":"RustCall.unwrap","text":"unwrap(result::RustResult)\n\nUnwrap a RustResult, returning the Ok value or throwing an error.\n\n\n\n\n\nunwrap(option::RustOption)\n\nUnwrap a RustOption, returning the Some value or throwing an error.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.unwrap_or","page":"API Reference","title":"RustCall.unwrap_or","text":"unwrap_or(result::RustResult{T, E}, default::T)\n\nUnwrap a RustResult, returning the Ok value or the provided default.\n\n\n\n\n\nunwrap_or(option::RustOption{T}, default::T)\n\nUnwrap a RustOption, returning the Some value or the provided default.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.is_ok","page":"API Reference","title":"RustCall.is_ok","text":"is_ok(result::RustResult)\n\nCheck if a RustResult is Ok.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.is_err","page":"API Reference","title":"RustCall.is_err","text":"is_err(result::RustResult)\n\nCheck if a RustResult is Err.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.is_some","page":"API Reference","title":"RustCall.is_some","text":"is_some(option::RustOption)\n\nCheck if a RustOption is Some.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.is_none","page":"API Reference","title":"RustCall.is_none","text":"is_none(option::RustOption)\n\nCheck if a RustOption is None.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.result_to_exception","page":"API Reference","title":"RustCall.result_to_exception","text":"result_to_exception(result::RustResult{T, E}) where {T, E}\n\nConvert a RustResult to either return the Ok value or throw a RustError.\n\nArguments\n\nresult::RustResult{T, E}: The Rust result to convert\n\nReturns\n\nThe Ok value of type T if the result is Ok\n\nThrows\n\nRustError if the result is Err\n\nExample\n\nresult = RustResult{Int32, String}(false, \"division by zero\")\ntry\n    value = result_to_exception(result)\ncatch e\n    @assert e isa RustError\n    println(e.message)  # => \"division by zero\"\nend\n\n\n\n\n\nresult_to_exception(result::RustResult{T, E}, code::Int32) where {T, E}\n\nConvert a RustResult to either return the Ok value or throw a RustError with a specific error code.\n\nArguments\n\nresult::RustResult{T, E}: The Rust result to convert\ncode::Int32: Error code to use if the result is Err\n\nReturns\n\nThe Ok value of type T if the result is Ok\n\nThrows\n\nRustError with the specified code if the result is Err\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.unwrap_or_throw","page":"API Reference","title":"RustCall.unwrap_or_throw","text":"unwrap_or_throw(result::RustResult{T, E}) where {T, E}\n\nAlias for result_to_exception that throws a RustError on Err.\n\nThis is a convenience function that provides a more Rust-like naming convention.\n\n\n\n\n\nunwrap_or_throw(result::RustResult{T, E}, code::Int32) where {T, E}\n\nAlias for result_to_exception with error code.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.rust_string_to_julia","page":"API Reference","title":"RustCall.rust_string_to_julia","text":"rust_string_to_julia(rs::RustString) -> String\n\nConvert a RustString to a Julia String. This copies the data from Rust memory to Julia memory.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.rust_str_to_julia","page":"API Reference","title":"RustCall.rust_str_to_julia","text":"rust_str_to_julia(rs::RustStr) -> String\n\nConvert a RustStr (string slice) to a Julia String. This copies the data.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.julia_string_to_rust","page":"API Reference","title":"RustCall.julia_string_to_rust","text":"julia_string_to_rust(s::String) -> RustStr\n\nConvert a Julia String to a RustStr (borrowed reference). Note: The returned RustStr is only valid while the Julia String exists. For FFI, you typically want to use Cstring instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.julia_string_to_cstring","page":"API Reference","title":"RustCall.julia_string_to_cstring","text":"julia_string_to_cstring(s::String) -> String\n\nPrepare a Julia String for FFI (to be converted to Cstring by ccall). Note: The actual conversion happens at ccall time via cconvert/unsafe_convert.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.cstring_to_julia_string","page":"API Reference","title":"RustCall.cstring_to_julia_string","text":"cstring_to_julia_string(cs::Cstring) -> String\n\nConvert a Cstring (from Rust) to a Julia String. This copies the data.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.format_rustc_error","page":"API Reference","title":"RustCall.format_rustc_error","text":"format_rustc_error(stderr::String) -> String\n\nFormat rustc error output to be more readable. Removes redundant information and highlights important parts.\n\nImprovements\n\nBetter error line highlighting\nContext-aware formatting\nSuggestion extraction\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.suggest_fix_for_error","page":"API Reference","title":"RustCall.suggest_fix_for_error","text":"suggest_fix_for_error(stderr::String, source_code::String) -> Vector{String}\n\nAnalyze compilation error and suggest potential fixes.\n\nReturns\n\nVector of suggested fixes (strings)\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.RustCompiler","page":"API Reference","title":"RustCall.RustCompiler","text":"RustCompiler\n\nConfiguration for the Rust compiler.\n\nFields\n\ntarget_triple::String: Target triple for compilation\noptimization_level::Int: Optimization level 0-3\nemit_debug_info::Bool: Whether to emit debug info\ndebug_mode::Bool: Enable debug mode (keep intermediate files, verbose output)\ndebug_dir::Union{String, Nothing}: Directory to keep debug files (default: nothing = use temp dir)\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.compile_with_recovery","page":"API Reference","title":"RustCall.compile_with_recovery","text":"compile_with_recovery(code::String, compiler::RustCompiler;\n                      retry_count::Int=1) -> String\n\nCompile Rust code with error recovery support. If compilation fails, attempts to retry with different compiler settings.\n\nArguments\n\ncode::String: Rust source code\ncompiler::RustCompiler: Compiler configuration\n\nKeyword Arguments\n\nretry_count::Int: Number of retry attempts (default: 1)\n\nReturns\n\nPath to the generated shared library\n\nThrows\n\nCompilationError if all recovery attempts fail\n\nNote\n\nCache recovery should be handled by the caller (e.g., in ruststr.jl). This function only handles retry with different compiler settings.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.check_rustc_available","page":"API Reference","title":"RustCall.check_rustc_available","text":"check_rustc_available() -> Bool\n\nCheck if rustc is available using RustToolChain.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.get_rustc_version","page":"API Reference","title":"RustCall.get_rustc_version","text":"get_rustc_version() -> String\n\nGet the version of rustc using RustToolChain.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.get_default_compiler","page":"API Reference","title":"RustCall.get_default_compiler","text":"get_default_compiler() -> RustCompiler\n\nGet or create the default RustCompiler instance.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.set_default_compiler","page":"API Reference","title":"RustCall.set_default_compiler","text":"set_default_compiler(compiler::RustCompiler)\n\nSet the default RustCompiler instance.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.compile_rust_to_shared_lib","page":"API Reference","title":"RustCall.compile_rust_to_shared_lib","text":"compile_rust_to_shared_lib(code::String; compiler=get_default_compiler()) -> String\n\nCompile Rust code to a shared library and return the path.\n\nArguments\n\ncode::String: Rust source code\n\nKeyword Arguments\n\ncompiler::RustCompiler: Compiler configuration (default: default compiler)\n\nReturns\n\nPath to the generated shared library\n\nThrows\n\nCompilationError if compilation fails\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.compile_rust_to_llvm_ir","page":"API Reference","title":"RustCall.compile_rust_to_llvm_ir","text":"compile_rust_to_llvm_ir(code::String; compiler=get_default_compiler()) -> String\n\nCompile Rust code to LLVM IR and return the path to the generated .ll file.\n\nArguments\n\ncode::String: Rust source code\n\nKeyword Arguments\n\ncompiler::RustCompiler: Compiler configuration (default: default compiler)\n\nReturns\n\nPath to the generated LLVM IR file (.ll)\n\nThrows\n\nCompilationError if compilation fails\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.load_llvm_ir","page":"API Reference","title":"RustCall.load_llvm_ir","text":"load_llvm_ir(ir_file::String) -> RustModule\n\nLoad an LLVM IR file and create a RustModule.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.wrap_rust_code","page":"API Reference","title":"RustCall.wrap_rust_code","text":"wrap_rust_code(code::String) -> String\n\nWrap Rust code to ensure it has the necessary FFI exports. This adds common imports and ensures extern \"C\" functions are properly exposed.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.drop!","page":"API Reference","title":"RustCall.drop!","text":"drop!(x::Union{RustBox, RustRc, RustArc, RustVec})\n\nMark an ownership type as dropped. The actual memory deallocation should be handled by Rust-side drop functions.\n\nNote: This sets the dropped flag to prevent double-drop but does not actually free memory. Call the appropriate Rust drop function for that.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.is_dropped","page":"API Reference","title":"RustCall.is_dropped","text":"is_dropped(x::Union{RustBox, RustRc, RustArc, RustVec}) -> Bool\n\nCheck if an ownership type has been dropped.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.is_valid","page":"API Reference","title":"RustCall.is_valid","text":"is_valid(box::RustBox) -> Bool\n\nCheck if a RustBox is still valid (not dropped and not null).\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.clone","page":"API Reference","title":"RustCall.clone","text":"clone(rc::RustRc{T}) -> RustRc{T} where T\n\nClone a RustRc, incrementing the reference count.\n\n\n\n\n\nclone(arc::RustArc{T}) -> RustArc{T} where T\n\nClone a RustArc, incrementing the atomic reference count.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.is_rust_helpers_available","page":"API Reference","title":"RustCall.is_rust_helpers_available","text":"is_rust_helpers_available() -> Bool\n\nCheck if the Rust helpers library is available.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.get_rust_helpers_lib","page":"API Reference","title":"RustCall.get_rust_helpers_lib","text":"get_rust_helpers_lib() -> Union{Ptr{Cvoid}, Nothing}\n\nGet or load the Rust helpers library. This library provides FFI functions for Box, Rc, Arc operations. Returns nothing if the library is not available.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.get_rust_helpers_lib_path","page":"API Reference","title":"RustCall.get_rust_helpers_lib_path","text":"get_rust_helpers_lib_path() -> Union{String, Nothing}\n\nGet the path to the Rust helpers library if it exists (either built or in a standard location). Returns nothing if the library is not found.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.create_rust_vec","page":"API Reference","title":"RustCall.create_rust_vec","text":"create_rust_vec(v::Vector{T}) -> RustVec{T}\n\nCreate a RustVec from a Julia Vector by copying data to Rust-managed memory.\n\nArguments\n\nv::Vector{T}: A Julia Vector to convert. Supported types: Int32, Int64, Float32, Float64\n\nReturns\n\nRustVec{T}: A new RustVec containing a copy of the data\n\nThrows\n\nErrorException: If the Rust helpers library is not loaded\nErrorException: If the element type is not supported\n\nExample\n\njulia_vec = Int32[1, 2, 3, 4, 5]\nrust_vec = create_rust_vec(julia_vec)\n@assert length(rust_vec) == 5\ndrop!(rust_vec)  # Clean up when done\n\nNote\n\nThe data is copied to Rust-managed memory. The original Julia array is not modified. Remember to call drop!(rust_vec) when done to free Rust memory.\n\nSee also: to_julia_vector, drop!\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.rust_vec_get","page":"API Reference","title":"RustCall.rust_vec_get","text":"rust_vec_get(vec::RustVec{T}, index::Integer) -> T\n\nGet an element from RustVec using Rust FFI with 0-based indexing.\n\nArguments\n\nvec::RustVec{T}: The RustVec to access\nindex::Integer: 0-based index of the element to retrieve\n\nReturns\n\nT: The element at the specified index\n\nThrows\n\nErrorException: If the vec has been dropped\nBoundsError: If index is out of bounds\nErrorException: If the Rust helpers library is not loaded\n\nExample\n\nrust_vec = create_rust_vec(Int32[10, 20, 30])\nvalue = rust_vec_get(rust_vec, 0)  # Returns 10\nvalue = rust_vec_get(rust_vec, 2)  # Returns 30\ndrop!(rust_vec)\n\nNote\n\nThis function uses 0-based indexing to match Rust's convention. For 1-based indexing, use vec[i] syntax instead.\n\nSee also: rust_vec_set!, getindex\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.rust_vec_set!","page":"API Reference","title":"RustCall.rust_vec_set!","text":"rust_vec_set!(vec::RustVec{T}, index::Integer, value::T) -> Bool\n\nSet an element in RustVec using Rust FFI (0-indexed). Returns true if successful.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.copy_to_julia!","page":"API Reference","title":"RustCall.copy_to_julia!","text":"copy_to_julia!(vec::RustVec{T}, dest::Vector{T}) -> Int\n\nCopy RustVec contents to a pre-allocated Julia Vector using efficient Rust FFI.\n\nThis is the most efficient way to transfer data from Rust to Julia when you already have a destination buffer allocated.\n\nArguments\n\nvec::RustVec{T}: Source RustVec to copy from\ndest::Vector{T}: Pre-allocated destination Julia Vector\n\nReturns\n\nInt: Number of elements actually copied (min of source and dest lengths)\n\nThrows\n\nErrorException: If the vec has been dropped\nErrorException: If the Rust helpers library is not loaded\n\nExample\n\nrust_vec = create_rust_vec(Int32[1, 2, 3, 4, 5])\n\n# Copy all elements\ndest = Vector{Int32}(undef, 5)\nn = copy_to_julia!(rust_vec, dest)\n@assert n == 5 && dest == Int32[1, 2, 3, 4, 5]\n\n# Copy to smaller buffer (partial copy)\nsmall_dest = Vector{Int32}(undef, 3)\nn = copy_to_julia!(rust_vec, small_dest)\n@assert n == 3 && small_dest == Int32[1, 2, 3]\n\ndrop!(rust_vec)\n\nPerformance\n\nThis function uses a single FFI call to copy all data, making it much more efficient than element-by-element access for large vectors.\n\nSee also: to_julia_vector, create_rust_vec\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.to_julia_vector","page":"API Reference","title":"RustCall.to_julia_vector","text":"to_julia_vector(vec::RustVec{T}) -> Vector{T}\n\nConvert a RustVec to a new Julia Vector using efficient Rust FFI copy.\n\nThis is the recommended way to convert RustVec data to Julia when you don't have a pre-allocated buffer.\n\nArguments\n\nvec::RustVec{T}: The RustVec to convert\n\nReturns\n\nVector{T}: A new Julia Vector containing a copy of the data\n\nThrows\n\nErrorException: If the vec has been dropped\n\nExample\n\nrust_vec = create_rust_vec(Int32[1, 2, 3, 4, 5])\njulia_vec = to_julia_vector(rust_vec)\n@assert julia_vec == Int32[1, 2, 3, 4, 5]\ndrop!(rust_vec)\n\nNote\n\nThis function allocates a new Julia Vector. If you already have a buffer, use copy_to_julia! instead for better performance.\n\nSee also: copy_to_julia!, create_rust_vec\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.clear_cache","page":"API Reference","title":"RustCall.clear_cache","text":"clear_cache()\n\nClear all cached libraries and metadata. On Windows, some files may be locked and cannot be deleted immediately.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.get_cache_size","page":"API Reference","title":"RustCall.get_cache_size","text":"get_cache_size() -> Int64\n\nGet the total size of the cache directory in bytes.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.list_cached_libraries","page":"API Reference","title":"RustCall.list_cached_libraries","text":"list_cached_libraries() -> Vector{String}\n\nList all cache keys for cached libraries.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.cleanup_old_cache","page":"API Reference","title":"RustCall.cleanup_old_cache","text":"cleanup_old_cache(max_age_days::Int = 30)\n\nRemove cache entries older than maxagedays.\n\nArguments\n\nmax_age_days::Int: Maximum age in days (default: 30)\n\nReturns\n\nInt: Number of removed cache entries\n\nExample\n\n# Remove cache entries older than 7 days\ncount = cleanup_old_cache(7)\nprintln(\"Removed $count old cache entries\")\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.OptimizationConfig","page":"API Reference","title":"RustCall.OptimizationConfig","text":"OptimizationConfig\n\nConfiguration for LLVM optimization passes.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.optimize_module!","page":"API Reference","title":"RustCall.optimize_module!","text":"optimize_module!(mod::LLVM.Module; config=get_default_opt_config())\n\nApply optimization passes to an LLVM module. Returns the optimized module (modified in place).\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.optimize_for_speed!","page":"API Reference","title":"RustCall.optimize_for_speed!","text":"optimize_for_speed!(mod::LLVM.Module)\n\nApply optimizations focused on execution speed.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.optimize_for_size!","page":"API Reference","title":"RustCall.optimize_for_size!","text":"optimize_for_size!(mod::LLVM.Module)\n\nApply optimizations focused on code size.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.RustFunctionInfo","page":"API Reference","title":"RustCall.RustFunctionInfo","text":"RustFunctionInfo\n\nInformation about a compiled Rust function for llvmcall.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.compile_and_register_rust_function","page":"API Reference","title":"RustCall.compile_and_register_rust_function","text":"compile_and_register_rust_function(code::String, func_name::String)\n\nCompile Rust code and register the function for llvmcall usage.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.julia_type_to_llvm_ir_string","page":"API Reference","title":"RustCall.julia_type_to_llvm_ir_string","text":"julia_type_to_llvm_ir_string(t::Type) -> String\n\nConvert a Julia type to its LLVM IR string representation. Supports basic types, pointers, tuples, and structs.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.register_generic_function","page":"API Reference","title":"RustCall.register_generic_function","text":"register_generic_function(func_name, code, type_params, constraints, context)\n\nRegister a generic Rust function for later monomorphization.\n\nArguments\n\nfunc_name: Name of the function\ncode: Rust function code (with generics)\ntype_params: List of type parameter symbols\nconstraints: Trait bounds for type parameters (TypeConstraints or legacy Dict{Symbol, String})\ncontext: Additional code (e.g. struct definitions) needed for compilation\n\nExamples\n\n# With TypeConstraints (recommended)\nconstraints = Dict(:T => TypeConstraints([TraitBound(\"Copy\", []), TraitBound(\"Clone\", [])]))\nregister_generic_function(\"identity\", code, [:T], constraints)\n\n# Legacy format (still supported)\nregister_generic_function(\"identity\", code, [:T], Dict(:T => \"Copy + Clone\"))\n\n# No constraints\nregister_generic_function(\"identity\", code, [:T])\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.call_generic_function","page":"API Reference","title":"RustCall.call_generic_function","text":"call_generic_function(func_name::String, args...)\n\nCall a generic Rust function, automatically monomorphizing if needed.\n\nArguments\n\nfunc_name: Name of the generic function\nargs...: Arguments (types will be inferred from these)\n\nExample\n\n# Assuming identity<T> is registered\nresult = call_generic_function(\"identity\", Int32(42))\n# Automatically monomorphizes to identity<Int32> and calls it\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.is_generic_function","page":"API Reference","title":"RustCall.is_generic_function","text":"is_generic_function(func_name::String) -> Bool\n\nCheck if a function is registered as a generic function.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.monomorphize_function","page":"API Reference","title":"RustCall.monomorphize_function","text":"monomorphize_function(func_name::String, type_params::Dict{Symbol, Type}) -> FunctionInfo\n\nMonomorphize a generic function with specific type parameters.\n\nArguments\n\nfunc_name: Name of the generic function\ntype_params: Mapping from type parameter symbols to concrete types\n\nReturns\n\nFunctionInfo for the monomorphized function\n\nExample\n\n# Register generic function\nregister_generic_function(\"identity\", \"pub fn identity<T>(x: T) -> T { x }\", [:T])\n\n# Monomorphize with Int32\ninfo = monomorphize_function(\"identity\", Dict{Symbol, Type}(:T => Int32))\n# Returns FunctionInfo for identity_i32\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.specialize_generic_code","page":"API Reference","title":"RustCall.specialize_generic_code","text":"specialize_generic_code(code::String, type_params::Dict{Symbol, Type}) -> String\n\nSpecialize a generic Rust function by replacing type parameters with concrete types.\n\nArguments\n\ncode: The generic Rust function code\ntype_params: Mapping from type parameter symbols to concrete Julia types\n\nExample\n\ncode = \"pub fn identity<T>(x: T) -> T { x }\"\ntype_params = Dict(:T => Int32)\nspecialize_generic_code(code, type_params)\n# Returns: \"pub fn identity(x: i32) -> i32 { x }\"\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.infer_type_parameters","page":"API Reference","title":"RustCall.infer_type_parameters","text":"infer_type_parameters(func_name::String, arg_types::Vector{Type}) -> Dict{Symbol, Type}\n\nInfer type parameters for a generic function from argument types.\n\nArguments\n\nfunc_name: Name of the generic function\narg_types: Types of the arguments passed to the function\n\nReturns\n\nDictionary mapping type parameter symbols to concrete types\n\nExample\n\n# For function: fn identity<T>(x: T) -> T\n# Called with: identity(Int32(42))\n# Returns: Dict(:T => Int32)\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.TraitBound","page":"API Reference","title":"RustCall.TraitBound","text":"TraitBound\n\nRepresents a single trait bound with optional type parameters.\n\nFields\n\ntrait_name::String: Name of the trait (e.g., \"Copy\", \"Add\")\ntype_params::Vector{String}: Type parameters for the trait (e.g., [\"Output = T\"] for Add<Output = T>)\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.TypeConstraints","page":"API Reference","title":"RustCall.TypeConstraints","text":"TypeConstraints\n\nRepresents all trait bounds for a type parameter.\n\nFields\n\nbounds::Vector{TraitBound}: List of trait bounds (e.g., [Copy, Clone, Add<Output = T>])\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.GenericFunctionInfo","page":"API Reference","title":"RustCall.GenericFunctionInfo","text":"GenericFunctionInfo\n\nInformation about a generic Rust function that needs monomorphization.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.parse_trait_bounds","page":"API Reference","title":"RustCall.parse_trait_bounds","text":"parse_trait_bounds(bounds_str::AbstractString) -> TypeConstraints\n\nParse a trait bounds string like \"Copy + Clone + Add<Output = T>\".\n\nExamples\n\nparse_trait_bounds(\"Copy + Clone\")\n# => TypeConstraints([TraitBound(\"Copy\", []), TraitBound(\"Clone\", [])])\n\nparse_trait_bounds(\"Copy + Add<Output = T>\")\n# => TypeConstraints([TraitBound(\"Copy\", []), TraitBound(\"Add\", [\"Output = T\"])])\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.parse_single_trait","page":"API Reference","title":"RustCall.parse_single_trait","text":"parse_single_trait(trait_str::String) -> TraitBound\n\nParse a single trait bound string like \"Copy\", \"Add<Output = T>\", or \"Into<String>\".\n\nExamples\n\nparse_single_trait(\"Copy\")\n# => TraitBound(\"Copy\", [])\n\nparse_single_trait(\"Add<Output = T>\")\n# => TraitBound(\"Add\", [\"Output = T\"])\n\nparse_single_trait(\"Into<String>\")\n# => TraitBound(\"Into\", [\"String\"])\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.parse_where_clause","page":"API Reference","title":"RustCall.parse_where_clause","text":"parse_where_clause(code::AbstractString) -> Dict{Symbol, TypeConstraints}\n\nParse a where clause from Rust code.\n\nSupported formats\n\nwhere T: Copy + Clone, U: Debug\nwhere T: Copy + Clone\n\nReturns\n\nDictionary mapping type parameters to their constraints\n\nExamples\n\ncode = \"fn foo<T, U>(x: T) -> U where T: Copy + Clone, U: Debug { ... }\"\nparse_where_clause(code)\n# => Dict(:T => TypeConstraints([Copy, Clone]), :U => TypeConstraints([Debug]))\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.parse_inline_constraints","page":"API Reference","title":"RustCall.parse_inline_constraints","text":"parse_inline_constraints(type_params_str::AbstractString) -> Tuple{Vector{Symbol}, Dict{Symbol, TypeConstraints}}\n\nParse inline type parameters with constraints like \"T: Copy + Clone, U: Debug\".\n\nReturns\n\nTuple of (type_params, constraints)\n\nExamples\n\nparse_inline_constraints(\"T: Copy + Clone, U: Debug\")\n# => ([:T, :U], Dict(:T => TypeConstraints([Copy, Clone]), :U => TypeConstraints([Debug])))\n\nparse_inline_constraints(\"T, U\")\n# => ([:T, :U], Dict())\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.parse_generic_function","page":"API Reference","title":"RustCall.parse_generic_function","text":"parse_generic_function(code::AbstractString, func_name::AbstractString) -> Union{GenericFunctionInfo, Nothing}\n\nParse a Rust function to detect if it's generic and extract type parameters with trait bounds.\n\nSupported formats\n\nInline bounds: fn foo<T: Copy + Clone, U: Debug>(x: T) -> U\nWhere clause: fn foo<T, U>(x: T) -> U where T: Copy + Clone, U: Debug\nMixed: fn foo<T: Copy, U>(x: T) -> U where U: Debug\n\nExample\n\npub fn identity<T: Copy + Clone>(x: T) -> T { x }\n\nThis would be parsed as:\n\nname: \"identity\"\ntype_params: [:T]\nconstraints: Dict(:T => TypeConstraints([Copy, Clone]))\n\npub fn transform<T, U>(x: T) -> U where T: Copy, U: From<T> { ... }\n\nThis would be parsed as:\n\nname: \"transform\"\ntype_params: [:T, :U]\nconstraints: Dict(:T => TypeConstraints([Copy]), :U => TypeConstraints([From<T>]))\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.constraints_to_rust_string","page":"API Reference","title":"RustCall.constraints_to_rust_string","text":"constraints_to_rust_string(constraints::Dict{Symbol, TypeConstraints}) -> String\n\nConvert constraints back to Rust syntax for code generation.\n\nExample\n\nconstraints = Dict(:T => TypeConstraints([TraitBound(\"Copy\", []), TraitBound(\"Clone\", [])]))\nconstraints_to_rust_string(constraints)\n# => \"T: Copy + Clone\"\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.merge_constraints","page":"API Reference","title":"RustCall.merge_constraints","text":"merge_constraints(c1::Dict{Symbol, TypeConstraints}, c2::Dict{Symbol, TypeConstraints}) -> Dict{Symbol, TypeConstraints}\n\nMerge two constraint dictionaries. If a type parameter exists in both, merge their bounds.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.DependencySpec","page":"API Reference","title":"RustCall.DependencySpec","text":"DependencySpec\n\nRepresents a single Rust crate dependency specification.\n\nFields\n\nname::String: Crate name\nversion::Union{String, Nothing}: Version specification (e.g., \"0.15\", \"1.0\")\nfeatures::Vector{String}: List of crate features to enable\ngit::Union{String, Nothing}: Git repository URL (for git dependencies)\npath::Union{String, Nothing}: Local path (for path dependencies)\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.parse_dependencies_from_code","page":"API Reference","title":"RustCall.parse_dependencies_from_code","text":"parse_dependencies_from_code(code::String) -> Vector{DependencySpec}\n\nParse dependencies from Rust code that contains rustscript-style dependency specifications.\n\nSupports two formats:\n\nDocument comment format:\n//! ```cargo\n//! [dependencies]\n//! ndarray = \"0.15\"\n//! serde = { version = \"1.0\", features = [\"derive\"] }\n//! ```\nSingle-line comment format:\n// cargo-deps: ndarray=\"0.15\", serde=\"1.0\"\n\nArguments\n\ncode::String: Rust source code potentially containing dependency specifications\n\nReturns\n\nVector{DependencySpec}: List of parsed dependencies (empty if none found)\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.has_dependencies","page":"API Reference","title":"RustCall.has_dependencies","text":"has_dependencies(code::String) -> Bool\n\nCheck if code contains any dependency specifications.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.CargoProject","page":"API Reference","title":"RustCall.CargoProject","text":"CargoProject\n\nRepresents a temporary Cargo project for building Rust code with dependencies.\n\nFields\n\nname::String: Project/crate name\nversion::String: Project version (default \"0.1.0\")\ndependencies::Vector{DependencySpec}: List of dependencies\nedition::String: Rust edition (default \"2021\")\npath::String: Path to the project directory\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.create_cargo_project","page":"API Reference","title":"RustCall.create_cargo_project","text":"create_cargo_project(name::String, dependencies::Vector{DependencySpec}; kwargs...) -> CargoProject\n\nCreate a temporary Cargo project with the specified dependencies.\n\nArguments\n\nname::String: Project name (used as crate name)\ndependencies::Vector{DependencySpec}: List of dependencies\n\nKeyword Arguments\n\nedition::String: Rust edition (default: \"2021\")\npath::Union{String, Nothing}: Project path (default: auto-generated temp directory)\n\nReturns\n\nCargoProject: The created project\n\nExample\n\ndeps = [DependencySpec(\"ndarray\", version=\"0.15\")]\nproject = create_cargo_project(\"my_project\", deps)\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.build_cargo_project","page":"API Reference","title":"RustCall.build_cargo_project","text":"build_cargo_project(project::CargoProject; release::Bool = true) -> String\n\nBuild a Cargo project and return the path to the compiled library.\n\nArguments\n\nproject::CargoProject: The Cargo project to build\n\nKeyword Arguments\n\nrelease::Bool: Build in release mode (default: true for better performance)\n\nReturns\n\nString: Path to the compiled shared library\n\nThrows\n\nCargoBuildError if the build fails\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.clear_cargo_cache","page":"API Reference","title":"RustCall.clear_cargo_cache","text":"clear_cargo_cache()\n\nClear all cached Cargo-built libraries.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.get_cargo_cache_size","page":"API Reference","title":"RustCall.get_cargo_cache_size","text":"get_cargo_cache_size() -> Int64\n\nGet the total size of the Cargo cache in bytes.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.CrateInfo","page":"API Reference","title":"RustCall.CrateInfo","text":"CrateInfo\n\nInformation about a Rust crate for binding generation.\n\nFields\n\nname::String: Crate name from Cargo.toml\npath::String: Path to the crate root directory\nversion::String: Crate version\ndependencies::Vector{DependencySpec}: Crate dependencies\njulia_functions::Vector{RustFunctionSignature}: Functions marked with #[julia]\njulia_structs::Vector{RustStructInfo}: Structs marked with #[julia]\nsource_files::Vector{String}: Paths to .rs source files\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.CrateBindingOptions","page":"API Reference","title":"RustCall.CrateBindingOptions","text":"CrateBindingOptions\n\nOptions for binding generation.\n\nFields\n\noutput_module_name::Union{String, Nothing}: Name for the generated module (default: crate name)\noutput_path::Union{String, Nothing}: Path to write generated Julia code\nuse_wrapper_crate::Bool: Whether to create a wrapper crate for building\nbuild_release::Bool: Build in release mode\ncache_enabled::Bool: Enable caching of compiled libraries\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.scan_crate","page":"API Reference","title":"RustCall.scan_crate","text":"scan_crate(crate_path::String) -> CrateInfo\n\nScan a Rust crate and extract information about #[julia] marked items.\n\nArguments\n\ncrate_path::String: Path to the crate root directory (containing Cargo.toml)\n\nReturns\n\nCrateInfo: Information about the crate including functions and structs\n\nExample\n\ninfo = scan_crate(\"/path/to/my_crate\")\nprintln(\"Found $(length(info.julia_functions)) Julia functions\")\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.generate_bindings","page":"API Reference","title":"RustCall.generate_bindings","text":"generate_bindings(crate_path::String; kwargs...) -> Expr\n\nGenerate Julia bindings for an external Rust crate.\n\nThis is the main entry point for the Maturin-like feature. It scans the crate, creates a wrapper crate if needed, builds it, and generates Julia bindings.\n\nArguments\n\ncrate_path::String: Path to the Rust crate root directory\n\nKeyword Arguments\n\noutput_module_name::Union{String, Nothing}: Name for the generated module\nbuild_release::Bool: Build in release mode (default: true)\ncache_enabled::Bool: Enable caching (default: true)\n\nReturns\n\nExpr: A module expression containing all bindings\n\nExample\n\nbindings = generate_bindings(\"/path/to/my_crate\")\neval(bindings)\n# Now MyCrate module is available\nMyCrate.add(1, 2)\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.write_bindings_to_file","page":"API Reference","title":"RustCall.write_bindings_to_file","text":"write_bindings_to_file(crate_path::String, output_path::String; kwargs...) -> String\n\nGenerate Julia bindings for a Rust crate and write them to a file.\n\nThis function is designed for package development workflow where bindings should be generated once and then included in the package for precompilation.\n\nArguments\n\ncrate_path::String: Path to the Rust crate root directory\noutput_path::String: Path to write the generated Julia code\n\nKeyword Arguments\n\noutput_module_name::Union{String, Nothing}: Name for the generated module\nbuild_release::Bool: Build in release mode (default: true)\nrelative_lib_path::Union{String, Nothing}: Path to library relative to the generated file If not provided, uses the absolute path to the compiled library.\n\nReturns\n\nString: Path to the generated Julia file\n\nWorkflow for Package Development\n\nDuring development, call write_bindings_to_file to generate bindings:\nusing RustCall\nwrite_bindings_to_file(\n    \"deps/my_rust_crate\",\n    \"src/generated/MyRustBindings.jl\",\n    relative_lib_path = \"../deps/lib\"\n)\nInclude the generated file in your package:\n# In src/MyPackage.jl\ninclude(\"generated/MyRustBindings.jl\")\nThe generated module will be precompiled with your package.\n\nExample\n\nusing RustCall\n\n# Generate bindings to a file\nwrite_bindings_to_file(\n    \"/path/to/my_crate\",\n    \"src/MyCrateBindings.jl\",\n    output_module_name = \"MyCrate\"\n)\n\n# The file can now be included in your package\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.@rust_crate","page":"API Reference","title":"RustCall.@rust_crate","text":"@rust_crate(path)\n@rust_crate(path, options...)\n\nGenerate and load bindings for an external Rust crate.\n\nArguments\n\npath: Path to the Rust crate (string literal)\n\nOptions\n\nname=\"ModuleName\": Override the generated module name\nrelease=true/false: Build in release mode (default: true)\ncache=true/false: Enable caching (default: true)\n\nExample\n\n# Basic usage\n@rust_crate \"/path/to/my_crate\"\n\n# With options\n@rust_crate \"/path/to/my_crate\" name=\"MyBindings\" release=true\n\n# After loading, use the module\nMyCrate.add(1, 2)\n\n\n\n\n\n","category":"macro"},{"location":"api/#RustCall.HotReloadState","page":"API Reference","title":"RustCall.HotReloadState","text":"HotReloadState\n\nState for a hot-reloadable Rust crate.\n\nFields\n\ncrate_path::String: Path to the Rust crate\nlib_path::String: Path to the compiled library\nlib_name::String: Name used to register the library\nsource_files::Vector{String}: Tracked .rs source files\nlast_modified::Dict{String, Float64}: Last modification times\nwatch_task::Union{Task, Nothing}: File watching task\nenabled::Bool: Whether hot reload is enabled\nrebuild_callback::Union{Function, Nothing}: Callback after rebuild\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.enable_hot_reload","page":"API Reference","title":"RustCall.enable_hot_reload","text":"enable_hot_reload(lib_name::String, crate_path::String; kwargs...) -> HotReloadState\n\nEnable hot reload for a Rust crate.\n\nArguments\n\nlib_name::String: Name of the loaded library\ncrate_path::String: Path to the Rust crate root\n\nKeyword Arguments\n\ninterval::Float64: Check interval in seconds (default: 1.0)\ncallback::Union{Function, Nothing}: Callback after rebuild (receives lib_name, success, error)\n\nReturns\n\nHotReloadState: The hot reload state for the crate\n\nExample\n\n# Load a Rust crate\nrust\"\"\"\n// cargo-deps: my_crate = { path = \"./my_rust_crate\" }\nuse my_crate::*;\n\"\"\"\n\n# Enable hot reload\nstate = enable_hot_reload(\"my_crate\", \"./my_rust_crate\")\n\n# Now modify Rust code and it will automatically reload!\n\n# When done, disable hot reload\ndisable_hot_reload(\"my_crate\")\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.disable_hot_reload","page":"API Reference","title":"RustCall.disable_hot_reload","text":"disable_hot_reload(lib_name::String)\n\nDisable hot reload for a Rust crate.\n\nArguments\n\nlib_name::String: Name of the library to disable hot reload for\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.disable_all_hot_reload","page":"API Reference","title":"RustCall.disable_all_hot_reload","text":"disable_all_hot_reload()\n\nDisable hot reload for all registered crates.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.is_hot_reload_enabled","page":"API Reference","title":"RustCall.is_hot_reload_enabled","text":"is_hot_reload_enabled(lib_name::String) -> Bool\n\nCheck if hot reload is enabled for a library.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.list_hot_reload_crates","page":"API Reference","title":"RustCall.list_hot_reload_crates","text":"list_hot_reload_crates() -> Vector{String}\n\nList all crates with hot reload enabled.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.trigger_reload","page":"API Reference","title":"RustCall.trigger_reload","text":"trigger_reload(lib_name::String) -> Bool\n\nManually trigger a reload for a library.\n\nReturns true if successful, false otherwise.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.set_hot_reload_global","page":"API Reference","title":"RustCall.set_hot_reload_global","text":"set_hot_reload_global(enabled::Bool)\n\nEnable or disable hot reload functionality globally.\n\nWhen disabled, all watch tasks will stop.\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.enable_hot_reload_for_crate","page":"API Reference","title":"RustCall.enable_hot_reload_for_crate","text":"enable_hot_reload_for_crate(crate_path::String; kwargs...) -> HotReloadState\n\nEnable hot reload for a crate loaded via @rust_crate.\n\nThis is a convenience function that determines the library name from the crate.\n\nArguments\n\ncrate_path::String: Path to the Rust crate\n\nKeyword Arguments\n\nSame as enable_hot_reload\n\nExample\n\n@rust_crate \"/path/to/my_crate\"\n\n# Enable hot reload\nenable_hot_reload_for_crate(\"/path/to/my_crate\")\n\n\n\n\n\n","category":"function"},{"location":"api/#RustCall.GENERIC_FUNCTION_REGISTRY","page":"API Reference","title":"RustCall.GENERIC_FUNCTION_REGISTRY","text":"Registry for generic functions. Maps function name to GenericFunctionInfo.\n\n\n\n\n\n","category":"constant"},{"location":"api/#RustCall.MONOMORPHIZED_FUNCTIONS","page":"API Reference","title":"RustCall.MONOMORPHIZED_FUNCTIONS","text":"Registry for monomorphized function instances. Maps (functionname, typeparams_tuple) to FunctionInfo.\n\n\n\n\n\n","category":"constant"},{"location":"api/#RustCall.RustCall","page":"API Reference","title":"RustCall.RustCall","text":"RustCall.jl\n\nA Foreign Function Interface (FFI) package for calling Rust code from Julia using LLVM IR integration.\n\nExported Macros\n\n@rust: Call a registered Rust function\n@rust_str: Compile and register Rust code (rust\"\" string literal)\n\nExample\n\nusing RustCall\n\n# Define Rust code\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\"\"\"\n\n# Call the function\nresult = @rust add(10i32, 20i32)\n\n\n\n\n\n","category":"module"},{"location":"api/#Base.Vector-Union{Tuple{RustVec{T}}, Tuple{T}} where T","page":"API Reference","title":"Base.Vector","text":"Vector(vec::RustVec{T}) -> Vector{T}\n\nConvert a RustVec to a Julia Vector by copying the data.\n\nExample\n\nvec = RustVec{Int32}(ptr, 10, 20)\njulia_vec = Vector(vec)  # Creates a new Julia array\n\nNote\n\nThis creates a copy of the data. Modifications to the returned Vector will not affect the original RustVec.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.COptionType","page":"API Reference","title":"RustCall.COptionType","text":"COptionType{T}\n\nC-compatible struct for Option<T> returned by FFI functions. Generated by #[julia] proc-macro as COption_<function_name>.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.CResultType","page":"API Reference","title":"RustCall.CResultType","text":"CResultType{T, E}\n\nC-compatible struct for Result<T, E> returned by FFI functions. Generated by #[julia] proc-macro as CResult_<function_name>.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.CacheMetadata","page":"API Reference","title":"RustCall.CacheMetadata","text":"CacheMetadata\n\nMetadata stored with cached libraries.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.FunctionInfo","page":"API Reference","title":"RustCall.FunctionInfo","text":"FunctionInfo\n\nInformation about a registered Rust function.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.LLVMCodeGenerator","page":"API Reference","title":"RustCall.LLVMCodeGenerator","text":"LLVMCodeGenerator\n\nConfiguration for LLVM-based code generation.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.LLVMCodeGenerator-Tuple{}","page":"API Reference","title":"RustCall.LLVMCodeGenerator","text":"LLVMCodeGenerator(; kwargs...)\n\nCreate an LLVMCodeGenerator with specified settings.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.OptionTypeInfo","page":"API Reference","title":"RustCall.OptionTypeInfo","text":"OptionTypeInfo\n\nParsed information about an Option<T> return type.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.ResultTypeInfo","page":"API Reference","title":"RustCall.ResultTypeInfo","text":"ResultTypeInfo\n\nParsed information about a Result<T, E> return type.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.RustFunctionSignature","page":"API Reference","title":"RustCall.RustFunctionSignature","text":"RustFunctionSignature\n\nRepresents a parsed Rust function signature marked with #[julia].\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.RustMethod","page":"API Reference","title":"RustCall.RustMethod","text":"RustMethod\n\nRepresents a Rust method found in an impl block.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.RustModule","page":"API Reference","title":"RustCall.RustModule","text":"RustModule\n\nA wrapper around an LLVM module containing compiled Rust code.\n\n\n\n\n\n","category":"type"},{"location":"api/#RustCall.RustStructInfo","page":"API Reference","title":"RustCall.RustStructInfo","text":"RustStructInfo\n\nRepresents a Rust struct and its associated implementation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.collect-Union{Tuple{RustVec{T}}, Tuple{T}} where T","page":"API Reference","title":"Base.collect","text":"collect(vec::RustVec{T}) -> Vector{T}\n\nAlias for Vector(vec::RustVec{T}). Convert a RustVec to a Julia Vector.\n\nExample\n\nvec = RustVec{Int32}(ptr, 10, 20)\njulia_vec = collect(vec)  # Creates a new Julia array\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Union{Tuple{T}, Tuple{RustSlice{T}, Int64}} where T","page":"API Reference","title":"Base.getindex","text":"getindex(slice::RustSlice{T}, i::Int) -> T\n\nGet the element at index i in a RustSlice.\n\nArguments\n\nslice: The RustSlice to index into\ni: The index (1-based, like Julia arrays)\n\nExample\n\nslice = RustSlice{Int32}(ptr, 10)\nvalue = slice[1]  # Get first element\n\nNote\n\nThis performs bounds checking. The index must be between 1 and length(slice).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Union{Tuple{T}, Tuple{RustVec{T}, Int64}} where T","page":"API Reference","title":"Base.getindex","text":"getindex(vec::RustVec{T}, i::Int) -> T\n\nGet the element at index i in a RustVec.\n\nArguments\n\nvec: The RustVec to index into\ni: The index (1-based, like Julia arrays)\n\nExample\n\nvec = RustVec{Int32}(ptr, 10, 20)\nvalue = vec[1]  # Get first element\n\nNote\n\nThis performs bounds checking. The index must be between 1 and length(vec).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.iterate-Union{Tuple{RustSlice{T}}, Tuple{T}, Tuple{RustSlice{T}, Int64}} where T","page":"API Reference","title":"Base.iterate","text":"iterate(slice::RustSlice{T}, state=1) -> Union{Tuple{T, Int}, Nothing}\n\nIterate over elements in a RustSlice.\n\nExample\n\nslice = RustSlice{Int32}(ptr, 10)\nfor x in slice\n    println(x)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.iterate-Union{Tuple{RustVec{T}}, Tuple{T}, Tuple{RustVec{T}, Int64}} where T","page":"API Reference","title":"Base.iterate","text":"iterate(vec::RustVec{T}, state=1) -> Union{Tuple{T, Int}, Nothing}\n\nIterate over elements in a RustVec.\n\nExample\n\nvec = RustVec{Int32}(ptr, 10, 20)\nfor x in vec\n    println(x)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.push!-Union{Tuple{T}, Tuple{RustVec{T}, T}} where T","page":"API Reference","title":"Base.push!","text":"push!(vec::RustVec{T}, value::T) -> RustVec{T}\n\nPush a value to RustVec. Note: This modifies the vec in place by updating its internal pointer, length, and capacity.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Union{Tuple{T}, Tuple{RustVec{T}, Any, Int64}} where T","page":"API Reference","title":"Base.setindex!","text":"setindex!(vec::RustVec{T}, value, i::Int) -> value\n\nSet the element at index i in a RustVec to value.\n\nArguments\n\nvec: The RustVec to modify\nvalue: The value to set (must be convertible to type T)\ni: The index (1-based, like Julia arrays)\n\nExample\n\nvec = RustVec{Int32}(ptr, 10, 20)\nvec[1] = 42  # Set first element to 42\n\nNote\n\nThis performs bounds checking. The index must be between 1 and length(vec).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.showerror-Tuple{IO, CargoBuildError}","page":"API Reference","title":"Base.showerror","text":"Base.showerror(io::IO, e::CargoBuildError)\n\nDisplay a CargoBuildError in a user-friendly format.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.showerror-Tuple{IO, CompilationError}","page":"API Reference","title":"Base.showerror","text":"Base.showerror(io::IO, e::CompilationError)\n\nDisplay a CompilationError in a user-friendly format with formatted rustc output. Enhanced with more context and debugging information.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.showerror-Tuple{IO, DependencyResolutionError}","page":"API Reference","title":"Base.showerror","text":"Base.showerror(io::IO, e::DependencyResolutionError)\n\nDisplay a DependencyResolutionError in a user-friendly format.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.showerror-Tuple{IO, RuntimeError}","page":"API Reference","title":"Base.showerror","text":"Base.showerror(io::IO, e::RuntimeError)\n\nDisplay a RuntimeError in a user-friendly format with enhanced stack trace. Enhanced with argument information and debugging context.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.showerror-Tuple{IO, RustError}","page":"API Reference","title":"Base.showerror","text":"Base.showerror(io::IO, e::RustError)\n\nDisplay a RustError in a user-friendly format.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._call_irust_function-Tuple{String, String, Type, Vararg{Any}}","page":"API Reference","title":"RustCall._call_irust_function","text":"_call_irust_function(lib_name::String, func_name::String, ret_type::Type, args...)\n_call_irust_function(lib_name::String, func_name::String, args...)\n\nCall an irust function with Julia arguments.\n\nError Handling\n\nProvides improved error messages for function call failures.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._compile_and_call_irust-Tuple{String, Vararg{Any}}","page":"API Reference","title":"RustCall._compile_and_call_irust","text":"_compile_and_call_irust(code::String, args...)\n\nInternal function to compile and execute Rust code at function scope.\n\nError Handling\n\nThis function provides improved error messages for:\n\nType mismatches\nCompilation failures\nMissing variables\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._compile_and_load_rust-Tuple{String, String, Int64}","page":"API Reference","title":"RustCall._compile_and_load_rust","text":"_compile_and_load_rust(code::String, source_file::String, source_line::Int)\n\nInternal function to compile Rust code and load the resulting shared library. Uses caching to avoid recompilation when possible.\n\nPhase 3: Automatically detects dependencies in the code and uses Cargo for building when external crates are required.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._compile_and_load_rust_with_cargo-Tuple{String, String, Int64}","page":"API Reference","title":"RustCall._compile_and_load_rust_with_cargo","text":"_compile_and_load_rust_with_cargo(code::String, source_file::String, source_line::Int)\n\nInternal function to compile Rust code that has external dependencies using Cargo. Phase 3: Supports rustscript-style dependency specifications.\n\nDependency Specification Formats\n\nDocument comment format:\n//! ```cargo\n//! [dependencies]\n//! ndarray = \"0.15\"\n//! ```\nSingle-line comment format:\n// cargo-deps: ndarray=\"0.15\", serde=\"1.0\"\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._convert_args_for_rust-Tuple","page":"API Reference","title":"RustCall._convert_args_for_rust","text":"_convert_args_for_rust(args...)\n\nConvert Julia arguments to Rust-compatible types. String arguments are passed directly and converted by ccall.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._count_trailing_backslashes-Tuple{AbstractString}","page":"API Reference","title":"RustCall._count_trailing_backslashes","text":"_count_trailing_backslashes(s::AbstractString) -> Int\n\nCount consecutive trailing backslash characters. Used to determine whether a quote is escaped: the quote is escaped only if preceded by an odd number of backslashes (e.g., \\\" is escaped, \\\\\" is not).\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._detect_and_register_generic_functions-Tuple{String, String}","page":"API Reference","title":"RustCall._detect_and_register_generic_functions","text":"_detect_and_register_generic_functions(code::String, lib_name::String)\n\nDetect generic functions in Rust code and register them for monomorphization.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._emit_function_code-Tuple{RustCall.RustFunctionSignature}","page":"API Reference","title":"RustCall._emit_function_code","text":"_emit_function_code(func::RustFunctionSignature) -> String\n\nGenerate Julia code for a function wrapper as a string.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._emit_method_code-Tuple{RustCall.RustStructInfo, RustCall.RustMethod}","page":"API Reference","title":"RustCall._emit_method_code","text":"_emit_method_code(struct_info::RustStructInfo, method::RustMethod) -> String\n\nGenerate Julia code for a method wrapper as a string.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._emit_struct_code-Tuple{RustCall.RustStructInfo}","page":"API Reference","title":"RustCall._emit_struct_code","text":"_emit_struct_code(info::RustStructInfo) -> String\n\nGenerate Julia code for a struct wrapper as a string.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._extract_error_line_numbers_impl-Tuple{String}","page":"API Reference","title":"RustCall._extract_error_line_numbers_impl","text":"_extract_error_line_numbers_impl(stderr::String) -> Vector{Int}\n\nExtract line numbers from rustc error output.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._extract_suggestions_impl-Tuple{String}","page":"API Reference","title":"RustCall._extract_suggestions_impl","text":"_extract_suggestions_impl(stderr::String) -> Vector{String}\n\nExtract helpful suggestions from rustc error output.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._find_matching_angle_bracket-Tuple{AbstractString, Int64}","page":"API Reference","title":"RustCall._find_matching_angle_bracket","text":"_find_matching_angle_bracket(s::AbstractString, open_pos::Int) -> Int\n\nFind the position of the matching closing > for an opening < at open_pos, correctly handling nested angle brackets like Vec<Option<T>>. Returns 0 if no matching bracket is found.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._generate_irust_function-Tuple{String, String, Vector{String}, String}","page":"API Reference","title":"RustCall._generate_irust_function","text":"_generate_irust_function(func_name::String, code::String, arg_types::Vector{String}, ret_type::String) -> String\n\nGenerate a complete Rust function from the code snippet. The code should use arg1, arg2, etc. to reference arguments.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._generate_option_function_wrapper-Tuple{RustCall.RustFunctionSignature, RustCall.OptionTypeInfo, Vector{Symbol}, Vector}","page":"API Reference","title":"RustCall._generate_option_function_wrapper","text":"_generate_option_function_wrapper(func, option_info, arg_syms, converted_args) -> Expr\n\nGenerate a Julia wrapper for a function that returns Option<T>. The wrapper will return RustOption{T}.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._generate_property_accessors-Tuple{RustCall.RustStructInfo}","page":"API Reference","title":"RustCall._generate_property_accessors","text":"_generate_property_accessors(info::RustStructInfo) -> Union{Expr, Nothing}\n\nGenerate Base.getproperty and Base.setproperty! methods for natural field access. This allows obj.field and obj.field = value syntax.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._generate_result_function_wrapper-Tuple{RustCall.RustFunctionSignature, RustCall.ResultTypeInfo, Vector{Symbol}, Vector}","page":"API Reference","title":"RustCall._generate_result_function_wrapper","text":"_generate_result_function_wrapper(func, result_info, arg_syms, converted_args) -> Expr\n\nGenerate a Julia wrapper for a function that returns Result<T, E>. The wrapper will return RustResult{T, E}.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._generate_single_wrapper-Tuple{RustCall.RustFunctionSignature}","page":"API Reference","title":"RustCall._generate_single_wrapper","text":"_generate_single_wrapper(sig::RustFunctionSignature) -> Union{Expr, Nothing}\n\nGenerate a Julia wrapper function for a single Rust function signature. Uses direct function call instead of @rust macro for better scope handling.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._get_library_filename-Tuple{String}","page":"API Reference","title":"RustCall._get_library_filename","text":"_get_library_filename(crate_name::String) -> String\n\nGet the platform-specific library filename for a crate.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._get_reload_lock-Tuple{String}","page":"API Reference","title":"RustCall._get_reload_lock","text":"_get_reload_lock(lib_name::String) -> ReentrantLock\n\nGet or create a per-library lock for serializing reload operations.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._infer_return_type-Tuple{String}","page":"API Reference","title":"RustCall._infer_return_type","text":"_infer_return_type(code::String) -> String\n\nInfer return type from Rust code (legacy function, kept for compatibility).\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._infer_return_type_improved-Tuple{String, Vector{<:Type}, Vector{String}}","page":"API Reference","title":"RustCall._infer_return_type_improved","text":"_infer_return_type_improved(code::String, arg_types::Vector{Type}, rust_arg_types::Vector{String}) -> String\n\nInfer return type from Rust code with improved heuristics.\n\nStrategy\n\nLook for explicit return statements with literals\nAnalyze arithmetic operations (int vs float)\nUse argument types as hints\nFall back to first argument type if available\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._julia_to_rust_type-Tuple{Type}","page":"API Reference","title":"RustCall._julia_to_rust_type","text":"_julia_to_rust_type(julia_type::Type) -> String\n\nConvert Julia type to Rust type string.\n\nSupported Types\n\nInteger types: Int8, Int16, Int32, Int64, UInt8, UInt16, UInt32, UInt64\nFloating point: Float32, Float64\nBoolean: Bool\n\nError Handling\n\nUnsupported types throw an error to prevent ABI mismatches.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._parse_function_return_type-Tuple{String, String}","page":"API Reference","title":"RustCall._parse_function_return_type","text":"_parse_function_return_type(code::String, func_name::String) -> Union{Type, Nothing}\n\nParse the return type of a function from Rust code. Returns the Julia type corresponding to the Rust return type, or nothing if not found.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._parse_irust_variables-Tuple{String}","page":"API Reference","title":"RustCall._parse_irust_variables","text":"_parse_irust_variables(code::String) -> (Vector{Symbol}, String)\n\nParse $var syntax in irust code and extract variable names. Returns (list of variable symbols, processed code with var replaced by argN).\n\nExample\n\nvars, code = _parse_irust_variables(\"$x + $y * 2\")\n# vars = [:x, :y]\n# code = \"arg1 + arg2 * 2\"\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._parse_qualified_call-Tuple{Any}","page":"API Reference","title":"RustCall._parse_qualified_call","text":"_parse_qualified_call(expr) -> Union{Tuple{Any, Expr}, Nothing}\n\nParse lib::func(args...) into (lib, call_expr).\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._parse_single_arg!-Tuple{Vector{String}, Vector{String}, AbstractString}","page":"API Reference","title":"RustCall._parse_single_arg!","text":"_parse_single_arg!(names::Vector{String}, types::Vector{String}, arg::AbstractString)\n\nParse a single function argument \"name: type\" and add to the vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._register_function_signatures-Tuple{String, String}","page":"API Reference","title":"RustCall._register_function_signatures","text":"_register_function_signatures(code::String, lib_name::String)\n\nRegister function return types from Rust code for type inference.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._reload_library_locked-Tuple{HotReloadState}","page":"API Reference","title":"RustCall._reload_library_locked","text":"_reload_library_locked(state::HotReloadState) -> Bool\n\nInternal implementation of reload_library, called while holding the per-library lock.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._remove_generic_params_from_fns-Tuple{AbstractString}","page":"API Reference","title":"RustCall._remove_generic_params_from_fns","text":"_remove_generic_params_from_fns(code::AbstractString) -> String\n\nRemove generic parameter lists from function signatures (e.g., fn name<T, Vec<U>>( -> fn name(), correctly handling nested angle brackets.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._remove_generic_params_from_impls-Tuple{AbstractString}","page":"API Reference","title":"RustCall._remove_generic_params_from_impls","text":"_remove_generic_params_from_impls(code::AbstractString) -> String\n\nRemove generic parameter lists from impl blocks (e.g., impl<T> -> impl), correctly handling nested angle brackets.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._resolve_lib-Tuple{Module, String}","page":"API Reference","title":"RustCall._resolve_lib","text":"_resolve_lib(mod::Module, lib_name::String)\n\nResolve the actual library name to use, handling session-aware reloading for precompiled modules.\n\nWhen a module has multiple rust\"\"\" blocks, all libraries are loaded to enable the fallback function lookup across libraries in get_function_pointer.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._rust_call_dynamic-Tuple{String, String, Vararg{Any}}","page":"API Reference","title":"RustCall._rust_call_dynamic","text":"_rust_call_dynamic(lib_name::String, func_name::String, args...)\n\nCall a Rust function with dynamic type dispatch. Automatically handles generic functions by monomorphizing them.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._rust_call_from_lib-Tuple{String, String, Vararg{Any}}","page":"API Reference","title":"RustCall._rust_call_from_lib","text":"_rust_call_from_lib(lib_name::String, func_name::String, args...)\n\nCall a Rust function from a specific library.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._rust_call_typed-Tuple{String, String, Type, Vararg{Any}}","page":"API Reference","title":"RustCall._rust_call_typed","text":"_rust_call_typed(lib_name::String, func_name::String, ret_type::Type, args...)\n\nCall a Rust function with explicit return type.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._rust_llvm_call-Tuple{String, Vararg{Any}}","page":"API Reference","title":"RustCall._rust_llvm_call","text":"_rust_llvm_call(func_name::String, args...)\n\nInternal function to call a Rust function via LLVM integration. Falls back to ccall if llvmcall is not available.\n\nErrors\n\nArgumentError: If function is not registered and cannot be found in current library\nTypeError: If argument types don't match expected signature\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._rust_to_julia_type-Tuple{String}","page":"API Reference","title":"RustCall._rust_to_julia_type","text":"_rust_to_julia_type(rust_type::String) -> Type\n\nConvert Rust type string to Julia type.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._rust_type_to_julia_conversion_type-Tuple{String}","page":"API Reference","title":"RustCall._rust_type_to_julia_conversion_type","text":"_rust_type_to_julia_conversion_type(rust_type::String) -> Union{Symbol, Nothing}\n\nGet the Julia type to use for argument conversion from Rust type. Returns Nothing if no conversion is needed or type is unknown.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._rust_type_to_julia_type_symbol-Tuple{String}","page":"API Reference","title":"RustCall._rust_type_to_julia_type_symbol","text":"_rust_type_to_julia_type_symbol(rust_type::String) -> Union{Symbol, Nothing}\n\nGet the Julia type symbol for return type annotation.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._struct_type_to_llvm_ir-Tuple{Type}","page":"API Reference","title":"RustCall._struct_type_to_llvm_ir","text":"_struct_type_to_llvm_ir(t::Type) -> String\n\nConvert a Julia struct type to LLVM IR struct representation. Extracts field types from the struct definition.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall._tuple_type_to_llvm_ir-Tuple{Type{<:Tuple}}","page":"API Reference","title":"RustCall._tuple_type_to_llvm_ir","text":"_tuple_type_to_llvm_ir(t::Type{<:Tuple}) -> String\n\nConvert a Julia Tuple type to LLVM IR struct representation.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.add_function_optimization_passes!-Tuple{LLVM.ModulePassManager, OptimizationConfig}","page":"API Reference","title":"RustCall.add_function_optimization_passes!","text":"add_function_optimization_passes!(pm::LLVM.ModulePassManager, config::OptimizationConfig)\n\nAdd function-level optimization passes.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.add_optimization_passes!-Tuple{LLVM.ModulePassManager, OptimizationConfig}","page":"API Reference","title":"RustCall.add_optimization_passes!","text":"add_optimization_passes!(pm::LLVM.ModulePassManager, config::OptimizationConfig)\n\nAdd optimization passes to the pass manager based on configuration.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.build_cargo_project_cached-Tuple{CargoProject, AbstractString}","page":"API Reference","title":"RustCall.build_cargo_project_cached","text":"build_cargo_project_cached(\n    project::CargoProject,\n    code_hash::UInt64;\n    release::Bool = true\n) -> String\n\nBuild a Cargo project with caching support.\n\nIf a cached library exists with matching code and dependency hashes, returns the cached library path. Otherwise, builds the project and caches the result.\n\nArguments\n\nproject::CargoProject: The Cargo project to build\ncode_hash::AbstractString: SHA256 hex digest of the Rust source code\n\nKeyword Arguments\n\nrelease::Bool: Build in release mode (default: true)\n\nReturns\n\nString: Path to the compiled shared library (may be cached)\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.build_crate_directly-Tuple{CrateInfo, Bool}","page":"API Reference","title":"RustCall.build_crate_directly","text":"build_crate_directly(info::CrateInfo, release::Bool) -> String\n\nBuild the crate directly using cargo and return the path to the library.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.build_llvmcall_expr-Tuple{Ptr{Nothing}, Type, Any, Any}","page":"API Reference","title":"RustCall.build_llvmcall_expr","text":"build_llvmcall_expr(func_ptr::Ptr{Cvoid}, ret_type::Type, arg_types::Tuple, args::Tuple)\n\nBuild an expression that uses llvmcall to invoke a function. This is used internally by @generated functions.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.call_rust_function-Tuple{Ptr{Nothing}, Type, Type{<:Tuple}, Vararg{Any}}","page":"API Reference","title":"RustCall.call_rust_function","text":"call_rust_function(func_ptr::Ptr{Cvoid}, ret_type::Type, argt::Type{<:Tuple}, args...)\n\nCall a Rust function with a tuple type for arguments.\n\nArguments\n\nfunc_ptr::Ptr{Cvoid}: Function pointer to the Rust function\nret_type::Type: Expected return type\nargt::Type{<:Tuple}: Tuple type containing argument types\nargs...: Arguments to pass to the function\n\nReturns\n\nThe return value of the Rust function\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.call_rust_function-Tuple{Ptr{Nothing}, Type, Vararg{Any}}","page":"API Reference","title":"RustCall.call_rust_function","text":"call_rust_function(func_ptr::Ptr{Cvoid}, ret_type::Type, args...)\n\nCall a Rust function with the given return type. Uses a generated ccall based on normalized argument types.\n\nArguments\n\nfunc_ptr::Ptr{Cvoid}: Function pointer to the Rust function\nret_type::Type: Expected return type of the function\nargs...: Arguments to pass to the function\n\nReturns\n\nThe return value of the Rust function, converted to the specified ret_type\n\nExample\n\nfunc_ptr = get_function_pointer(\"mylib\", \"add\")\nresult = call_rust_function(func_ptr, Int32, 10, 20)  # Returns Int32\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.call_rust_function-Tuple{Ptr{Nothing}, Type, Vector{Type}, Vararg{Any}}","page":"API Reference","title":"RustCall.call_rust_function","text":"call_rust_function(func_ptr::Ptr{Cvoid}, ret_type::Type, arg_types::Vector{Type}, args...)\n\nCall a Rust function with explicit argument types.\n\nArguments\n\nfunc_ptr::Ptr{Cvoid}: Function pointer to the Rust function\nret_type::Type: Expected return type\narg_types::Vector{Type}: Vector of argument types\nargs...: Arguments to pass to the function\n\nReturns\n\nThe return value of the Rust function\n\nExample\n\nfunc_ptr = get_function_pointer(\"mylib\", \"multiply\")\nresult = call_rust_function(func_ptr, Float64, [Float64, Float64], 3.14, 2.0)\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.call_rust_function_infer-Tuple{Ptr{Nothing}, Vararg{Any}}","page":"API Reference","title":"RustCall.call_rust_function_infer","text":"call_rust_function_infer(func_ptr::Ptr{Cvoid}, args...)\n\nCall a Rust function, inferring the return type from the first argument type. Uses @generated function for compile-time optimization based on argument types.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.check_dependency_availability-Tuple{Vector{DependencySpec}}","page":"API Reference","title":"RustCall.check_dependency_availability","text":"check_dependency_availability(deps::Vector{DependencySpec}) -> Bool\n\nCheck if dependencies are likely to be available on crates.io. This is a heuristic check - actual availability is confirmed during cargo build.\n\nReturns\n\ntrue if dependencies appear valid\nEmits warnings for potentially problematic dependencies\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.check_for_changes-Tuple{HotReloadState}","page":"API Reference","title":"RustCall.check_for_changes","text":"check_for_changes(state::HotReloadState) -> Bool\n\nCheck if any source files have been modified since last check. Updates the last_modified times if changes are detected.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.cleanup_cargo_project-Tuple{CargoProject}","page":"API Reference","title":"RustCall.cleanup_cargo_project","text":"cleanup_cargo_project(project::CargoProject)\n\nRemove the temporary Cargo project directory.\n\nArguments\n\nproject::CargoProject: The project to clean up\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.compute_crate_hash-Tuple{CrateInfo}","page":"API Reference","title":"RustCall.compute_crate_hash","text":"compute_crate_hash(info::CrateInfo) -> String\n\nCompute a hash for caching based on crate contents.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.convert_c_option_to_rust_option-Union{Tuple{T}, Tuple{Any, Type{T}}} where T","page":"API Reference","title":"RustCall.convert_c_option_to_rust_option","text":"convert_c_option_to_rust_option(c_option, inner_type::Type) -> RustOption\n\nConvert a C-compatible option struct to RustOption{T}.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.convert_c_result_to_rust_result-Union{Tuple{E}, Tuple{T}, Tuple{Any, Type{T}, Type{E}}} where {T, E}","page":"API Reference","title":"RustCall.convert_c_result_to_rust_result","text":"convert_c_result_to_rust_result(c_result, ok_type::Type, err_type::Type) -> RustResult\n\nConvert a C-compatible result struct to RustResult{T, E}.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.crate_has_cdylib-Tuple{String}","page":"API Reference","title":"RustCall.crate_has_cdylib","text":"crate_has_cdylib(crate_path::String) -> Bool\n\nCheck if the crate has cdylib in its crate-type.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.create_rust_arc-Tuple{T} where T","page":"API Reference","title":"RustCall.create_rust_arc","text":"create_rust_arc(value::T) -> RustArc{T} where T\n\nCreate a RustArc from a Julia value. Automatically calls the appropriate Rust Arc::new function.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.create_rust_box-Tuple{T} where T","page":"API Reference","title":"RustCall.create_rust_box","text":"create_rust_box(value::T) -> RustBox{T} where T\n\nCreate a RustBox from a Julia value. Automatically calls the appropriate Rust Box::new function.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.create_rust_rc-Tuple{T} where T","page":"API Reference","title":"RustCall.create_rust_rc","text":"create_rust_rc(value::T) -> RustRc{T} where T\n\nCreate a RustRc from a Julia value. Automatically calls the appropriate Rust Rc::new function.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.create_wrapper_crate-Tuple{CrateInfo, CrateBindingOptions}","page":"API Reference","title":"RustCall.create_wrapper_crate","text":"create_wrapper_crate(info::CrateInfo, opts::CrateBindingOptions) -> String\n\nCreate a wrapper crate that depends on the target crate and re-exports #[julia] items.\n\nReturns\n\nString: Path to the created wrapper crate directory\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.dispose_module-Tuple{RustCall.RustModule}","page":"API Reference","title":"RustCall.dispose_module","text":"dispose_module(mod::RustModule)\n\nDispose of the LLVM resources associated with a RustModule.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.drop_rust_arc-Union{Tuple{RustArc{T}}, Tuple{T}} where T","page":"API Reference","title":"RustCall.drop_rust_arc","text":"drop_rust_arc(arc::RustArc{T}) where T\n\nDrop a RustArc, decrementing the atomic reference count.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.drop_rust_box-Union{Tuple{RustBox{T}}, Tuple{T}} where T","page":"API Reference","title":"RustCall.drop_rust_box","text":"drop_rust_box(box::RustBox{T}) where T\n\nDrop a RustBox, calling the appropriate Rust drop function.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.drop_rust_rc-Union{Tuple{RustRc{T}}, Tuple{T}} where T","page":"API Reference","title":"RustCall.drop_rust_rc","text":"drop_rust_rc(rc::RustRc{T}) where T\n\nDrop a RustRc, decrementing the reference count.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.drop_rust_vec-Union{Tuple{RustVec{T}}, Tuple{T}} where T","page":"API Reference","title":"RustCall.drop_rust_vec","text":"drop_rust_vec(vec::RustVec{T}) -> Nothing\n\nDrop a RustVec by calling the Rust-side drop function.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.emit_crate_module-Tuple{CrateInfo, String}","page":"API Reference","title":"RustCall.emit_crate_module","text":"emit_crate_module(info::CrateInfo, lib_path::String; module_name::Union{String, Nothing}=nothing) -> Expr\n\nGenerate a Julia module expression containing bindings for the crate.\n\nArguments\n\ninfo::CrateInfo: Crate information from scan_crate\nlib_path::String: Path to the compiled shared library\n\nKeyword Arguments\n\nmodule_name::Union{String, Nothing}: Name for the module (default: crate name with first letter capitalized)\n\nReturns\n\nExpr: A module expression that can be evaluated\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.emit_crate_module_code-Tuple{CrateInfo, String}","page":"API Reference","title":"RustCall.emit_crate_module_code","text":"emit_crate_module_code(info::CrateInfo, lib_path::String; kwargs...) -> String\n\nGenerate Julia module code as a string, suitable for writing to a file.\n\nArguments\n\ninfo::CrateInfo: Crate information from scan_crate\nlib_path::String: Path to the compiled shared library (or relative path)\n\nKeyword Arguments\n\nmodule_name::Union{String, Nothing}: Name for the module\nuse_relative_path::Bool: If true, treat lib_path as relative to @DIR\n\nReturns\n\nString: Julia source code for the module\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.emit_julia_definitions-Tuple{RustCall.RustStructInfo}","page":"API Reference","title":"RustCall.emit_julia_definitions","text":"emit_julia_definitions(info::RustStructInfo)\n\nGenerate Julia code to define a corresponding mutable struct and its methods. Only generates definitions for structs marked with #[derive(JuliaStruct)] or #[julia].\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.emit_julia_function_wrappers-Tuple{Vector{RustCall.RustFunctionSignature}}","page":"API Reference","title":"RustCall.emit_julia_function_wrappers","text":"emit_julia_function_wrappers(signatures::Vector{RustFunctionSignature}) -> Expr\n\nGenerate Julia wrapper functions for the given Rust function signatures.\n\nFor a function like:\n\n#[julia]\nfn add(a: i32, b: i32) -> i32 { ... }\n\nGenerates:\n\nadd(a, b) = @rust add(Int32(a), Int32(b))::Int32\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.ensure_loaded-Tuple{String, String}","page":"API Reference","title":"RustCall.ensure_loaded","text":"ensure_loaded(lib_name::String, code::String)\n\nEnsure that a Rust library is loaded in the current session. Useful for precompiled modules that need to reload libraries at runtime.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.escape_toml_string-Tuple{AbstractString}","page":"API Reference","title":"RustCall.escape_toml_string","text":"escape_toml_string(s::AbstractString) -> String\n\nEscape special characters in a string for safe TOML value interpolation. Prevents TOML injection by escaping backslashes, quotes, and control characters.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.extract_block_at-Tuple{String, Int64}","page":"API Reference","title":"RustCall.extract_block_at","text":"extract_block_at(code::String, start_idx::Int) -> Union{String, Nothing}\n\nExtract a balanced brace block starting near startidx. Searches for the first '{' at or after startidx.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.extract_cargo_block-Tuple{String}","page":"API Reference","title":"RustCall.extract_cargo_block","text":"extract_cargo_block(code::String) -> Union{String, Nothing}\n\nExtract the cargo TOML block from Rust code.\n\nLooks for patterns like:\n\n//! ```cargo\n//! [dependencies]\n//! ndarray = \"0.15\"\n//! ```\n\nReturns\n\nThe content inside the cargo block (without //! prefixes), or nothing if not found\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.extract_cargo_deps_line-Tuple{String}","page":"API Reference","title":"RustCall.extract_cargo_deps_line","text":"extract_cargo_deps_line(code::String) -> Union{String, Nothing}\n\nExtract the cargo-deps line from Rust code.\n\nLooks for patterns like:\n\n// cargo-deps: ndarray=\"0.15\", serde=\"1.0\"\n\nReturns\n\nThe content after \"cargo-deps:\", or nothing if not found\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.extract_crate_dependencies-Tuple{Dict}","page":"API Reference","title":"RustCall.extract_crate_dependencies","text":"extract_crate_dependencies(cargo_toml::Dict) -> Vector{DependencySpec}\n\nExtract dependencies from parsed Cargo.toml.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.extract_function_code-Tuple{String, String}","page":"API Reference","title":"RustCall.extract_function_code","text":"extract_function_code(code::String, func_name::String) -> Union{String, Nothing}\n\nExtract the full code for a function from Rust source code.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.extract_function_ir-Tuple{RustCall.RustModule, String}","page":"API Reference","title":"RustCall.extract_function_ir","text":"extract_function_ir(mod::RustModule, func_name::String) -> String\n\nExtract the LLVM IR for a specific function from a RustModule.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.find_rust_source_files-Tuple{String}","page":"API Reference","title":"RustCall.find_rust_source_files","text":"find_rust_source_files(crate_path::String) -> Vector{String}\n\nFind all .rs files in a crate's src directory.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.find_rust_sources-Tuple{String}","page":"API Reference","title":"RustCall.find_rust_sources","text":"find_rust_sources(crate_path::String) -> Vector{String}\n\nFind all .rs files in a crate's src directory.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.format_dependency_line-Tuple{DependencySpec}","page":"API Reference","title":"RustCall.format_dependency_line","text":"format_dependency_line(dep::DependencySpec) -> String\n\nFormat a single dependency for Cargo.toml.\n\nExamples\n\nformat_dependency_line(DependencySpec(\"ndarray\", version=\"0.15\"))\n# => \"ndarray = \"0.15\"\"\n\nformat_dependency_line(DependencySpec(\"serde\", version=\"1.0\", features=[\"derive\"]))\n# => \"serde = { version = \"1.0\", features = [\"derive\"] }\"\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.free_rust_obj-Tuple{Ptr{Nothing}, String}","page":"API Reference","title":"RustCall.free_rust_obj","text":"free_rust_obj(ptr::Ptr{Cvoid}, lib_func::String)\n\nHelper to safely call the Rust destructor.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.generate_c_option_struct_type-Tuple{String, Symbol}","page":"API Reference","title":"RustCall.generate_c_option_struct_type","text":"generate_c_option_struct_type(func_name::String, inner_type::Symbol) -> Expr\n\nGenerate a Julia struct definition for the C-compatible Option type.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.generate_c_result_struct_type-Tuple{String, Symbol, Symbol}","page":"API Reference","title":"RustCall.generate_c_result_struct_type","text":"generate_c_result_struct_type(func_name::String, ok_type::Symbol, err_type::Symbol) -> Expr\n\nGenerate a Julia struct definition for the C-compatible Result type.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.generate_cache_key-Tuple{String, RustCompiler}","page":"API Reference","title":"RustCall.generate_cache_key","text":"generate_cache_key(code::String, compiler::RustCompiler) -> String\n\nGenerate a cache key based on code hash, compiler settings, and target triple. Uses SHA256 for collision resistance.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.generate_cargo_toml-Tuple{String, Vector{DependencySpec}, String}","page":"API Reference","title":"RustCall.generate_cargo_toml","text":"generate_cargo_toml(name::String, deps::Vector{DependencySpec}, edition::String) -> String\n\nGenerate Cargo.toml content for a project.\n\nArguments\n\nname::String: Project name\ndeps::Vector{DependencySpec}: Dependencies\nedition::String: Rust edition\n\nReturns\n\nString: Cargo.toml content\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.generate_crate_function_wrappers-Tuple{CrateInfo, String}","page":"API Reference","title":"RustCall.generate_crate_function_wrappers","text":"generate_crate_function_wrappers(info::CrateInfo, lib_path::String) -> Expr\n\nGenerate Julia wrapper functions for all #[julia] functions in the crate.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.generate_crate_struct_wrappers-Tuple{CrateInfo, String}","page":"API Reference","title":"RustCall.generate_crate_struct_wrappers","text":"generate_crate_struct_wrappers(info::CrateInfo, lib_path::String) -> Expr\n\nGenerate Julia struct definitions and wrappers for all #[julia] structs in the crate.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.generate_llvmcall_ir-Tuple{String, Type, Vector{Type}}","page":"API Reference","title":"RustCall.generate_llvmcall_ir","text":"generate_llvmcall_ir(func_name::String, ret_type::Type, arg_types::Vector{Type}) -> String\n\nGenerate LLVM IR string suitable for llvmcall based on function signature. This creates a simple wrapper that calls the actual function.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.generate_struct_wrappers-Tuple{RustCall.RustStructInfo}","page":"API Reference","title":"RustCall.generate_struct_wrappers","text":"generate_struct_wrappers(info::RustStructInfo) -> String\n\nGenerate \"extern C\" C-FFI wrappers for a given struct. For generic structs, registers them as generic functions instead of returning static wrappers. Only generates wrappers for structs marked with #[derive(JuliaStruct)] or #[julia].\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.generate_wrapper_cargo_toml-Tuple{CrateInfo, CrateBindingOptions}","page":"API Reference","title":"RustCall.generate_wrapper_cargo_toml","text":"generate_wrapper_cargo_toml(info::CrateInfo, opts::CrateBindingOptions) -> String\n\nGenerate Cargo.toml content for the wrapper crate.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.generate_wrapper_lib_rs-Tuple{CrateInfo}","page":"API Reference","title":"RustCall.generate_wrapper_lib_rs","text":"generate_wrapper_lib_rs(info::CrateInfo) -> String\n\nGenerate lib.rs content for the wrapper crate that re-exports #[julia] items.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_built_library_path-Tuple{CargoProject, Bool}","page":"API Reference","title":"RustCall.get_built_library_path","text":"get_built_library_path(project::CargoProject, release::Bool) -> String\n\nGet the path to the built library for a Cargo project.\n\nArguments\n\nproject::CargoProject: The Cargo project\nrelease::Bool: Whether release mode was used\n\nReturns\n\nString: Path to the shared library\n\nNote\n\nThe path follows Cargo's target directory structure:\n\nRelease: target/release/libname.dylib (or .so, .dll)\nDebug: target/debug/libname.dylib\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_cache_dir-Tuple{}","page":"API Reference","title":"RustCall.get_cache_dir","text":"get_cache_dir() -> String\n\nGet the cache directory for RustCall.jl compiled libraries. Uses Julia's standard cache directory structure.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_cached_library-Tuple{String}","page":"API Reference","title":"RustCall.get_cached_library","text":"get_cached_library(cache_key::String) -> Union{String, Nothing}\n\nCheck if a cached library exists for the given cache key. Returns the path to the cached library if it exists, nothing otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_cached_llvm_ir-Tuple{String}","page":"API Reference","title":"RustCall.get_cached_llvm_ir","text":"get_cached_llvm_ir(cache_key::String) -> Union{String, Nothing}\n\nCheck if a cached LLVM IR file exists for the given cache key. Returns the path to the cached IR file if it exists, nothing otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_cargo_cache_dir-Tuple{}","page":"API Reference","title":"RustCall.get_cargo_cache_dir","text":"get_cargo_cache_dir() -> String\n\nGet the cache directory for Cargo-built libraries.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_cargo_cached_library-Tuple{String}","page":"API Reference","title":"RustCall.get_cargo_cached_library","text":"get_cargo_cached_library(cache_key::String) -> Union{String, Nothing}\n\nGet a cached Cargo library by cache key.\n\nReturns\n\nPath to cached library, or nothing if not found\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_current_library-Tuple{}","page":"API Reference","title":"RustCall.get_current_library","text":"get_current_library() -> String\n\nGet the name of the currently active Rust library.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_default_target-Tuple{}","page":"API Reference","title":"RustCall.get_default_target","text":"get_default_target() -> String\n\nGet the default target triple for the current platform.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_file_mtime-Tuple{String}","page":"API Reference","title":"RustCall.get_file_mtime","text":"get_file_mtime(path::String) -> Float64\n\nGet the modification time of a file as a Float64 timestamp. Returns 0.0 if the file doesn't exist.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_function-Tuple{RustCall.RustModule, String}","page":"API Reference","title":"RustCall.get_function","text":"get_function(mod::RustModule, name::String) -> Union{LLVM.Function, Nothing}\n\nGet a function by name from the RustModule.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_function_info-Tuple{String, String}","page":"API Reference","title":"RustCall.get_function_info","text":"get_function_info(lib_name::String, name::String) -> Union{FunctionInfo, Nothing}\n\nGet registered function info scoped to a library. Falls back to name-only registry for backward compatibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_function_info-Tuple{String}","page":"API Reference","title":"RustCall.get_function_info","text":"get_function_info(name::String) -> Union{FunctionInfo, Nothing}\n\nGet the registered function info for a function name.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_function_pointer-Tuple{String, String}","page":"API Reference","title":"RustCall.get_function_pointer","text":"get_function_pointer(lib_name::String, func_name::String) -> Ptr{Cvoid}\n\nGet a function pointer from a loaded library.\n\nIf the function is not found in the specified library, searches all other loaded libraries as a fallback. This enables using functions from multiple rust\"\"\" blocks.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_function_pointer_from_lib-Tuple{Ptr{Nothing}, String}","page":"API Reference","title":"RustCall.get_function_pointer_from_lib","text":"get_function_pointer_from_lib(lib_handle::Ptr{Cvoid}, func_name::String) -> Ptr{Cvoid}\n\nGet a function pointer from a loaded library.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_function_return_type-Tuple{String, String}","page":"API Reference","title":"RustCall.get_function_return_type","text":"get_function_return_type(lib_name::String, func_name::String) -> Union{Type, Nothing}\n\nGet a registered return type for a function in a specific library. Falls back to global function-name mapping for backward compatibility.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_function_signature-Tuple{LLVM.Function}","page":"API Reference","title":"RustCall.get_function_signature","text":"get_function_signature(fn::LLVM.Function) -> Tuple{Type, Vector{Type}}\n\nGet the Julia return type and argument types for an LLVM function.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_library_extension-Tuple{}","page":"API Reference","title":"RustCall.get_library_extension","text":"get_library_extension() -> String\n\nGet the shared library extension for the current platform.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_library_handle-Tuple{String}","page":"API Reference","title":"RustCall.get_library_handle","text":"get_library_handle(name::String) -> Ptr{Cvoid}\n\nGet the library handle for a named library.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_metadata_dir-Tuple{}","page":"API Reference","title":"RustCall.get_metadata_dir","text":"get_metadata_dir() -> String\n\nGet the directory for cache metadata files.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_monomorphized_function-Tuple{String, Dict{Symbol, <:Type}}","page":"API Reference","title":"RustCall.get_monomorphized_function","text":"get_monomorphized_function(func_name::String, type_params::Dict{Symbol, Type}) -> Union{FunctionInfo, Nothing}\n\nGet a monomorphized function instance if it exists.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_optimization_stats-Tuple{LLVM.Module}","page":"API Reference","title":"RustCall.get_optimization_stats","text":"get_optimization_stats(mod::LLVM.Module) -> Dict{String, Any}\n\nGet statistics about an LLVM module for optimization analysis.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_or_compile_function-Tuple{RustCall.RustModule, String}","page":"API Reference","title":"RustCall.get_or_compile_function","text":"get_or_compile_function(mod::RustModule, name::String) -> Ptr{Cvoid}\n\nGet a compiled function pointer, compiling if necessary using Julia's JIT.\n\nArguments\n\nmod::RustModule: The Rust module containing the function\nname::String: Name of the function to compile\n\nReturns\n\nPtr{Cvoid}: Function pointer to the compiled function\n\nNote\n\nThis function is a placeholder for future LLVM JIT compilation support. Currently, it raises an error indicating that direct LLVM JIT compilation is not yet implemented. Use the shared library approach instead.\n\nExample\n\nmod = load_llvm_ir(\"path/to/file.ll\")\n# Note: This will raise an error until JIT compilation is implemented\n# func_ptr = get_or_compile_function(mod, \"my_function\")\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_project_lib_name-Tuple{CargoProject}","page":"API Reference","title":"RustCall.get_project_lib_name","text":"get_project_lib_name(project::CargoProject) -> String\n\nGet the library file name for the project (platform-specific).\n\nReturns\n\nLibrary filename (e.g., \"libmy_project.dylib\" on macOS)\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_registered_function-Tuple{String}","page":"API Reference","title":"RustCall.get_registered_function","text":"get_registered_function(func_name::String) -> Union{RustFunctionInfo, Nothing}\n\nGet a registered Rust function's information.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.get_rust_module-Tuple{String}","page":"API Reference","title":"RustCall.get_rust_module","text":"get_rust_module(code::String) -> Union{RustModule, Nothing}\n\nGet the RustModule for a given code string, if available.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.has_julia_attribute-Tuple{String}","page":"API Reference","title":"RustCall.has_julia_attribute","text":"has_julia_attribute(code::String) -> Bool\n\nCheck if the code contains any #[julia] or #[julia_pyo3] attributes.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.hash_dependencies-Tuple{Vector{DependencySpec}}","page":"API Reference","title":"RustCall.hash_dependencies","text":"hash_dependencies(deps::Vector{DependencySpec}) -> String\n\nGenerate a hash of the dependency specifications for cache keying.\n\nArguments\n\ndeps::Vector{DependencySpec}: Dependencies to hash\n\nReturns\n\nString: Hex-encoded hash of the dependencies\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.infer_function_types-Tuple{String, String}","page":"API Reference","title":"RustCall.infer_function_types","text":"infer_function_types(lib_name::String, func_name::String) -> Tuple{Type, Vector{Type}}\n\nTry to infer the return type and argument types for a function. Uses LLVM IR analysis if available.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.is_cache_valid-Tuple{String, String, RustCompiler}","page":"API Reference","title":"RustCall.is_cache_valid","text":"is_cache_valid(cache_key::String, code::String, compiler::RustCompiler) -> Bool\n\nCheck if a cached library is still valid for the given code and compiler settings.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.is_option_type-Tuple{String}","page":"API Reference","title":"RustCall.is_option_type","text":"is_option_type(rust_type::String) -> Bool\n\nCheck if a Rust type is Option<T>.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.is_result_type-Tuple{String}","page":"API Reference","title":"RustCall.is_result_type","text":"is_result_type(rust_type::String) -> Bool\n\nCheck if a Rust type is Result<T, E>.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.julia_to_llvm_type-Tuple{Type}","page":"API Reference","title":"RustCall.julia_to_llvm_type","text":"julia_to_llvm_type(julia_type::Type) -> String\n\nConvert a Julia type to the corresponding LLVM IR type string.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.julia_type_to_llvm-Tuple{Type}","page":"API Reference","title":"RustCall.julia_type_to_llvm","text":"julia_type_to_llvm(julia_type::Type) -> LLVM.LLVMType\n\nConvert a Julia type to the corresponding LLVM type. Note: Must be called within an active LLVM context (use LLVM.Context() do ... end).\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.list_functions-Tuple{RustCall.RustModule}","page":"API Reference","title":"RustCall.list_functions","text":"list_functions(mod::RustModule) -> Vector{String}\n\nList all exported function names in the module.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.list_library_functions-Tuple{String}","page":"API Reference","title":"RustCall.list_library_functions","text":"list_library_functions(lib_name::String) -> Vector{String}\n\nList all exported functions in a loaded library. Note: This uses the LLVM IR module if available, otherwise returns an empty list.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.list_loaded_libraries-Tuple{}","page":"API Reference","title":"RustCall.list_loaded_libraries","text":"list_loaded_libraries() -> Vector{String}\n\nList all currently loaded Rust libraries.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.llvm_to_julia_type-Tuple{String}","page":"API Reference","title":"RustCall.llvm_to_julia_type","text":"llvm_to_julia_type(llvm_type_str::String) -> Type\n\nConvert an LLVM IR type string to the corresponding Julia type.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.llvm_type_to_julia-Tuple{LLVM.LLVMType}","page":"API Reference","title":"RustCall.llvm_type_to_julia","text":"llvm_type_to_julia(llvm_type::LLVM.LLVMType) -> Type\n\nConvert an LLVM type to the corresponding Julia type. Uses LLVM.jl 9.x API which uses concrete types for different LLVM types.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.load_cache_metadata-Tuple{String}","page":"API Reference","title":"RustCall.load_cache_metadata","text":"load_cache_metadata(cache_key::String) -> Union{CacheMetadata, Nothing}\n\nLoad cache metadata from a JSON file.\n\nArguments\n\ncache_key::String: The cache key identifying the cached library\n\nReturns\n\nUnion{CacheMetadata, Nothing}: The loaded metadata, or nothing if not found\n\nNote\n\nThis function currently returns nothing as a placeholder. Full JSON parsing will be implemented in a future version.\n\nExample\n\nmeta = load_cache_metadata(\"abc123...\")\nif meta !== nothing\n    println(\"Cache created at: $(meta.created_at)\")\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.load_cached_library-Tuple{String}","page":"API Reference","title":"RustCall.load_cached_library","text":"load_cached_library(cache_key::String) -> Tuple{Ptr{Cvoid}, String}\n\nLoad a cached library and return its handle and library name.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.load_rust_helpers_lib-Tuple{String}","page":"API Reference","title":"RustCall.load_rust_helpers_lib","text":"load_rust_helpers_lib(lib_path::String)\n\nLoad the Rust helpers library from a file path.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.merge_dependencies-Tuple{Vector{DependencySpec}}","page":"API Reference","title":"RustCall.merge_dependencies","text":"merge_dependencies(deps::Vector{DependencySpec}) -> Vector{DependencySpec}\n\nMerge dependencies with the same name, combining features.\n\nArguments\n\ndeps::Vector{DependencySpec}: List of dependencies (may contain duplicates)\n\nReturns\n\nVector{DependencySpec}: Merged dependencies (no duplicates)\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.merge_two_dependencies-Tuple{DependencySpec, DependencySpec}","page":"API Reference","title":"RustCall.merge_two_dependencies","text":"merge_two_dependencies(dep1::DependencySpec, dep2::DependencySpec) -> DependencySpec\n\nMerge two dependencies with the same name.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.normalize_dependency-Tuple{DependencySpec}","page":"API Reference","title":"RustCall.normalize_dependency","text":"normalize_dependency(dep::DependencySpec) -> DependencySpec\n\nNormalize a dependency specification.\n\nSorts features alphabetically\nTrims whitespace from strings\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.optimize_balanced!-Tuple{LLVM.Module}","page":"API Reference","title":"RustCall.optimize_balanced!","text":"optimize_balanced!(mod::LLVM.Module)\n\nApply balanced optimizations (default).\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.optimize_function!-Tuple{LLVM.Function}","page":"API Reference","title":"RustCall.optimize_function!","text":"optimize_function!(fn::LLVM.Function; config=get_default_opt_config())\n\nApply optimization passes to a single LLVM function.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.parse_cargo_deps_line-Tuple{AbstractString}","page":"API Reference","title":"RustCall.parse_cargo_deps_line","text":"parse_cargo_deps_line(line::AbstractString) -> Vector{DependencySpec}\n\nParse a cargo-deps line to extract dependencies.\n\nFormat: name=\"version\", name2={version=\"1.0\", features=[\"f1\"]}\n\nArguments\n\nline::AbstractString: Content after \"cargo-deps:\"\n\nReturns\n\nVector{DependencySpec}: Parsed dependencies\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.parse_cargo_toml-Tuple{String}","page":"API Reference","title":"RustCall.parse_cargo_toml","text":"parse_cargo_toml(path::String) -> Dict\n\nParse a Cargo.toml file and return its contents as a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.parse_cargo_toml_block-Tuple{String}","page":"API Reference","title":"RustCall.parse_cargo_toml_block","text":"parse_cargo_toml_block(block::String) -> Vector{DependencySpec}\n\nParse a TOML-formatted cargo block to extract dependencies.\n\nArguments\n\nblock::String: TOML content from a cargo block\n\nReturns\n\nVector{DependencySpec}: Parsed dependencies\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.parse_impl_methods_for_struct-Tuple{String, String}","page":"API Reference","title":"RustCall.parse_impl_methods_for_struct","text":"parse_impl_methods_for_struct(code::String, struct_name::String) -> Vector{RustMethod}\n\nParse impl blocks for a struct and extract methods marked with #[julia] or #[juliapyo3]. If the impl block itself has #[juliapyo3], all pub fn methods are captured.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.parse_julia_functions-Tuple{String}","page":"API Reference","title":"RustCall.parse_julia_functions","text":"parse_julia_functions(code::String) -> Vector{RustFunctionSignature}\n\nParse Rust code and extract functions marked with #[julia] attribute.\n\nExample\n\n#[julia]\nfn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\nReturns a vector of RustFunctionSignature for each #[julia] marked function.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.parse_julia_structs_from_source-Tuple{String}","page":"API Reference","title":"RustCall.parse_julia_structs_from_source","text":"parse_julia_structs_from_source(code::String) -> Vector{RustStructInfo}\n\nParse Rust source code and extract structs marked with #[julia] or #[julia_pyo3].\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.parse_methods_in_impl-Tuple{AbstractString}","page":"API Reference","title":"RustCall.parse_methods_in_impl","text":"parse_methods_in_impl(impl_body::AbstractString) -> Vector{RustMethod}\n\nParse function definitions inside an impl block.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.parse_option_type-Tuple{String}","page":"API Reference","title":"RustCall.parse_option_type","text":"parse_option_type(rust_type::String) -> Union{OptionTypeInfo, Nothing}\n\nParse an Option<T> type string and extract T. Returns nothing if not an Option type.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.parse_result_type-Tuple{String}","page":"API Reference","title":"RustCall.parse_result_type","text":"parse_result_type(rust_type::String) -> Union{ResultTypeInfo, Nothing}\n\nParse a Result<T, E> type string and extract T and E. Returns nothing if not a Result type.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.parse_single_cargo_dep-Tuple{String}","page":"API Reference","title":"RustCall.parse_single_cargo_dep","text":"parse_single_cargo_dep(part::String) -> Union{DependencySpec, Nothing}\n\nParse a single dependency from cargo-deps format.\n\nFormats:\n\nname=\"version\"\nname={version=\"1.0\", features=[\"f1\", \"f2\"]}\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.parse_structs_and_impls-Tuple{String}","page":"API Reference","title":"RustCall.parse_structs_and_impls","text":"parse_structs_and_impls(code::String) -> Vector{RustStructInfo}\n\nHeuristic parser to find pub structs and their impl blocks. Supports generics (e.g. struct Point<T>) and captures full source context. Now supports #[derive(JuliaStruct)] attribute for automatic mapping.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.parse_toml_dependency-Tuple{String, Any}","page":"API Reference","title":"RustCall.parse_toml_dependency","text":"parse_toml_dependency(name::String, spec) -> DependencySpec\n\nParse a single dependency from TOML format.\n\nArguments\n\nname::String: Crate name\nspec: Version string or dict with version, features, git, path\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.parse_trait_type_params-Tuple{AbstractString}","page":"API Reference","title":"RustCall.parse_trait_type_params","text":"parse_trait_type_params(params_str::AbstractString) -> Vector{String}\n\nParse type parameters inside trait angle brackets, handling nested generics.\n\nExample\n\nparse_trait_type_params(\"Output = T, Error = E\")\n# => [\"Output = T\", \"Error = E\"]\n\nparse_trait_type_params(\"Vec<T>\")\n# => [\"Vec<T>\"]\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.print_function_ir-Tuple{LLVM.Function}","page":"API Reference","title":"RustCall.print_function_ir","text":"print_function_ir(fn::LLVM.Function; io::IO=stdout)\n\nPrint the LLVM IR of a function for debugging.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.print_module_ir-Tuple{LLVM.Module}","page":"API Reference","title":"RustCall.print_module_ir","text":"print_module_ir(mod::LLVM.Module; io::IO=stdout)\n\nPrint the LLVM IR of a module for debugging.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.rebuild_crate-Tuple{String}","page":"API Reference","title":"RustCall.rebuild_crate","text":"rebuild_crate(crate_path::String) -> String\n\nRebuild a Rust crate and return the path to the compiled library.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.register_function-Tuple{String, String, Type, Vector{Type}}","page":"API Reference","title":"RustCall.register_function","text":"register_function(name::String, lib_name::String, ret_type::Type, arg_types::Vector{Type})\n\nRegister a function with its type signature for later calling.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.reload_library-Tuple{HotReloadState}","page":"API Reference","title":"RustCall.reload_library","text":"reload_library(state::HotReloadState) -> Bool\n\nRebuild and reload a Rust library.\n\nReturns true if successful, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.remove_dependency_comments-Tuple{String}","page":"API Reference","title":"RustCall.remove_dependency_comments","text":"remove_dependency_comments(code::String) -> String\n\nRemove dependency specification comments from Rust code.\n\nRemoves:\n\n//!cargo  blocks\n// cargo-deps: ... lines\n\nArguments\n\ncode::String: Original Rust code\n\nReturns\n\nString: Code without dependency comments\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.remove_derive_julia_struct_attributes-Tuple{String}","page":"API Reference","title":"RustCall.remove_derive_julia_struct_attributes","text":"remove_derive_julia_struct_attributes(code::String) -> String\n\nRemove #[derive(JuliaStruct)] and related attributes from Rust code before compilation. This is necessary because JuliaStruct is not a real Rust macro.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.resolve_version-Tuple{Union{Nothing, String}, Union{Nothing, String}, String}","page":"API Reference","title":"RustCall.resolve_version","text":"resolve_version(v1::Union{String, Nothing}, v2::Union{String, Nothing}, name::String) -> Union{String, Nothing}\n\nResolve version conflict between two version specifications.\n\nStrategy\n\nIf both are nothing, return nothing\nIf one is nothing, return the other\nIf both are the same, return that version\nPrefer more specific version (e.g., \"1.0.5\" over \"1.0\")\nIf neither is more specific, use v1 with a warning\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.resolve_version_conflict-Tuple{DependencySpec, DependencySpec}","page":"API Reference","title":"RustCall.resolve_version_conflict","text":"resolve_version_conflict(dep1::DependencySpec, dep2::DependencySpec) -> DependencySpec\n\nResolve version conflicts between two dependency specifications.\n\nWhen two dependencies with the same name have different versions:\n\nIf one has a stricter (more specific) version, prefer that\nOtherwise, prefer the first one and emit a warning\n\nArguments\n\ndep1::DependencySpec: First dependency\ndep2::DependencySpec: Second dependency (same name)\n\nReturns\n\nDependencySpec: Resolved dependency\n\nThrows\n\nDependencyResolutionError if dependencies have incompatible sources\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.rust_call_generated-Union{Tuple{name}, Tuple{Val{name}, Vararg{Any}}} where name","page":"API Reference","title":"RustCall.rust_call_generated","text":"@generated function rust_call_generated(::Val{name}, args...) where {name}\n\nA generated function that emits a typed call for registered Rust functions. The function name is encoded as a type parameter for compile-time dispatch.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.rust_impl-Tuple{Any, Any, Any}","page":"API Reference","title":"RustCall.rust_impl","text":"rust_impl(mod, expr, source)\n\nImplementation of the @rust macro.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.rust_impl_call-NTuple{4, Any}","page":"API Reference","title":"RustCall.rust_impl_call","text":"rust_impl_call(mod, expr, ret_type, source)\n\nHandle a simple function call.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.rust_impl_qualified-NTuple{5, Any}","page":"API Reference","title":"RustCall.rust_impl_qualified","text":"rust_impl_qualified(mod, lib_name, call_expr, ret_type, source)\n\nHandle a library-qualified function call: lib::func(args...)\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.rust_impl_with_type-NTuple{4, Any}","page":"API Reference","title":"RustCall.rust_impl_with_type","text":"rust_impl_with_type(mod, call_expr, ret_type, source)\n\nHandle a function call with explicit return type.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.rust_to_julia_type_sym-Tuple{String}","page":"API Reference","title":"RustCall.rust_to_julia_type_sym","text":"rust_to_julia_type_sym(rust_type::String) -> Symbol\n\nMap Rust type strings to Julia type symbols for code generation.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.safe_dlsym-Tuple{Ptr{Nothing}, Symbol}","page":"API Reference","title":"RustCall.safe_dlsym","text":"safe_dlsym(lib::Ptr{Cvoid}, sym::Symbol) -> Ptr{Cvoid}\n\nLook up a symbol in a shared library, raising a clear error instead of returning NULL (which would cause a segfault when passed to ccall).\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.save_cache_metadata-Tuple{String, RustCall.CacheMetadata}","page":"API Reference","title":"RustCall.save_cache_metadata","text":"save_cache_metadata(cache_key::String, metadata::CacheMetadata)\n\nSave cache metadata to a JSON file.\n\nArguments\n\ncache_key::String: The cache key identifying the cached library\nmetadata::CacheMetadata: Metadata to save\n\nExample\n\nmetadata = CacheMetadata(\n    cache_key=\"abc123...\",\n    code_hash=0x1234...,\n    compiler_config=\"2_false_x86_64-unknown-linux-gnu\",\n    target_triple=\"x86_64-unknown-linux-gnu\",\n    created_at=now(),\n    functions=[\"add\", \"multiply\"]\n)\nsave_cache_metadata(\"abc123...\", metadata)\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.save_cached_library-Tuple{String, String, RustCall.CacheMetadata}","page":"API Reference","title":"RustCall.save_cached_library","text":"save_cached_library(cache_key::String, lib_path::String, metadata::CacheMetadata)\n\nSave a compiled library to the cache along with its metadata.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.save_cached_llvm_ir-Tuple{String, String}","page":"API Reference","title":"RustCall.save_cached_llvm_ir","text":"save_cached_llvm_ir(cache_key::String, ir_path::String)\n\nSave a compiled LLVM IR file to the cache.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.save_cargo_cached_library-Tuple{String, String}","page":"API Reference","title":"RustCall.save_cargo_cached_library","text":"save_cargo_cached_library(cache_key::String, lib_path::String)\n\nSave a compiled library to the Cargo cache.\n\nArguments\n\ncache_key::String: Cache key\nlib_path::String: Path to the compiled library\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.snake_to_pascal-Tuple{AbstractString}","page":"API Reference","title":"RustCall.snake_to_pascal","text":"snake_to_pascal(s::AbstractString) -> String\n\nConvert a snakecase or kebab-case string to PascalCase (CamelCase). Handles both underscore (`) and hyphen (-`) as separators.\n\nExamples\n\njulia> snake_to_pascal(\"sample_crate\")\n\"SampleCrate\"\n\njulia> snake_to_pascal(\"my_rust_lib\")\n\"MyRustLib\"\n\njulia> snake_to_pascal(\"sample-rs\")\n\"SampleRs\"\n\njulia> snake_to_pascal(\"my-rust-lib\")\n\"MyRustLib\"\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.split_cargo_deps-Tuple{String}","page":"API Reference","title":"RustCall.split_cargo_deps","text":"split_cargo_deps(line::String) -> Vector{String}\n\nSplit cargo-deps line by commas, respecting braces and quotes.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.start_watch_task-Tuple{HotReloadState}","page":"API Reference","title":"RustCall.start_watch_task","text":"start_watch_task(state::HotReloadState; interval::Float64=1.0)\n\nStart a background task that watches for file changes.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.stop_watch_task-Tuple{HotReloadState}","page":"API Reference","title":"RustCall.stop_watch_task","text":"stop_watch_task(state::HotReloadState)\n\nStop the file watching task for a crate.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.transform_julia_attribute-Tuple{String}","page":"API Reference","title":"RustCall.transform_julia_attribute","text":"transform_julia_attribute(code::String) -> String\n\nTransform #[julia] attributes in Rust code:\n\nFor functions: #[julia] fn → #[no_mangle] pub extern \"C\" fn\nFor structs: #[julia] pub struct → #[derive(JuliaStruct)] pub struct\n\nExample\n\nInput:\n\n#[julia]\nfn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n#[julia]\npub struct Point {\n    x: f64,\n    y: f64,\n}\n\nOutput:\n\n#[no_mangle]\npub extern \"C\" fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n#[derive(JuliaStruct)]\npub struct Point {\n    x: f64,\n    y: f64,\n}\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.try_load_rust_helpers-Tuple{}","page":"API Reference","title":"RustCall.try_load_rust_helpers","text":"try_load_rust_helpers() -> Bool\n\nTry to load the Rust helpers library. Returns true if successful, false otherwise. This function will not throw errors, making it safe to call during module initialization.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.unload_all_libraries-Tuple{}","page":"API Reference","title":"RustCall.unload_all_libraries","text":"unload_all_libraries()\n\nUnload all loaded Rust libraries.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.unload_library-Tuple{String}","page":"API Reference","title":"RustCall.unload_library","text":"unload_library(lib_name::String)\n\nUnload a Rust library and free its resources.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.validate_dependencies-Tuple{Vector{DependencySpec}}","page":"API Reference","title":"RustCall.validate_dependencies","text":"validate_dependencies(deps::Vector{DependencySpec})\n\nValidate that all dependencies have valid specifications.\n\nChecks\n\nEach dependency has a name\nEach dependency has at least one of: version, git, path\nNo duplicate names (use merge_dependencies first)\n\nThrows\n\nDependencyResolutionError if validation fails\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.validate_version_format-Tuple{String, String}","page":"API Reference","title":"RustCall.validate_version_format","text":"validate_version_format(version::String, name::String)\n\nValidate that a version string is well-formed.\n\nValid formats\n\n\"1.0\"\n\"1.0.5\"\n\"^1.0\"\n\"~1.0.5\"\n\">=1.0, <2.0\"\n\"*\"\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.verify_module-Tuple{LLVM.Module}","page":"API Reference","title":"RustCall.verify_module","text":"verify_module(mod::LLVM.Module) -> Bool\n\nVerify that an LLVM module is well-formed.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.verify_rust_helpers_functions-Tuple{Ptr{Nothing}}","page":"API Reference","title":"RustCall.verify_rust_helpers_functions","text":"verify_rust_helpers_functions(lib::Ptr{Cvoid}) -> Bool\n\nVerify that required functions are available in the loaded library. Returns true if all required functions are found, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.version_specificity-Tuple{String}","page":"API Reference","title":"RustCall.version_specificity","text":"version_specificity(version::String) -> Int\n\nCalculate a specificity score for a version string. Higher score = more specific.\n\nExamples\n\n\"1\" -> 1\n\"1.0\" -> 2\n\"1.0.5\" -> 3\n\"1.0.5-beta\" -> 4\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.write_rust_code_to_project-Tuple{CargoProject, String}","page":"API Reference","title":"RustCall.write_rust_code_to_project","text":"write_rust_code_to_project(project::CargoProject, code::String)\n\nWrite Rust code to the project's src/lib.rs, removing dependency comments.\n\nArguments\n\nproject::CargoProject: The Cargo project\ncode::String: Rust source code (may contain dependency comments)\n\n\n\n\n\n","category":"method"},{"location":"api/#RustCall.@rust_ccall-Tuple{Any, Any, Any, Vararg{Any}}","page":"API Reference","title":"RustCall.@rust_ccall","text":"@rust_ccall(func_name, ret_type, arg_types, args...)\n\nLow-level macro for calling a Rust function with explicit types.\n\nExample\n\n@rust_ccall(add, Int32, (Int32, Int32), 10, 20)\n\n\n\n\n\n","category":"macro"},{"location":"api/#RustCall.@rust_crate_static-Tuple{Any, Any}","page":"API Reference","title":"RustCall.@rust_crate_static","text":"@rust_crate_static(lib_path, module_name)\n\nLoad a pre-generated Rust crate binding with a specific library path.\n\nThis macro is for loading bindings that were generated with write_bindings_to_file where the library was placed at a known location.\n\nArguments\n\nlib_path: Path to the compiled shared library\nmodule_name: Name of the module to create\n\nExample\n\n# In a precompiled package\nconst _RUST_LIB = joinpath(@__DIR__, \"..\", \"deps\", \"libmycrate.so\")\n@rust_crate_static _RUST_LIB MyCrate\n\n\n\n\n\n","category":"macro"},{"location":"api/#RustCall.@rust_register-Tuple{Any, Any, Vararg{Any}}","page":"API Reference","title":"RustCall.@rust_register","text":"@rust_register(func_name, ret_type, arg_types...)\n\nRegister a Rust function with its type signature for optimized calling.\n\nExample\n\n@rust_register(add, Int32, Int32, Int32)\n\n\n\n\n\n","category":"macro"},{"location":"platforms/windows/#Windows-Platform-Guide","page":"Windows","title":"Windows Platform Guide","text":"This guide covers Windows-specific setup, configuration, and troubleshooting for RustCall.jl.","category":"section"},{"location":"platforms/windows/#Prerequisites","page":"Windows","title":"Prerequisites","text":"","category":"section"},{"location":"platforms/windows/#Rust-Installation","page":"Windows","title":"Rust Installation","text":"Download and run rustup-init.exe from rustup.rs\nChoose installation options:\nSelect \"Proceed with installation (default)\" for MSVC toolchain\nOr customize if you need MinGW\nVerify installation:\nrustc --version\ncargo --version","category":"section"},{"location":"platforms/windows/#Visual-Studio-Build-Tools","page":"Windows","title":"Visual Studio Build Tools","text":"The default MSVC toolchain requires Visual Studio Build Tools:\n\nDownload Visual Studio Build Tools\nIn the installer, select:\n\"Desktop development with C++\"\nWindows 10/11 SDK\nMSVC v143 (or latest) build tools\nAlternatively, install via winget:\nwinget install Microsoft.VisualStudio.2022.BuildTools","category":"section"},{"location":"platforms/windows/#Julia-Installation","page":"Windows","title":"Julia Installation","text":"Download Julia from julialang.org\nUse the Windows installer (.exe)\nEnsure \"Add Julia to PATH\" is checked during installation","category":"section"},{"location":"platforms/windows/#PATH-Configuration","page":"Windows","title":"PATH Configuration","text":"","category":"section"},{"location":"platforms/windows/#Automatic-Configuration-(Recommended)","page":"Windows","title":"Automatic Configuration (Recommended)","text":"Rustup automatically adds Cargo to your PATH. Verify:\n\n# Check Rust tools are accessible\nwhere.exe rustc\nwhere.exe cargo","category":"section"},{"location":"platforms/windows/#Manual-PATH-Configuration","page":"Windows","title":"Manual PATH Configuration","text":"If Rust tools are not found, add to PATH manually:\n\nOpen \"Environment Variables\" (search in Start menu)\nUnder \"User variables\", edit \"Path\"\nAdd: %USERPROFILE%\\.cargo\\bin\n\nOr via PowerShell (requires restart):\n\n[Environment]::SetEnvironmentVariable(\n    \"Path\",\n    [Environment]::GetEnvironmentVariable(\"Path\", \"User\") + \";$env:USERPROFILE\\.cargo\\bin\",\n    \"User\"\n)","category":"section"},{"location":"platforms/windows/#Toolchain-Selection","page":"Windows","title":"Toolchain Selection","text":"","category":"section"},{"location":"platforms/windows/#MSVC-Toolchain-(Default,-Recommended)","page":"Windows","title":"MSVC Toolchain (Default, Recommended)","text":"The MSVC (Microsoft Visual C++) toolchain is the default on Windows:\n\n# Check current toolchain\nrustup show\n\n# Ensure MSVC is default\nrustup default stable-x86_64-pc-windows-msvc\n\nAdvantages:\n\nNative Windows ABI compatibility\nBetter integration with Windows libraries\nRequired for some Windows-specific crates\n\nRequirements:\n\nVisual Studio Build Tools (or full Visual Studio)\nWindows SDK","category":"section"},{"location":"platforms/windows/#MinGW-Toolchain-(Alternative)","page":"Windows","title":"MinGW Toolchain (Alternative)","text":"MinGW uses GCC instead of MSVC:\n\n# Install MinGW toolchain\nrustup target add x86_64-pc-windows-gnu\n\n# Use for a specific build\nrustup run stable-x86_64-pc-windows-gnu cargo build\n\nAdvantages:\n\nSmaller installation (no Visual Studio needed)\nSimpler setup\nCross-compilation friendly\n\nDisadvantages:\n\nPotential ABI incompatibility with some libraries\nLess common in Windows ecosystem","category":"section"},{"location":"platforms/windows/#When-to-Use-Which","page":"Windows","title":"When to Use Which","text":"Scenario Recommended Toolchain\nGeneral development MSVC\nLinking with Windows DLLs MSVC\nMinimal installation MinGW\nCross-compiling from Linux MinGW\nCI/CD with limited resources MinGW","category":"section"},{"location":"platforms/windows/#Terminal-Options","page":"Windows","title":"Terminal Options","text":"","category":"section"},{"location":"platforms/windows/#PowerShell-(Recommended)","page":"Windows","title":"PowerShell (Recommended)","text":"PowerShell is the recommended terminal for RustCall.jl development:\n\n# Run Julia with debug logging\n$env:JULIA_DEBUG = \"RustCall\"\njulia --project","category":"section"},{"location":"platforms/windows/#Command-Prompt-(CMD)","page":"Windows","title":"Command Prompt (CMD)","text":"Also works, but with different syntax:\n\nset JULIA_DEBUG=RustCall\njulia --project","category":"section"},{"location":"platforms/windows/#Windows-Terminal","page":"Windows","title":"Windows Terminal","text":"Modern terminal with better features:\n\nMultiple tabs\nBetter Unicode support\nCustomizable","category":"section"},{"location":"platforms/windows/#WSL-(Windows-Subsystem-for-Linux)","page":"Windows","title":"WSL (Windows Subsystem for Linux)","text":"WSL2 works well but is a separate Linux environment:\n\n# In WSL2 - uses Linux toolchain, not Windows\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\njulia --project\n\nwarning: WSL vs Native Windows\nWSL is a Linux environment. Libraries compiled in WSL won't work with native Windows Julia and vice versa. Choose one environment and stick with it.","category":"section"},{"location":"platforms/windows/#Common-Issues-and-Solutions","page":"Windows","title":"Common Issues and Solutions","text":"","category":"section"},{"location":"platforms/windows/#Error:-\"link.exe-not-found\"","page":"Windows","title":"Error: \"link.exe not found\"","text":"Cause: Visual Studio Build Tools not installed or not in PATH.\n\nSolution:\n\nInstall Visual Studio Build Tools (see Prerequisites)\nOr run from Developer Command Prompt:\nSearch \"Developer Command Prompt for VS 2022\"\nRun Julia from there\nCheck Build Tools installation:\n# Should show Visual Studio installation\n& \"${env:ProgramFiles(x86)}\\Microsoft Visual Studio\\Installer\\vswhere.exe\" -products *","category":"section"},{"location":"platforms/windows/#Error:-\"Windows-SDK-not-found\"","page":"Windows","title":"Error: \"Windows SDK not found\"","text":"Cause: Windows SDK component not installed.\n\nSolution:\n\nRun Visual Studio Installer\nModify your Build Tools installation\nEnsure \"Windows 10 SDK\" or \"Windows 11 SDK\" is checked","category":"section"},{"location":"platforms/windows/#Error:-DLL-Loading-Failures","page":"Windows","title":"Error: DLL Loading Failures","text":"Symptoms:\n\ncould not load library \"...\"\nThe specified module could not be found.\n\nSolutions:\n\nCheck DLL location: Ensure the compiled library is in the expected path\n# Debug: Check library path\nusing RustCall\nlib_path = joinpath(RustCall.CACHE_DIR, \"...\")\n@info \"Library exists?\" isfile(lib_path)\nCheck dependencies: Use dumpbin to verify dependencies\ndumpbin /dependents path\\to\\library.dll\nAdd to PATH: If DLL depends on other DLLs\n$env:PATH += \";C:\\path\\to\\dlls\"","category":"section"},{"location":"platforms/windows/#Error:-Long-Path-Issues-(-260-characters)","page":"Windows","title":"Error: Long Path Issues (> 260 characters)","text":"Cause: Windows default path limit is 260 characters.\n\nSolutions:\n\nEnable long paths (Windows 10 1607+):\n# Run as Administrator\nNew-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\FileSystem\" `\n    -Name \"LongPathsEnabled\" -Value 1 -PropertyType DWORD -Force\nUse shorter paths: Move project closer to root\n# Instead of: C:\\Users\\Username\\Documents\\Projects\\MyProject\\...\n# Use: C:\\Dev\\MyProject\\...\nConfigure Cargo home:\n$env:CARGO_HOME = \"C:\\cargo\"","category":"section"},{"location":"platforms/windows/#Error:-Unicode/Encoding-Issues","page":"Windows","title":"Error: Unicode/Encoding Issues","text":"Symptoms: Build errors with non-ASCII characters in paths or source files.\n\nSolutions:\n\nUse ASCII-only paths: Avoid Unicode characters in project paths\nSet console encoding:\n[Console]::OutputEncoding = [System.Text.Encoding]::UTF8\nchcp 65001\nConfigure Git for line endings:\ngit config --global core.autocrlf true","category":"section"},{"location":"platforms/windows/#Error:-Antivirus-Interference","page":"Windows","title":"Error: Antivirus Interference","text":"Symptoms: Random build failures, slow compilation, \"access denied\" errors.\n\nSolutions:\n\nAdd exclusions for:\n%USERPROFILE%\\.cargo\n%USERPROFILE%\\.julia\nYour project directory\nWindows Defender exclusions (PowerShell as Admin):\nAdd-MpPreference -ExclusionPath \"$env:USERPROFILE\\.cargo\"\nAdd-MpPreference -ExclusionPath \"$env:USERPROFILE\\.julia\"","category":"section"},{"location":"platforms/windows/#CI/CD-Configuration","page":"Windows","title":"CI/CD Configuration","text":"","category":"section"},{"location":"platforms/windows/#GitHub-Actions","page":"Windows","title":"GitHub Actions","text":"RustCall.jl's CI already includes Windows testing:\n\ntest:\n  runs-on: ${{ matrix.os }}\n  strategy:\n    matrix:\n      os:\n        - ubuntu-latest\n        - windows-latest\n  steps:\n    - uses: actions/checkout@v6\n    - uses: julia-actions/setup-julia@v2\n    - uses: julia-actions/julia-buildpkg@v1\n    - uses: julia-actions/julia-runtest@v1","category":"section"},{"location":"platforms/windows/#Caching-for-Windows-Builds","page":"Windows","title":"Caching for Windows Builds","text":"Add Rust caching to speed up Windows CI:\n\n- name: Cache Cargo\n  uses: actions/cache@v4\n  with:\n    path: |\n      ~/.cargo/bin/\n      ~/.cargo/registry/index/\n      ~/.cargo/registry/cache/\n      ~/.cargo/git/db/\n    key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n\n- name: Cache Julia artifacts\n  uses: julia-actions/cache@v2","category":"section"},{"location":"platforms/windows/#Windows-Specific-CI-Tips","page":"Windows","title":"Windows-Specific CI Tips","text":"Path separators: Use / in YAML (works on Windows too)\nShell selection: GitHub Actions uses PowerShell by default on Windows\nLine endings: Configure Git to handle CRLF/LF","category":"section"},{"location":"platforms/windows/#Best-Practices","page":"Windows","title":"Best Practices","text":"","category":"section"},{"location":"platforms/windows/#1.-Use-PowerShell","page":"Windows","title":"1. Use PowerShell","text":"PowerShell provides better scripting and Unicode support than CMD.","category":"section"},{"location":"platforms/windows/#2.-Keep-Paths-Short","page":"Windows","title":"2. Keep Paths Short","text":"Windows path limits can cause issues. Keep project paths under 100 characters.","category":"section"},{"location":"platforms/windows/#3.-Regular-Updates","page":"Windows","title":"3. Regular Updates","text":"Keep tools updated to avoid compatibility issues:\n\nrustup update\njulia -e 'using Pkg; Pkg.update()'","category":"section"},{"location":"platforms/windows/#4.-Use-Native-Tools","page":"Windows","title":"4. Use Native Tools","text":"Prefer native Windows tools over WSL for Windows-targeted development.","category":"section"},{"location":"platforms/windows/#5.-Configure-Antivirus-Exclusions","page":"Windows","title":"5. Configure Antivirus Exclusions","text":"Add development directories to antivirus exclusions for better performance.","category":"section"},{"location":"platforms/windows/#Quick-Reference","page":"Windows","title":"Quick Reference","text":"","category":"section"},{"location":"platforms/windows/#Essential-Commands","page":"Windows","title":"Essential Commands","text":"# Check Rust installation\nrustc --version\ncargo --version\n\n# Check toolchain\nrustup show\n\n# Update Rust\nrustup update\n\n# Clean Cargo cache\ncargo clean\n\n# Julia with debug logging\n$env:JULIA_DEBUG = \"RustCall\"; julia --project","category":"section"},{"location":"platforms/windows/#Common-Paths","page":"Windows","title":"Common Paths","text":"Path Description\n%USERPROFILE%\\.cargo Cargo home directory\n%USERPROFILE%\\.julia Julia depot\n%USERPROFILE%\\.rustup Rustup toolchains\n%LOCALAPPDATA%\\Temp Temporary files","category":"section"},{"location":"platforms/windows/#Environment-Variables","page":"Windows","title":"Environment Variables","text":"Variable Purpose\nCARGO_HOME Override Cargo directory\nRUSTUP_HOME Override Rustup directory\nJULIA_DEBUG Enable Julia debug logging\nRUST_BACKTRACE Enable Rust backtraces","category":"section"},{"location":"platforms/windows/#See-Also","page":"Windows","title":"See Also","text":"Troubleshooting - General troubleshooting guide\nGetting Started - Basic usage tutorial\nRust Windows Installation - Official Rust documentation","category":"section"},{"location":"troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"This guide covers common issues and solutions when using RustCall.jl.","category":"section"},{"location":"troubleshooting/#Installation-and-Setup","page":"Troubleshooting","title":"Installation and Setup","text":"","category":"section"},{"location":"troubleshooting/#Problem:-rustc-not-found","page":"Troubleshooting","title":"Problem: rustc not found","text":"Error message:\n\nrustc not found in PATH. RustCall.jl requires Rust to be installed.\n\nSolution:\n\nCheck if Rust is installed:\nrustc --version\nIf Rust is not installed:\nInstall from rustup.rs\nOr use a package manager:\n# macOS\nbrew install rust\n\n# Ubuntu/Debian\nsudo apt-get install rustc cargo\nEnsure it's in PATH:\necho $PATH | grep rust","category":"section"},{"location":"troubleshooting/#Problem:-Rust-helpers-library-build-fails","page":"Troubleshooting","title":"Problem: Rust helpers library build fails","text":"Error message:\n\nRust helpers library not found. Ownership types (Box, Rc, Arc) will not work...\n\nSolution:\n\nRun the build:\nusing Pkg\nPkg.build(\"RustCall\")\nCheck Cargo availability:\ncargo --version\nCheck build log:\ncat deps/build.log\nManual build:\ncd deps/rust_helpers\ncargo build --release","category":"section"},{"location":"troubleshooting/#Compilation-Errors","page":"Troubleshooting","title":"Compilation Errors","text":"","category":"section"},{"location":"troubleshooting/#Problem:-Rust-code-syntax-errors","page":"Troubleshooting","title":"Problem: Rust code syntax errors","text":"Error message:\n\nerror: expected one of ...\n\nSolution:\n\nCheck Rust code syntax:\nHas #[no_mangle] attribute\nCorrectly specifies pub extern \"C\"\nFunction signature is correct\nCorrect example:\n#[no_mangle]\npub extern \"C\" fn my_function(x: i32) -> i32 {\n    x * 2\n}\nCheck error message in detail:\n# Clear cache and recompile\nclear_cache()\nrust\"\"\"\n// Fixed code\n\"\"\"","category":"section"},{"location":"troubleshooting/#Problem:-Linking-errors","page":"Troubleshooting","title":"Problem: Linking errors","text":"Error message:\n\nundefined symbol: ...\n\nSolution:\n\nCheck function name is correct (#[no_mangle] required)\nVerify library is loaded correctly\nCheck platform-specific issues:\nmacOS: .dylib file exists\nLinux: .so file exists\nWindows: .dll file exists","category":"section"},{"location":"troubleshooting/#Problem:-Type-mismatch-errors","page":"Troubleshooting","title":"Problem: Type mismatch errors","text":"Error message:\n\nERROR: type mismatch\n\nSolution:\n\nCheck Rust function signature:\npub extern \"C\" fn add(a: i32, b: i32) -> i32\nUse correct types on Julia side:\n# Correct\n# @rust add(Int32(10), Int32(20))::Int32\nReview the type mapping table","category":"section"},{"location":"troubleshooting/#Runtime-Errors","page":"Troubleshooting","title":"Runtime Errors","text":"","category":"section"},{"location":"troubleshooting/#Problem:-Function-not-found","page":"Troubleshooting","title":"Problem: Function not found","text":"Error message:\n\nFunction 'my_function' not found in library\n\nSolution:\n\nCheck function name spelling\nEnsure #[no_mangle] attribute is present\nVerify library compiled correctly:\nclear_cache()\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn my_test_function() -> i32 { 42 }\n\"\"\"","category":"section"},{"location":"troubleshooting/#Problem:-Segmentation-fault","page":"Troubleshooting","title":"Problem: Segmentation fault","text":"Error message:\n\nsignal (11): Segmentation fault\n\nSolution:\n\nCheck pointer validity:\n# Warning: Don't use invalid or Julia-managed pointers with Rust ownership types\nCheck array bounds\nCheck memory management (if using ownership types)","category":"section"},{"location":"troubleshooting/#FAQ","page":"Troubleshooting","title":"FAQ","text":"","category":"section"},{"location":"troubleshooting/#Q:-Can-I-use-multiple-Rust-libraries-simultaneously?","page":"Troubleshooting","title":"Q: Can I use multiple Rust libraries simultaneously?","text":"A: Yes. You can define multiple functions in a single rust\"\" block or use multiple blocks:\n\n# Multiple functions in one block\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn calc_add(a: i32, b: i32) -> i32 { a + b }\n\n#[no_mangle]\npub extern \"C\" fn calc_mul(a: i32, b: i32) -> i32 { a * b }\n\"\"\"\n\nresult1 = @rust calc_add(Int32(10), Int32(20))::Int32\nresult2 = @rust calc_mul(Int32(3), Int32(4))::Int32\nprintln(\"add result = $result1, mul result = $result2\")\n\nnote: Function Name Uniqueness\nUse unique function names across all rust\"\" blocks. If the same function name exists in multiple libraries, an ambiguity error will be raised.","category":"section"},{"location":"troubleshooting/#Q:-Can-I-use-Rust-generics?","page":"Troubleshooting","title":"Q: Can I use Rust generics?","text":"A: Yes, with automatic monomorphization. See Generics for details.","category":"section"},{"location":"troubleshooting/#Q:-Best-practices-for-error-handling?","page":"Troubleshooting","title":"Q: Best practices for error handling?","text":"A:\n\nUse Result type on Rust side\nUse result_to_exception on Julia side\nOr use unwrap_or for default values","category":"section"},{"location":"troubleshooting/#Debugging-Tips","page":"Troubleshooting","title":"Debugging Tips","text":"","category":"section"},{"location":"troubleshooting/#1.-Enable-debug-logging","page":"Troubleshooting","title":"1. Enable debug logging","text":"RustCall.jl uses Julia's built-in Logging module with @debug, @info, @warn, and @error macros.\n\nOption A: Environment variable (recommended)\n\nRun Julia with the JULIA_DEBUG environment variable:\n\nJULIA_DEBUG=RustCall julia -e 'using RustCall; ...'\n\nOr set it within Julia before loading RustCall:\n\nENV[\"JULIA_DEBUG\"] = \"RustCall\"\nusing RustCall\n\nOption B: Global logger\n\nusing Logging\nglobal_logger(ConsoleLogger(stderr, Logging.Debug))\nusing RustCall\n\nDebug logging shows detailed information about:\n\nRust code compilation\nLibrary loading and caching\nGeneric function registration and monomorphization\nFunction pointer resolution\nError recovery attempts","category":"section"},{"location":"troubleshooting/#2.-Clear-cache","page":"Troubleshooting","title":"2. Clear cache","text":"clear_cache()","category":"section"},{"location":"troubleshooting/#3.-Check-library-status","page":"Troubleshooting","title":"3. Check library status","text":"# List cached libraries\nlist_cached_libraries()\n\n# Check cache size\nget_cache_size()","category":"section"},{"location":"troubleshooting/#4.-Check-type-information","page":"Troubleshooting","title":"4. Check type information","text":"# Check type mapping\nrusttype_to_julia(:i32)  # => Int32\njuliatype_to_rust(Int32)  # => \"i32\"","category":"section"},{"location":"examples/#RustCall.jl-Examples","page":"Examples","title":"RustCall.jl Examples","text":"This document provides practical examples of using RustCall.jl.","category":"section"},{"location":"examples/#Table-of-Contents","page":"Examples","title":"Table of Contents","text":"Numerical Computations\nString Processing\nData Structures\nPerformance Comparison\nReal-world Examples\nBest Practices","category":"section"},{"location":"examples/#Numerical-Computations","page":"Examples","title":"Numerical Computations","text":"","category":"section"},{"location":"examples/#Basic-Math-Functions","page":"Examples","title":"Basic Math Functions","text":"rust\"\"\"\n#[julia]\nfn power(x: f64, n: i32) -> f64 {\n    let mut result = 1.0;\n    for _ in 0..n {\n        result *= x;\n    }\n    result\n}\n\"\"\"\n\n# Usage - wrapper auto-generated\nresult = power(2.0, 10)  # => 1024.0","category":"section"},{"location":"examples/#Fibonacci-Sequence","page":"Examples","title":"Fibonacci Sequence","text":"rust\"\"\"\n#[julia]\nfn fibonacci(n: u32) -> u64 {\n    if n <= 1 {\n        return n as u64;\n    }\n\n    let mut a = 0u64;\n    let mut b = 1u64;\n\n    for _ in 2..=n {\n        let temp = a + b;\n        a = b;\n        b = temp;\n    }\n\n    b\n}\n\"\"\"\n\n# Usage - wrapper auto-generated\nfib_10 = fibonacci(UInt32(10))  # => 55\nfib_20 = fibonacci(UInt32(20))  # => 6765","category":"section"},{"location":"examples/#Statistical-Calculations","page":"Examples","title":"Statistical Calculations","text":"rust\"\"\"\n#[no_mangle]\npub extern \"C\" fn calculate_mean(data: *const f64, len: usize) -> f64 {\n    let slice = unsafe { std::slice::from_raw_parts(data, len) };\n    let sum: f64 = slice.iter().sum();\n    sum / len as f64\n}\n\n#[no_mangle]\npub extern \"C\" fn calculate_variance(data: *const f64, len: usize, mean: f64) -> f64 {\n    let slice = unsafe { std::slice::from_raw_parts(data, len) };\n    let sum_sq_diff: f64 = slice.iter()\n        .map(|&x| (x - mean) * (x - mean))\n        .sum();\n    sum_sq_diff / len as f64\n}\n\"\"\"\n\n# Julia wrapper\nfunction compute_statistics(data::Vector{Float64})\n    len = length(data)\n    ptr = pointer(data)\n\n    mean = @rust calculate_mean(ptr, len)::Float64\n    variance = @rust calculate_variance(ptr, len, mean)::Float64\n\n    return (mean=mean, variance=variance, stddev=sqrt(variance))\nend\n\n# Usage\ndata = [1.0, 2.0, 3.0, 4.0, 5.0]\nstats = compute_statistics(data)\nprintln(\"Mean: $(stats.mean), StdDev: $(stats.stddev)\")","category":"section"},{"location":"examples/#String-Processing","page":"Examples","title":"String Processing","text":"","category":"section"},{"location":"examples/#String-Search-and-Replacement","page":"Examples","title":"String Search and Replacement","text":"rust\"\"\"\n#[no_mangle]\npub extern \"C\" fn find_substring(haystack: *const u8, needle: *const u8) -> i32 {\n    let haystack_str = unsafe {\n        std::ffi::CStr::from_ptr(haystack as *const i8)\n            .to_str()\n            .unwrap_or(\"\")\n    };\n    let needle_str = unsafe {\n        std::ffi::CStr::from_ptr(needle as *const i8)\n            .to_str()\n            .unwrap_or(\"\")\n    };\n\n    match haystack_str.find(needle_str) {\n        Some(pos) => pos as i32,\n        None => -1,\n    }\n}\n\"\"\"\n\n# Usage\npos = @rust find_substring(\"hello world\", \"world\")::Int32  # => 6\npos = @rust find_substring(\"hello world\", \"xyz\")::Int32    # => -1","category":"section"},{"location":"examples/#Word-Counting","page":"Examples","title":"Word Counting","text":"rust\"\"\"\n#[no_mangle]\npub extern \"C\" fn count_words(text: *const u8) -> u32 {\n    let text_str = unsafe {\n        std::ffi::CStr::from_ptr(text as *const i8)\n            .to_str()\n            .unwrap_or(\"\")\n    };\n\n    text_str.split_whitespace().count() as u32\n}\n\"\"\"\n\n# Usage\nword_count = @rust count_words(\"The quick brown fox\")::UInt32  # => 4","category":"section"},{"location":"examples/#UTF-8-String-Processing","page":"Examples","title":"UTF-8 String Processing","text":"rust\"\"\"\n#[no_mangle]\npub extern \"C\" fn count_utf8_chars(s: *const u8) -> u32 {\n    let c_str = unsafe { std::ffi::CStr::from_ptr(s as *const i8) };\n    let utf8_str = std::str::from_utf8(c_str.to_bytes()).unwrap_or(\"\");\n    utf8_str.chars().count() as u32\n}\n\n#[no_mangle]\npub extern \"C\" fn reverse_utf8_string(s: *const u8, output: *mut u8, len: usize) {\n    let c_str = unsafe { std::ffi::CStr::from_ptr(s as *const i8) };\n    let utf8_str = std::str::from_utf8(c_str.to_bytes()).unwrap_or(\"\");\n    let reversed: String = utf8_str.chars().rev().collect();\n\n    let output_slice = unsafe { std::slice::from_raw_parts_mut(output, len) };\n    let bytes = reversed.as_bytes();\n    let copy_len = bytes.len().min(len);\n    output_slice[..copy_len].copy_from_slice(&bytes[..copy_len]);\n}\n\"\"\"\n\n# Usage\nchar_count = @rust count_utf8_chars(\"こんにちは\")::UInt32  # => 5","category":"section"},{"location":"examples/#Data-Structures","page":"Examples","title":"Data Structures","text":"","category":"section"},{"location":"examples/#Array-Operations","page":"Examples","title":"Array Operations","text":"rust\"\"\"\n#[no_mangle]\npub extern \"C\" fn sum_array(data: *const i32, len: usize) -> i64 {\n    let slice = unsafe { std::slice::from_raw_parts(data, len) };\n    slice.iter().map(|&x| x as i64).sum()\n}\n\n#[no_mangle]\npub extern \"C\" fn max_element(data: *const i32, len: usize) -> i32 {\n    let slice = unsafe { std::slice::from_raw_parts(data, len) };\n    *slice.iter().max().unwrap_or(&0)\n}\n\"\"\"\n\n# Julia wrapper\nfunction process_array(data::Vector{Int32})\n    ptr = pointer(data)\n    len = length(data)\n\n    total = @rust sum_array(ptr, len)::Int64\n    maximum = @rust max_element(ptr, len)::Int32\n\n    return (sum=total, max=maximum)\nend\n\n# Usage\narr = Int32[1, 5, 3, 9, 2]\nresult = process_array(arr)\nprintln(\"Sum: $(result.sum), Max: $(result.max)\")","category":"section"},{"location":"examples/#In-place-Sorting","page":"Examples","title":"In-place Sorting","text":"rust\"\"\"\n#[no_mangle]\npub extern \"C\" fn sort_array(data: *mut i32, len: usize) {\n    let slice = unsafe { std::slice::from_raw_parts_mut(data, len) };\n    slice.sort();\n}\n\"\"\"\n\n# Julia wrapper\nfunction sort_in_place(arr::Vector{Int32})\n    ptr = pointer(arr)\n    len = length(arr)\n    @rust sort_array(ptr, len)::Cvoid\n    return arr\nend\n\n# Usage\narr = Int32[5, 2, 8, 1, 9]\nsort_in_place(arr)\nprintln(arr)  # => [1, 2, 5, 8, 9]","category":"section"},{"location":"examples/#Performance-Comparison","page":"Examples","title":"Performance Comparison","text":"","category":"section"},{"location":"examples/#Julia-vs-Rust:-Numerical-Computation","page":"Examples","title":"Julia vs Rust: Numerical Computation","text":"using BenchmarkTools\n\n# Rust implementation\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn rust_sum_range(n: u64) -> u64 {\n    (1..=n).sum()\n}\n\"\"\"\n\n# Julia implementation\nfunction julia_sum_range(n::UInt64)\n    sum = UInt64(0)\n    for i in 1:n\n        sum += i\n    end\n    return sum\nend\n\n# Benchmark\nn = UInt64(1_000_000)\n\nprintln(\"Julia native:\")\n@btime julia_sum_range($n)\n\nprintln(\"Rust (@rust):\")\n@btime @rust rust_sum_range($n)::UInt64","category":"section"},{"location":"examples/#String-Processing-Performance","page":"Examples","title":"String Processing Performance","text":"rust\"\"\"\n#[no_mangle]\npub extern \"C\" fn rust_count_words(text: *const u8) -> u32 {\n    let text_str = unsafe {\n        std::ffi::CStr::from_ptr(text as *const i8)\n            .to_str()\n            .unwrap_or(\"\")\n    };\n    text_str.split_whitespace().count() as u32\n}\n\"\"\"\n\nfunction julia_count_words(text::String)\n    return length(split(text))\nend\n\n# Benchmark\ntext = repeat(\"The quick brown fox jumps over the lazy dog. \", 1000)\n\nprintln(\"Julia native:\")\n@btime julia_count_words($text)\n\nprintln(\"Rust (@rust):\")\n@btime @rust rust_count_words($text)::UInt32","category":"section"},{"location":"examples/#Real-world-Examples","page":"Examples","title":"Real-world Examples","text":"","category":"section"},{"location":"examples/#Cryptographic-Hash-Calculation","page":"Examples","title":"Cryptographic Hash Calculation","text":"rust\"\"\"\nuse std::collections::hash_map::DefaultHasher;\nuse std::hash::{Hash, Hasher};\n\n#[no_mangle]\npub extern \"C\" fn calculate_hash(data: *const u8, len: usize) -> u64 {\n    let slice = unsafe { std::slice::from_raw_parts(data, len) };\n    let mut hasher = DefaultHasher::new();\n    slice.hash(&mut hasher);\n    hasher.finish()\n}\n\"\"\"\n\n# Usage\ndata = Vector{UInt8}(b\"hello world\")\nptr = pointer(data)\nhash_value = @rust calculate_hash(ptr, length(data))::UInt64\nprintln(\"Hash: $hash_value\")","category":"section"},{"location":"examples/#Image-Processing-(Simplified)","page":"Examples","title":"Image Processing (Simplified)","text":"This example demonstrates using Rust for image processing with visualization using Images.jl.\n\nusing RustCall\nusing Images\n\n# Define Rust grayscale conversion function\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn grayscale_image(\n    pixels: *mut u8,\n    width: usize,\n    height: usize\n) {\n    let total_pixels = width * height * 3;  // RGB\n    let slice = unsafe { std::slice::from_raw_parts_mut(pixels, total_pixels) };\n\n    for i in 0..(width * height) {\n        let r = slice[i * 3] as f32;\n        let g = slice[i * 3 + 1] as f32;\n        let b = slice[i * 3 + 2] as f32;\n\n        // Standard luminance formula (ITU-R BT.601)\n        let gray = (0.299 * r + 0.587 * g + 0.114 * b) as u8;\n\n        slice[i * 3] = gray;\n        slice[i * 3 + 1] = gray;\n        slice[i * 3 + 2] = gray;\n    }\n}\n\"\"\"\n\n# Julia wrapper for grayscale conversion\nfunction convert_to_grayscale!(pixels::Vector{UInt8}, width::Int, height::Int)\n    ptr = pointer(pixels)\n    @rust grayscale_image(ptr, UInt(width), UInt(height))::Cvoid\n    return pixels\nend\n\n# Create a sample RGB image (gradient with colors)\nfunction create_sample_image(width, height)\n    img = zeros(RGB{N0f8}, height, width)\n    for y in 1:height, x in 1:width\n        r = (x - 1) / (width - 1)    # Red increases left to right\n        g = (y - 1) / (height - 1)   # Green increases top to bottom\n        b = 0.5                       # Constant blue\n        img[y, x] = RGB{N0f8}(r, g, b)\n    end\n    return img\nend\n\n# Convert Julia image to raw RGB bytes (row-major, interleaved RGB)\nfunction image_to_bytes(img)\n    h, w = size(img)\n    pixels = Vector{UInt8}(undef, h * w * 3)\n    idx = 1\n    for y in 1:h, x in 1:w\n        pixel = img[y, x]\n        pixels[idx] = reinterpret(UInt8, red(pixel))\n        pixels[idx + 1] = reinterpret(UInt8, green(pixel))\n        pixels[idx + 2] = reinterpret(UInt8, blue(pixel))\n        idx += 3\n    end\n    return pixels\nend\n\n# Convert raw RGB bytes back to Julia image\nfunction bytes_to_image(pixels, width, height)\n    img = zeros(RGB{N0f8}, height, width)\n    idx = 1\n    for y in 1:height, x in 1:width\n        r = reinterpret(N0f8, pixels[idx])\n        g = reinterpret(N0f8, pixels[idx + 1])\n        b = reinterpret(N0f8, pixels[idx + 2])\n        img[y, x] = RGB{N0f8}(r, g, b)\n        idx += 3\n    end\n    return img\nend\n\n# Create sample image\nwidth, height = 256, 256\noriginal_img = create_sample_image(width, height)\nnothing # hide\n\nOriginal Image (Color Gradient):\n\noriginal_img\n\nNow let's convert it to grayscale using Rust:\n\n# Process the image with Rust\npixels = image_to_bytes(original_img)\nconvert_to_grayscale!(pixels, width, height)\ngrayscale_img = bytes_to_image(pixels, width, height)\nnothing # hide\n\nGrayscale Image (Processed by Rust):\n\ngrayscale_img\n\nLet's verify the grayscale conversion worked correctly:\n\n# Check that R, G, B are equal (grayscale property)\nsample_pixel = grayscale_img[128, 128]\nprintln(\"Sample pixel at (128, 128):\")\nprintln(\"  R = $(red(sample_pixel))\")\nprintln(\"  G = $(green(sample_pixel))\")\nprintln(\"  B = $(blue(sample_pixel))\")\nprintln(\"  Grayscale verified: \", red(sample_pixel) == green(sample_pixel) == blue(sample_pixel))\n\nSide-by-side comparison:\n\n# Create a side-by-side comparison image\ncomparison = [original_img grayscale_img]\n\nnote: Running this example\nTo run this example locally, you need the Images package:using Pkg\nPkg.add(\"Images\")For servedocs(), make sure to run it from the docs environment:julia --project=docs -e 'using Pkg; Pkg.instantiate()'\njulia --project=docs -e 'using LiveServer; servedocs()'","category":"section"},{"location":"examples/#Network-Processing-(Simplified)","page":"Examples","title":"Network Processing (Simplified)","text":"rust\"\"\"\n#[no_mangle]\npub extern \"C\" fn validate_ip_address(ip: *const u8) -> bool {\n    let ip_str = unsafe {\n        std::ffi::CStr::from_ptr(ip as *const i8)\n            .to_str()\n            .unwrap_or(\"\")\n    };\n\n    let parts: Vec<&str> = ip_str.split('.').collect();\n    if parts.len() != 4 {\n        return false;\n    }\n\n    for part in parts {\n        match part.parse::<u8>() {\n            Ok(num) if num <= 255 => continue,\n            _ => return false,\n        }\n    }\n\n    true\n}\n\"\"\"\n\n# Usage\nis_valid = @rust validate_ip_address(\"192.168.1.1\")::Bool  # => true\nis_valid = @rust validate_ip_address(\"999.999.999.999\")::Bool  # => false","category":"section"},{"location":"examples/#Data-Compression-(Simplified)","page":"Examples","title":"Data Compression (Simplified)","text":"rust\"\"\"\n#[no_mangle]\npub extern \"C\" fn simple_compress(\n    input: *const u8,\n    input_len: usize,\n    output: *mut u8,\n    output_capacity: usize\n) -> usize {\n    let input_slice = unsafe { std::slice::from_raw_parts(input, input_len) };\n    let output_slice = unsafe { std::slice::from_raw_parts_mut(output, output_capacity) };\n\n    let mut output_idx = 0;\n    let mut i = 0;\n\n    while i < input_len && output_idx + 1 < output_capacity {\n        let mut count = 1;\n        let current = input_slice[i];\n\n        // Count consecutive identical characters\n        while i + count < input_len && input_slice[i + count] == current && count < 255 {\n            count += 1;\n        }\n\n        if output_idx + 2 <= output_capacity {\n            output_slice[output_idx] = count as u8;\n            output_slice[output_idx + 1] = current;\n            output_idx += 2;\n        }\n\n        i += count;\n    }\n\n    output_idx\n}\n\"\"\"\n\n# Julia wrapper\nfunction compress_data(data::Vector{UInt8})\n    input_len = length(data)\n    output_capacity = input_len * 2  # Worst case\n    output = Vector{UInt8}(undef, output_capacity)\n\n    input_ptr = pointer(data)\n    output_ptr = pointer(output)\n\n    compressed_len = @rust simple_compress(\n        input_ptr, input_len,\n        output_ptr, output_capacity\n    )::UInt\n\n    return output[1:compressed_len]\nend\n\n# Usage\ndata = Vector{UInt8}(b\"aaabbbcccddd\")\ncompressed = compress_data(data)\nprintln(\"Original: $(length(data)) bytes\")\nprintln(\"Compressed: $(length(compressed)) bytes\")","category":"section"},{"location":"examples/#Best-Practices","page":"Examples","title":"Best Practices","text":"","category":"section"},{"location":"examples/#1.-Memory-Safety","page":"Examples","title":"1. Memory Safety","text":"When working with pointers, ensure Julia memory remains valid using GC.@preserve:\n\nusing RustCall\n\n# Define a Rust function that processes an array\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn sum_array(arr: *const i32, len: usize) -> i32 {\n    let slice = unsafe { std::slice::from_raw_parts(arr, len) };\n    slice.iter().sum()\n}\n\"\"\"\n\nfunction safe_array_sum(arr::Vector{Int32})\n    if isempty(arr)\n        return Int32(0)\n    end\n\n    ptr = pointer(arr)\n    len = length(arr)\n\n    # GC.@preserve ensures arr remains valid during Rust call\n    GC.@preserve arr begin\n        result = @rust sum_array(ptr, UInt(len))::Int32\n    end\n\n    return result\nend\n\n# Test the safe function\narr = Int32[1, 2, 3, 4, 5]\nresult = safe_array_sum(arr)\nprintln(\"Sum of $arr = $result\")  # => Sum of [1, 2, 3, 4, 5] = 15","category":"section"},{"location":"examples/#2.-Error-Handling","page":"Examples","title":"2. Error Handling","text":"Use error codes or Result types for safe error handling:\n\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn safe_divide(a: i32, b: i32, result: *mut i32) -> bool {\n    if b == 0 {\n        return false;  // Indicate error\n    }\n    unsafe { *result = a / b; }\n    true  // Indicate success\n}\n\"\"\"\n\nfunction divide_safely(a::Int32, b::Int32)\n    result = Ref{Int32}(0)\n    success = @rust safe_divide(a, b, result)::Bool\n    if !success\n        throw(DomainError(b, \"Division by zero\"))\n    end\n    return result[]\nend\n\n# Test successful division\ndivide_safely(Int32(10), Int32(2))  # => 5\n\n# Test error handling\ntry\n    divide_safely(Int32(10), Int32(0))\ncatch e\n    println(\"Caught error: $e\")  # => DomainError\nend","category":"section"},{"location":"examples/#3.-Performance-Optimization","page":"Examples","title":"3. Performance Optimization","text":"Benchmark to compare Julia and Rust performance:\n\nusing BenchmarkTools\n\n# Rust implementation for computing sum of squares\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn sum_of_squares_rust(arr: *const f64, len: usize) -> f64 {\n    let slice = unsafe { std::slice::from_raw_parts(arr, len) };\n    slice.iter().map(|x| x * x).sum()\n}\n\"\"\"\n\n# Julia implementation\nfunction sum_of_squares_julia(arr::Vector{Float64})\n    sum(x -> x * x, arr)\nend\n\n# Wrapper for Rust\nfunction sum_of_squares_rust_wrapper(arr::Vector{Float64})\n    GC.@preserve arr begin\n        @rust sum_of_squares_rust(pointer(arr), UInt(length(arr)))::Float64\n    end\nend\n\n# Benchmark\ndata = rand(10000)\n@btime sum_of_squares_julia($data)\n@btime sum_of_squares_rust_wrapper($data)\n\nPerformance tips:\n\nUse GC.@preserve for large arrays to prevent garbage collection during Rust calls\nConsider @rust_llvm for performance-critical code with LLVM optimizations\nLeverage caching to avoid recompilation (functions are cached automatically)\nAlways specify explicit types in @rust macro calls","category":"section"},{"location":"examples/#4.-Debugging","page":"Examples","title":"4. Debugging","text":"When issues occur, use these debugging techniques:\n\n# Check cache status\ncache_size = get_cache_size()\nprintln(\"Current cache size: $cache_size libraries\")\n\n# List cached libraries\ncached = list_cached_libraries()\nprintln(\"Cached libraries: $(length(cached)) items\")\n\n# Clear cache if needed\nclear_cache()\nprintln(\"Cache cleared\")","category":"section"},{"location":"examples/#5.-Type-Safety-with-Generics","page":"Examples","title":"5. Type Safety with Generics","text":"Use generics for type-safe, reusable code:\n\n# Register a generic identity function\ncode = \"\"\"\n#[no_mangle]\npub extern \"C\" fn identity<T>(x: T) -> T {\n    x\n}\n\"\"\"\n\nregister_generic_function(\"identity\", code, [:T])\n\n# Call with different types - automatic monomorphization\nresult_i32 = call_generic_function(\"identity\", Int32(42))  # => 42\nresult_f64 = call_generic_function(\"identity\", 3.14)       # => 3.14\n\nprintln(\"identity(Int32(42)) = $result_i32\")\nprintln(\"identity(3.14) = $result_f64\")","category":"section"},{"location":"examples/#Summary","page":"Examples","title":"Summary","text":"These examples demonstrate practical usage of RustCall.jl:\n\nMemory Safety: Always use GC.@preserve when passing Julia arrays to Rust\nError Handling: Use error codes or Result types instead of panics\nPerformance: Benchmark and optimize with explicit types\nDebugging: Use cache management functions to troubleshoot\nGenerics: Leverage automatic monomorphization for type-safe code\n\nFor more detailed information, see the Tutorial and API Reference.","category":"section"},{"location":"design/INTERNAL/#Cxx.jl-Internal-Implementation-Details","page":"Internal","title":"Cxx.jl Internal Implementation Details","text":"This document explains in detail how C++ code is processed and integrated with Julia.","category":"section"},{"location":"design/INTERNAL/#Table-of-Contents","page":"Internal","title":"Table of Contents","text":"Architecture Overview\nProcessing Flow\nMacro Processing (@cxx)\nString Literals (cxx\"\" and icxx\"\")\nType System\nCode Generation Process\nClang Integration\nLLVM IR Integration\n\n","category":"section"},{"location":"design/INTERNAL/#Architecture-Overview","page":"Internal","title":"Architecture Overview","text":"Cxx.jl consists of three main components:\n\nJulia-side macros and staged functions: Parse Julia syntax and extract type information\nClang integration: Parse C++ code and generate AST (Abstract Syntax Tree)\nLLVM integration: Generate LLVM IR from Clang AST and embed it into Julia's llvmcall","category":"section"},{"location":"design/INTERNAL/#Data-Flow","page":"Internal","title":"Data Flow","text":"Julia code (@cxx macro)\n    ↓\nSyntax parsing and type information extraction (cxxmacro.jl)\n    ↓\nStaged function (@generated)\n    ↓\nClang AST generation (codegen.jl)\n    ↓\nLLVM IR generation (Clang CodeGen)\n    ↓\nllvmcall embedding\n    ↓\nJulia runtime execution\n\n","category":"section"},{"location":"design/INTERNAL/#Processing-Flow","page":"Internal","title":"Processing Flow","text":"","category":"section"},{"location":"design/INTERNAL/#1.-Macro-Expansion-Stage","page":"Internal","title":"1. Macro Expansion Stage","text":"When a user writes @cxx foo::bar(args...):\n\n# cxxmacro.jl's cpps_impl function processes it\n@cxx foo::bar(args...)\n    ↓\n# Parse syntax and extract namespace and function name\nStored as CppNNS{(:foo, :bar)} in type parameters\n    ↓\n# Generate expression calling staged function cppcall\ncppcall(__current_compiler__, CppNNS{(:foo, :bar)}(), args...)","category":"section"},{"location":"design/INTERNAL/#2.-Staged-Function-Execution-Stage","page":"Internal","title":"2. Staged Function Execution Stage","text":"@generated functions execute at compile time and generate code based on type information:\n\n@generated function cppcall(CT::CxxInstance, expr, args...)\n    # CT: Compiler instance\n    # expr: CppNNS{(:foo, :bar)} type\n    # args: Argument type information\n\n    C = instance(CT)  # Get Clang instance\n\n    # 1. Type checking\n    check_args(argt, expr)\n\n    # 2. Build Clang AST\n    callargs, pvds = buildargexprs(C, argt)\n    d = declfornns(C, expr)  # Name resolution\n\n    # 3. Generate call expression\n    ce = CreateCallExpr(C, dne, callargs)\n\n    # 4. Generate LLVM IR and embed into llvmcall\n    EmitExpr(C, ce, ...)\nend","category":"section"},{"location":"design/INTERNAL/#3.-Clang-AST-Generation","page":"Internal","title":"3. Clang AST Generation","text":"The buildargexprs function converts Julia arguments to Clang AST nodes:\n\nfunction buildargexprs(C, argt; derefval = true)\n    callargs = pcpp\"clang::Expr\"[]\n    pvds = pcpp\"clang::ParmVarDecl\"[]\n\n    for i in 1:length(argt)\n        t = argt[i]\n        st = stripmodifier(t)  # Remove modifiers\n\n        # Get Clang type\n        argit = cpptype(C, st)\n\n        # Create ParmVarDecl (function parameter declaration)\n        argpvd = CreateParmVarDecl(C, argit)\n        push!(pvds, argpvd)\n\n        # Create DeclRefExpr (variable reference)\n        expr = CreateDeclRefExpr(C, argpvd)\n\n        # Apply modifiers (*, &, etc.)\n        expr = resolvemodifier(C, t, expr)\n        push!(callargs, expr)\n    end\n\n    callargs, pvds\nend","category":"section"},{"location":"design/INTERNAL/#4.-LLVM-IR-Generation-and-Embedding","page":"Internal","title":"4. LLVM IR Generation and Embedding","text":"The EmitExpr function generates LLVM IR from Clang AST and embeds it into Julia's llvmcall:\n\nfunction EmitExpr(C, ce, nE, ctce, argt, pvds, rett = Cvoid)\n    # 1. Create LLVM function\n    f = CreateFunctionWithPersonality(C, llvmrt, map(julia_to_llvm, llvmargt))\n\n    # 2. Setup Clang code generation environment\n    state = setup_cpp_env(C, f)\n    builder = irbuilder(C)\n\n    # 3. Process LLVM arguments\n    args = llvmargs(C, builder, f, llvmargt)\n\n    # 4. Associate Clang AST with LLVM values\n    associateargs(C, builder, argt, args, pvds)\n\n    # 5. Compile Clang AST to LLVM IR\n    ret = EmitCallExpr(C, ce, rslot)\n\n    # 6. Generate llvmcall expression\n    createReturn(C, builder, f, argt, llvmargt, llvmrt, rett, rt, ret, state)\nend\n\nFinally, an llvmcall expression like the following is generated:\n\nExpr(:call, Core.Intrinsics.llvmcall,\n    convert(Ptr{Cvoid}, f),  # Pointer to LLVM function\n    rett,                    # Return type\n    Tuple{argt...},         # Argument types\n    args2...)               # Actual arguments\n\n","category":"section"},{"location":"design/INTERNAL/#Macro-Processing-(@cxx)","page":"Internal","title":"Macro Processing (@cxx)","text":"","category":"section"},{"location":"design/INTERNAL/#Syntax-Parsing","page":"Internal","title":"Syntax Parsing","text":"The cpps_impl function in cxxmacro.jl parses Julia syntax and extracts C++ intent:\n\n# Example: @cxx foo::bar::baz(a, b)\n#\n# 1. Extract namespace\nnns = Expr(:curly, Tuple, :foo, :bar, :baz)\n\n# 2. Detect function call\ncexpr = :(baz(a, b))\n\n# 3. Generate staged function call\nbuild_cpp_call(mod, cexpr, nothing, nns)\n    ↓\ncppcall(__current_compiler__, CppNNS{(:foo, :bar, :baz)}(), a, b)","category":"section"},{"location":"design/INTERNAL/#Member-Calls","page":"Internal","title":"Member Calls","text":"For @cxx obj->method(args):\n\n# 1. Detect -> operator\nexpr.head == :(->)\na = expr.args[1]  # obj\nb = expr.args[2]  # method(args)\n\n# 2. Call staged function for member call\ncppcall_member(__current_compiler__, CppNNS{(:method,)}(), obj, args...)","category":"section"},{"location":"design/INTERNAL/#Modifier-Processing","page":"Internal","title":"Modifier Processing","text":"@cxx foo(*(a)): Wrapped with CppDeref\n@cxx foo(&a): Wrapped with CppAddr\n@cxx foo(cast(T, a)): Wrapped with CppCast\n\n","category":"section"},{"location":"design/INTERNAL/#String-Literals-(cxx\"\"-and-icxx\"\")","page":"Internal","title":"String Literals (cxx\"\" and icxx\"\")","text":"","category":"section"},{"location":"design/INTERNAL/#cxx\"\"-(Global-Scope)","page":"Internal","title":"cxx\"\" (Global Scope)","text":"Processed by process_cxx_string function in cxxstr.jl:\n\ncxx\"\"\"\n    void myfunction(int x) {\n        std::cout << x << std::endl;\n    }\n\"\"\"\n\nProcessing flow:\n\nExtract Julia expressions: Detect Julia expressions embedded with $\nReplace placeholders: Replace with __julia::var1, __julia::var2, etc.\nPass to Clang parser: EnterBuffer or EnterVirtualSource\nParse: Parse C++ code with ParseToEndOfFile\nExecute global constructors: RunGlobalConstructors","category":"section"},{"location":"design/INTERNAL/#icxx\"\"-(Function-Scope)","page":"Internal","title":"icxx\"\" (Function Scope)","text":"icxx\"\" is used within functions and evaluated at runtime:\n\nfunction myfunc(x)\n    icxx\"\"\"\n        int result = $(x) * 2;\n        return result;\n    \"\"\"\nend\n\nProcessing flow:\n\nGenerate staged function: cxxstr_impl executes as @generated function\nCreate Clang function: Create Clang function declaration with CreateFunctionWithBody\nParse: Parse function body with ParseFunctionStatementBody\nGenerate LLVM IR: Compile to LLVM IR with EmitTopLevelDecl\nGenerate call expression: Generate expression to call function with CallDNE","category":"section"},{"location":"design/INTERNAL/#Julia-Expression-Embedding","page":"Internal","title":"Julia Expression Embedding","text":"When embedding Julia expressions with $ syntax:\n\ncxx\"\"\"\n    void test() {\n        $:(println(\"Hello from Julia\")::Nothing);\n    }\n\"\"\"\n\nProcessing:\n\nfind_expr function detects $\nParse Julia expression: Meta.parse(str, idx + 1)\nReplace with placeholder: __juliavar1, etc.\nClang's external semantic source evaluates Julia expression at runtime\n\n","category":"section"},{"location":"design/INTERNAL/#Type-System","page":"Internal","title":"Type System","text":"","category":"section"},{"location":"design/INTERNAL/#Conversion-from-Julia-Types-to-C-Types","page":"Internal","title":"Conversion from Julia Types to C++ Types","text":"The cpptype function in typetranslation.jl handles conversion:\n\n# Basic types\ncpptype(C, ::Type{Int32}) → QualType (pointer to clang::Type*)\n\n# C++ classes\ncpptype(C, ::Type{CppBaseType{:MyClass}})\n    → lookup_ctx(C, :MyClass)  # Name resolution\n    → typeForDecl(decl)        # Get Clang type\n\n# Templates\ncpptype(C, ::Type{CppTemplate{CppBaseType{:vector}, Tuple{Int32}}})\n    → specialize_template(C, cxxt, targs)  # Template specialization\n    → typeForDecl(specialized_decl)\n\n# Pointers and references\ncpptype(C, ::Type{CppPtr{T, CVR}})\n    → pointerTo(C, cpptype(C, T))  # Get pointer type\n    → addQualifiers(..., CVR)      # Add const/volatile/restrict","category":"section"},{"location":"design/INTERNAL/#Conversion-from-C-Types-to-Julia-Types","page":"Internal","title":"Conversion from C++ Types to Julia Types","text":"The juliatype function handles conversion:\n\nfunction juliatype(t::QualType, quoted = false, typeargs = Dict{Int,Cvoid}())\n    CVR = extractCVR(t)  # Extract const/volatile/restrict\n    t = extractTypePtr(t)\n    t = canonicalType(t)  # Normalize\n\n    if isPointerType(t)\n        pt = getPointeeType(t)\n        tt = juliatype(pt, quoted, typeargs)\n        return CppPtr{tt, CVR}\n    elseif isReferenceType(t)\n        t = getPointeeType(t)\n        pointeeT = juliatype(t, quoted, typeargs)\n        return CppRef{pointeeT, CVR}\n    elseif isEnumeralType(t)\n        T = juliatype(getUnderlyingTypeOfEnum(t))\n        return CppEnum{Symbol(get_name(t)), T}\n    # ... other types\nend","category":"section"},{"location":"design/INTERNAL/#Type-Representation","page":"Internal","title":"Type Representation","text":"CppBaseType{s}: Base types (e.g., int, MyClass)\nCppTemplate{T, targs}: Template types (e.g., std::vector<int>)\nCppPtr{T, CVR}: Pointer types\nCppRef{T, CVR}: Reference types\nCppValue{T, N}: Value types (on stack)\nCxxQualType{T, CVR}: Types with CVR qualifiers\n\n","category":"section"},{"location":"design/INTERNAL/#Code-Generation-Process","page":"Internal","title":"Code Generation Process","text":"","category":"section"},{"location":"design/INTERNAL/#1.-Argument-Preparation-(buildargexprs)","page":"Internal","title":"1. Argument Preparation (buildargexprs)","text":"function buildargexprs(C, argt; derefval = true)\n    # For each argument:\n    # 1. Get Clang type\n    argit = cpptype(C, stripmodifier(t))\n\n    # 2. Create ParmVarDecl (function parameter declaration)\n    argpvd = CreateParmVarDecl(C, argit)\n\n    # 3. Create DeclRefExpr (variable reference expression)\n    expr = CreateDeclRefExpr(C, argpvd)\n\n    # 4. Apply modifiers (*, &, etc.)\n    expr = resolvemodifier(C, t, expr)\nend","category":"section"},{"location":"design/INTERNAL/#2.-Name-Resolution-(declfornns)","page":"Internal","title":"2. Name Resolution (declfornns)","text":"function declfornns(C, ::Type{CppNNS{Tnns}}, cxxscope=C_NULL)\n    nns = Tnns.parameters  # (:foo, :bar, :baz)\n    d = translation_unit(C)  # Start from translation unit\n\n    for (i, n) in enumerate(nns)\n        if n <: CppTemplate\n            # Template specialization\n            d = specialize_template_clang(C, cxxt, arr)\n        else\n            # Normal name resolution\n            d = lookup_name(C, (n,), cxxscope, d, i != length(nns))\n        end\n    end\n\n    d\nend","category":"section"},{"location":"design/INTERNAL/#3.-Call-Expression-Generation","page":"Internal","title":"3. Call Expression Generation","text":"# Normal function call\nce = CreateCallExpr(C, dne, callargs)\n\n# Member function call\nme = BuildMemberReference(C, callargs[1], cpptype(C, argt[1]),\n                          argt[1] <: CppPtr, fname)\nce = BuildCallToMemberFunction(C, me, callargs[2:end])\n\n# Constructor call\nctce = BuildCXXTypeConstructExpr(C, rt, callargs)\n\n# new expression\nnE = BuildCXXNewExpr(C, QualType(typeForDecl(cxxd)), callargs)","category":"section"},{"location":"design/INTERNAL/#4.-LLVM-IR-Generation","page":"Internal","title":"4. LLVM IR Generation","text":"function EmitExpr(C, ce, nE, ctce, argt, pvds, rett = Cvoid)\n    # 1. Create LLVM function\n    f = CreateFunctionWithPersonality(C, llvmrt, map(julia_to_llvm, llvmargt))\n\n    # 2. Setup code generation environment\n    state = setup_cpp_env(C, f)\n    builder = irbuilder(C)\n\n    # 3. Process LLVM arguments (convert from Julia types to LLVM types)\n    args = llvmargs(C, builder, f, llvmargt)\n\n    # 4. Associate Clang AST with LLVM values\n    associateargs(C, builder, argt, args, pvds)\n\n    # 5. Compile Clang AST to LLVM IR\n    if ce != C_NULL\n        ret = EmitCallExpr(C, ce, rslot)\n    elseif nE != C_NULL\n        ret = EmitCXXNewExpr(C, nE)\n    elseif ctce != C_NULL\n        EmitAnyExprToMem(C, ctce, args[1], true)\n    end\n\n    # 6. Generate llvmcall expression\n    createReturn(C, builder, f, argt, llvmargt, llvmrt, rett, rt, ret, state)\nend","category":"section"},{"location":"design/INTERNAL/#5.-LLVM-Value-Conversion","page":"Internal","title":"5. LLVM Value Conversion","text":"The resolvemodifier_llvm function converts Julia's LLVM representation to Clang's LLVM representation:\n\n# Pointer type\nresolvemodifier_llvm(C, builder, t::Type{Ptr{ptr}}, v)\n    → IntToPtr(builder, v, toLLVM(C, cpptype(C, Ptr{ptr})))\n\n# CppValue type (value type)\nresolvemodifier_llvm(C, builder, t::Type{T} where T <: CppValue, v)\n    → CreatePointerFromObjref(C, builder, v)\n    → CreateBitCast(builder, v, getPointerTo(getPointerTo(toLLVM(C, ty))))\n\n# CppRef type (reference)\nresolvemodifier_llvm(C, builder, t::Type{CppRef{T, CVR}}, v)\n    → IntToPtr(builder, v, toLLVM(C, ty))\n\n","category":"section"},{"location":"design/INTERNAL/#Clang-Integration","page":"Internal","title":"Clang Integration","text":"","category":"section"},{"location":"design/INTERNAL/#Clang-Instance-Initialization","page":"Internal","title":"Clang Instance Initialization","text":"setup_instance function in initialization.jl:\n\nfunction setup_instance(PCHBuffer = []; makeCCompiler=false, ...)\n    x = Ref{ClangCompiler}()\n\n    # Call C++ side init_clang_instance\n    ccall((:init_clang_instance, libcxxffi), Cvoid,\n        (Ptr{Cvoid}, Ptr{UInt8}, Ptr{UInt8}, ...),\n        x, target, CPU, sysroot, ...)\n\n    # Apply default ABI\n    useDefaultCxxABI && ccall((:apply_default_abi, libcxxffi), ...)\n\n    x[]\nend","category":"section"},{"location":"design/INTERNAL/#Adding-Header-Search-Paths","page":"Internal","title":"Adding Header Search Paths","text":"function addHeaderDir(C, dirname; kind = C_User, isFramework = false)\n    ccall((:add_directory, libcxxffi), Cvoid,\n        (Ref{ClangCompiler}, Cint, Cint, Ptr{UInt8}),\n        C, kind, isFramework, dirname)\nend","category":"section"},{"location":"design/INTERNAL/#Source-Buffer-Input","page":"Internal","title":"Source Buffer Input","text":"# Anonymous buffer\nfunction EnterBuffer(C, buf)\n    ccall((:EnterSourceFile, libcxxffi), Cvoid,\n        (Ref{ClangCompiler}, Ptr{UInt8}, Csize_t),\n        C, buf, sizeof(buf))\nend\n\n# Virtual file (specify filename)\nfunction EnterVirtualSource(C, buf, file::String)\n    ccall((:EnterVirtualFile, libcxxffi), Cvoid,\n        (Ref{ClangCompiler}, Ptr{UInt8}, Csize_t, Ptr{UInt8}, Csize_t),\n        C, buf, sizeof(buf), file, sizeof(file))\nend","category":"section"},{"location":"design/INTERNAL/#Parsing","page":"Internal","title":"Parsing","text":"function ParseToEndOfFile(C)\n    hadError = ccall((:_cxxparse, libcxxffi), Cint, (Ref{ClangCompiler},), C) == 0\n    if !hadError\n        RunGlobalConstructors(C)  # Execute global constructors\n    end\n    !hadError\nend\n\n","category":"section"},{"location":"design/INTERNAL/#LLVM-IR-Integration","page":"Internal","title":"LLVM IR Integration","text":"","category":"section"},{"location":"design/INTERNAL/#Using-llvmcall","page":"Internal","title":"Using llvmcall","text":"Cxx.jl uses Julia's llvmcall in the second form (pointer form):\n\nllvmcall(convert(Ptr{Cvoid}, f),  # Pointer to LLVM function\n         rett,                     # Return type\n         Tuple{argt...},          # Argument type tuple\n         args...)                 # Actual arguments\n\nIn this form, Julia directly calls the LLVM function and performs argument conversion and inlining.","category":"section"},{"location":"design/INTERNAL/#LLVM-Function-Creation","page":"Internal","title":"LLVM Function Creation","text":"function CreateFunction(C, rt, argt)\n    pcpp\"llvm::Function\"(\n        ccall((:CreateFunction, libcxxffi), Ptr{Cvoid},\n            (Ref{ClangCompiler}, Ptr{Cvoid}, Ptr{Ptr{Cvoid}}, Csize_t),\n            C, rt, cptrarr(argt), length(argt)))\nend","category":"section"},{"location":"design/INTERNAL/#Type-Conversion","page":"Internal","title":"Type Conversion","text":"function julia_to_llvm(@nospecialize x)\n    isboxed, ty = _julia_to_llvm(x)\n    isboxed ? getPRJLValueTy() : ty  # Boxed types become jl_value_t*\nend","category":"section"},{"location":"design/INTERNAL/#Return-Value-Processing","page":"Internal","title":"Return Value Processing","text":"The createReturn function converts LLVM IR return values to Julia format:\n\nfunction createReturn(C, builder, f, argt, llvmargt, llvmrt, rett, rt, ret, state)\n    if ret == C_NULL\n        CreateRetVoid(builder)\n    else\n        if rett <: CppEnum || rett <: CppFptr\n            # Wrap in struct\n            undef = getUndefValue(llvmrt)\n            ret = InsertValue(builder, undef, ret, 0)\n        elseif rett <: CppRef || rett <: CppPtr || rett <: Ptr\n            # Convert pointer to integer\n            ret = PtrToInt(builder, ret, llvmrt)\n        elseif rett <: CppValue\n            # Value types need special processing\n            # ...\n        end\n        CreateRet(builder, ret)\n    end\n\n    # Generate llvmcall expression\n    Expr(:call, Core.Intrinsics.llvmcall, convert(Ptr{Cvoid}, f), rett, ...)\nend\n\n","category":"section"},{"location":"design/INTERNAL/#Memory-Management","page":"Internal","title":"Memory Management","text":"","category":"section"},{"location":"design/INTERNAL/#C-Object-Lifecycle","page":"Internal","title":"C++ Object Lifecycle","text":"CppPtr: Pointer to heap-allocated object\nCppRef: Reference to existing object\nCppValue: Value stored on stack or within Julia struct","category":"section"},{"location":"design/INTERNAL/#Destructor-Invocation","page":"Internal","title":"Destructor Invocation","text":"For types with non-trivial destructors in CppValue:\n\nif rett <: CppValue\n    T = cpptype(C, rett)\n    D = getAsCXXRecordDecl(T)\n    if D != C_NULL && !hasTrivialDestructor(C, D)\n        # Register finalizer to call destructor\n        push!(B.args, :(finalizer($(get_destruct_for_instance(C)), r)))\n    end\nend\n\n","category":"section"},{"location":"design/INTERNAL/#Error-Handling","page":"Internal","title":"Error Handling","text":"","category":"section"},{"location":"design/INTERNAL/#C-Exception-Processing","page":"Internal","title":"C++ Exception Processing","text":"C++ exceptions are converted to Julia exceptions in exceptions.jl:\n\nfunction setup_exception_callback()\n    callback = cglobal((:process_cxx_exception, libcxxffi), Ptr{Cvoid})\n    unsafe_store!(callback, @cfunction(process_cxx_exception, Union{}, (UInt64, Ptr{Cvoid})))\nend\n\nWhen an exception occurs on the C++ side, this callback is invoked and converted to a Julia exception.\n\n","category":"section"},{"location":"design/INTERNAL/#Optimization-Points","page":"Internal","title":"Optimization Points","text":"Type information utilization: Staged functions allow appropriate C++ functions to be selected at compile time since types are determined\nInlining: llvmcall allows LLVM IR to be inlined into Julia's IR, applying optimizations\nPCH (Precompiled Header): Precompile frequently used headers for speed\nTemplate specialization cache: Reuse once-specialized templates\n\n","category":"section"},{"location":"design/INTERNAL/#Summary","page":"Internal","title":"Summary","text":"Cxx.jl achieves C++ and Julia interop by combining the following technologies:\n\nMacros and staged functions: Syntax parsing and type information extraction\nClang integration: C++ code parsing and AST generation\nLLVM integration: Conversion from AST to LLVM IR and embedding into Julia\nType system: Bidirectional conversion between Julia types and C++ types\n\nThis architecture enables direct calls to C++ code from Julia and leverages optimizations from both languages.","category":"section"},{"location":"tutorial/#RustCall.jl-Tutorial","page":"Tutorial","title":"RustCall.jl Tutorial","text":"This tutorial walks you through using RustCall.jl to call Rust code from Julia step by step.","category":"section"},{"location":"tutorial/#Table-of-Contents","page":"Tutorial","title":"Table of Contents","text":"Getting Started\nBasic Usage\nThe Easy Way: #[julia] Attribute\nThe Traditional Way: Manual FFI\nUnderstanding the Type System\nString Handling\nError Handling\nUsing Ownership Types\nLLVM IR Integration (Advanced)\nPerformance Optimization","category":"section"},{"location":"tutorial/#Getting-Started","page":"Tutorial","title":"Getting Started","text":"","category":"section"},{"location":"tutorial/#Installation","page":"Tutorial","title":"Installation","text":"using Pkg\nPkg.add(\"RustCall\")","category":"section"},{"location":"tutorial/#Requirements","page":"Tutorial","title":"Requirements","text":"Julia 1.12 or later\nRust toolchain (rustc and cargo) installed and available in PATH\n\nTo install Rust, visit rustup.rs.","category":"section"},{"location":"tutorial/#Building-Rust-Helpers-Library-(Optional)","page":"Tutorial","title":"Building Rust Helpers Library (Optional)","text":"To use ownership types (Box, Rc, Arc), you need to build the Rust helpers library:\n\nusing Pkg\nPkg.build(\"RustCall\")","category":"section"},{"location":"tutorial/#Basic-Usage","page":"Tutorial","title":"Basic Usage","text":"","category":"section"},{"location":"tutorial/#The-Easy-Way:-#[julia]-Attribute","page":"Tutorial","title":"The Easy Way: #[julia] Attribute","text":"The simplest way to define Rust functions is using the #[julia] attribute:\n\nrust\"\"\"\n#[julia]\nfn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\"\"\"\n\n# Call directly - no @rust macro needed!\nresult = add(10, 20)\nprintln(result)  # => 30\n\nThe #[julia] attribute automatically:\n\nConverts to #[no_mangle] pub extern \"C\"\nGenerates a Julia wrapper function with proper type conversions","category":"section"},{"location":"tutorial/#The-Traditional-Way:-Manual-FFI","page":"Tutorial","title":"The Traditional Way: Manual FFI","text":"For more control, you can use the traditional FFI approach:\n\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn multiply(a: i32, b: i32) -> i32 {\n    a * b\n}\n\"\"\"\n\n# Use @rust macro with explicit types\nresult = @rust multiply(Int32(5), Int32(7))::Int32\nprintln(result)  # => 35","category":"section"},{"location":"tutorial/#Step-1:-Define-and-Compile-Rust-Code","page":"Tutorial","title":"Step 1: Define and Compile Rust Code","text":"Use the rust\"\" string literal to define and compile Rust code:\n\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn subtract(a: i32, b: i32) -> i32 {\n    a - b\n}\n\"\"\"\n\nThis code is automatically compiled and loaded as a shared library.","category":"section"},{"location":"tutorial/#Step-2:-Call-Rust-Functions","page":"Tutorial","title":"Step 2: Call Rust Functions","text":"Use the @rust macro to call functions:\n\n# With type inference\nresult = @rust subtract(Int32(100), Int32(30))::Int32\nprintln(result)  # => 70","category":"section"},{"location":"tutorial/#Step-3:-Define-Multiple-Functions","page":"Tutorial","title":"Step 3: Define Multiple Functions","text":"You can define multiple functions in the same rust\"\" block:\n\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn multiply(x: f64, y: f64) -> f64 {\n    x * y\n}\n\n#[no_mangle]\npub extern \"C\" fn subtract(a: i64, b: i64) -> i64 {\n    a - b\n}\n\"\"\"\n\n# Usage\nproduct = @rust multiply(3.0, 4.0)::Float64  # => 12.0\ndifference = @rust subtract(100, 30)::Int64  # => 70","category":"section"},{"location":"tutorial/#Understanding-the-Type-System","page":"Tutorial","title":"Understanding the Type System","text":"","category":"section"},{"location":"tutorial/#Basic-Type-Mapping","page":"Tutorial","title":"Basic Type Mapping","text":"RustCall.jl automatically maps Rust types to Julia types:\n\nRust Type Julia Type Example\ni8 Int8 10i8\ni16 Int16 100i16\ni32 Int32 1000i32\ni64 Int64 10000i64\nu8 UInt8 10u8\nu32 UInt32 1000u32\nu64 UInt64 10000u64\nf32 Float32 3.14f0\nf64 Float64 3.14159\nbool Bool true\nusize UInt 100u\nisize Int 100\n() Cvoid -","category":"section"},{"location":"tutorial/#Type-Inference","page":"Tutorial","title":"Type Inference","text":"RustCall.jl tries to infer return types from argument types, but explicit specification is recommended:\n\n# Not recommended - relies on inference (works but not recommended)\nresult = @rust add(Int32(10), Int32(20))\n\n# Recommended - explicit type specification\nresult = @rust add(Int32(10), Int32(20))::Int32","category":"section"},{"location":"tutorial/#Boolean-Values","page":"Tutorial","title":"Boolean Values","text":"rust\"\"\"\n#[no_mangle]\npub extern \"C\" fn is_positive(x: i32) -> bool {\n    x > 0\n}\n\"\"\"\n\n@rust is_positive(Int32(5))::Bool   # => true\n@rust is_positive(Int32(-5))::Bool  # => false","category":"section"},{"location":"tutorial/#String-Handling","page":"Tutorial","title":"String Handling","text":"","category":"section"},{"location":"tutorial/#Passing-as-C-Strings","page":"Tutorial","title":"Passing as C Strings","text":"When Rust functions expect *const u8 (C strings), you can pass Julia String directly:\n\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn string_length(s: *const u8) -> u32 {\n    let c_str = unsafe { std::ffi::CStr::from_ptr(s as *const i8) };\n    c_str.to_bytes().len() as u32\n}\n\"\"\"\n\n# Julia String is automatically converted to Cstring\nlen = @rust string_length(\"hello\")::UInt32  # => 5\nlen = @rust string_length(\"世界\")::UInt32   # => 6 (UTF-8 bytes)","category":"section"},{"location":"tutorial/#UTF-8-String-Handling","page":"Tutorial","title":"UTF-8 String Handling","text":"rust\"\"\"\n#[no_mangle]\npub extern \"C\" fn count_chars(s: *const u8) -> u32 {\n    let c_str = unsafe { std::ffi::CStr::from_ptr(s as *const i8) };\n    let utf8_str = std::str::from_utf8(c_str.to_bytes()).unwrap();\n    utf8_str.chars().count() as u32\n}\n\"\"\"\n\n# Count UTF-8 characters\ncount = @rust count_chars(\"hello\")::UInt32    # => 5\ncount = @rust count_chars(\"世界\")::UInt32     # => 2 (characters, not bytes)","category":"section"},{"location":"tutorial/#Error-Handling","page":"Tutorial","title":"Error Handling","text":"","category":"section"},{"location":"tutorial/#Using-Result-Type","page":"Tutorial","title":"Using Result Type","text":"Rust's Result<T, E> type is represented as RustResult{T, E} in Julia:\n\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn divide(a: i32, b: i32) -> i32 {\n    if b == 0 {\n        return -1;  // Return -1 as error code\n    }\n    a / b\n}\n\"\"\"\n\n# Error checking\nresult = @rust divide(Int32(10), Int32(2))::Int32\nif result == -1\n    println(\"Division by zero!\")\nend","category":"section"},{"location":"tutorial/#Explicit-Use-of-RustResult","page":"Tutorial","title":"Explicit Use of RustResult","text":"For a more Rust-like approach, you can define functions that return Result types:\n\n# Create RustResult manually\nok_result = RustResult{Int32, String}(true, Int32(42))\nis_ok(ok_result)  # => true\nunwrap(ok_result)  # => 42\n\nerr_result = RustResult{Int32, String}(false, \"error message\")\nis_err(err_result)  # => true\nunwrap_or(err_result, Int32(0))  # => 0","category":"section"},{"location":"tutorial/#Converting-to-Exceptions","page":"Tutorial","title":"Converting to Exceptions","text":"Use result_to_exception to convert Result to Julia exceptions:\n\nerr_result = RustResult{Int32, String}(false, \"division by zero\")\ntry\n    value = result_to_exception(err_result)\ncatch e\n    if e isa RustError\n        println(\"Rust error: $(e.message)\")\n    end\nend","category":"section"},{"location":"tutorial/#Using-Ownership-Types","page":"Tutorial","title":"Using Ownership Types","text":"","category":"section"},{"location":"tutorial/#RustBox-(Single-Ownership)","page":"Tutorial","title":"RustBox (Single Ownership)","text":"RustBox<T> is a heap-allocated value with single ownership:\n\n# Rust helpers library required\nif is_rust_helpers_available()\n    # Create Box (usually returned from Rust functions)\n    # Here as an example, actual usage is from Rust function return values\n    box = RustBox{Int32}(ptr)  # ptr obtained from Rust function\n\n    # Explicitly drop after use\n    drop!(box)\nend","category":"section"},{"location":"tutorial/#RustRc-(Reference-Counting,-Single-threaded)","page":"Tutorial","title":"RustRc (Reference Counting, Single-threaded)","text":"if is_rust_helpers_available()\n    # Create Rc\n    rc1 = RustRc{Int32}(ptr)\n\n    # Clone to increment reference count\n    rc2 = clone(rc1)\n\n    # Dropping one keeps the other valid\n    drop!(rc1)\n    @assert is_valid(rc2)  # Still valid\n\n    # Drop last reference\n    drop!(rc2)\nend","category":"section"},{"location":"tutorial/#RustArc-(Atomic-Reference-Counting,-Thread-safe)","page":"Tutorial","title":"RustArc (Atomic Reference Counting, Thread-safe)","text":"if is_rust_helpers_available()\n    # Create Arc\n    arc1 = RustArc{Int32}(ptr)\n\n    # Thread-safe clone\n    arc2 = clone(arc1)\n\n    # Can be used from different tasks\n    @sync begin\n        @async begin\n            # Use arc2\n        end\n    end\n\n    drop!(arc1)\n    drop!(arc2)\nend","category":"section"},{"location":"tutorial/#LLVM-IR-Integration-(Advanced)","page":"Tutorial","title":"LLVM IR Integration (Advanced)","text":"","category":"section"},{"location":"tutorial/#Using-@rust_llvm-Macro","page":"Tutorial","title":"Using @rust_llvm Macro","text":"The @rust_llvm macro enables optimized calls via LLVM IR integration (experimental):\n\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn fast_add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\"\"\"\n\n# Register function\ninfo = compile_and_register_rust_function(\"\"\"\n#[no_mangle]\npub extern \"C\" fn fast_add(a: i32, b: i32) -> i32 { a + b }\n\"\"\", \"fast_add\")\n\n# Call with @rust_llvm (potentially optimized)\nresult = @rust_llvm fast_add(Int32(10), Int32(20))  # => 30","category":"section"},{"location":"tutorial/#LLVM-Optimization-Settings","page":"Tutorial","title":"LLVM Optimization Settings","text":"using RustCall\n\n# Create optimization configuration\nconfig = OptimizationConfig(\n    level=3,  # Optimization level 0-3\n    enable_vectorization=true,\n    inline_threshold=300\n)\n\n# Optimize module\n# optimize_module!(module, config)\n\n# Convenience functions\n# optimize_for_speed!(module)  # Level 3, aggressive optimization\n# optimize_for_size!(module)   # Level 2, size optimization","category":"section"},{"location":"tutorial/#Performance-Optimization","page":"Tutorial","title":"Performance Optimization","text":"","category":"section"},{"location":"tutorial/#Using-Compilation-Cache","page":"Tutorial","title":"Using Compilation Cache","text":"RustCall.jl automatically caches compilation results. No need to recompile the same code:\n\n# First compilation (takes time)\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn compute(x: i32) -> i32 {\n    x * 2\n}\n\"\"\"\n\n# Same code again (fast load from cache)\nrust\"\"\"\n#[no_mangle]\npub extern \"C\" fn compute(x: i32) -> i32 {\n    x * 2\n}\n\"\"\"","category":"section"},{"location":"tutorial/#Cache-Management","page":"Tutorial","title":"Cache Management","text":"# Check cache size\nsize = get_cache_size()\nprintln(\"Cache size: $size bytes\")\n\n# List cached libraries\nlibs = list_cached_libraries()\nprintln(\"Cached libraries: $libs\")\n\n# Cleanup old cache (older than 30 days)\ncleanup_old_cache(30)\n\n# Clear all cache\nclear_cache()","category":"section"},{"location":"tutorial/#Running-Benchmarks","page":"Tutorial","title":"Running Benchmarks","text":"To measure performance:\n\njulia --project benchmark/benchmarks.jl\n\nThis compares performance of Julia native, @rust, and @rust_llvm.","category":"section"},{"location":"tutorial/#Best-Practices","page":"Tutorial","title":"Best Practices","text":"","category":"section"},{"location":"tutorial/#1.-Always-Specify-Types-Explicitly","page":"Tutorial","title":"1. Always Specify Types Explicitly","text":"# Recommended\nresult = @rust add(Int32(10), Int32(20))::Int32\n\n# Not recommended (relies on type inference)\nresult = @rust add(Int32(10), Int32(20))","category":"section"},{"location":"tutorial/#2.-Proper-Error-Handling","page":"Tutorial","title":"2. Proper Error Handling","text":"# Use Result type\nresult = some_rust_function()\nif is_err(result)\n    # Handle error\n    return\nend\nvalue = unwrap(result)","category":"section"},{"location":"tutorial/#3.-Be-Careful-with-Memory-Management","page":"Tutorial","title":"3. Be Careful with Memory Management","text":"When using ownership types, always call drop! appropriately:\n\nbox = RustBox{Int32}(ptr)\ntry\n    # Use box\nfinally\n    drop!(box)  # Always cleanup\nend","category":"section"},{"location":"tutorial/#4.-Leverage-Caching","page":"Tutorial","title":"4. Leverage Caching","text":"When using the same Rust code multiple times, caching is automatically leveraged.","category":"section"},{"location":"tutorial/#5.-Clear-Cache-When-Debugging","page":"Tutorial","title":"5. Clear Cache When Debugging","text":"If issues occur, try clearing the cache and recompiling:\n\nclear_cache()","category":"section"},{"location":"tutorial/#Next-Steps","page":"Tutorial","title":"Next Steps","text":"See Examples for more advanced usage examples\nCheck Troubleshooting to solve problems\nReview API Reference for all features","category":"section"},{"location":"#RustCall.jl","page":"Home","title":"RustCall.jl","text":"RustCall.jl is a Foreign Function Interface (FFI) package for calling Rust code directly from Julia, inspired by Cxx.jl.\n\nIt's the last call for headache. 🦀","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"#Phase-1:-C-Compatible-ABI","page":"Home","title":"Phase 1: C-Compatible ABI ✅","text":"@rust macro: Call Rust functions directly from Julia\nrust\"\" string literal: Compile and load Rust code as shared libraries\n@irust macro: Execute Rust code at function scope\nType mapping: Automatic conversion between Rust and Julia types\nResult/Option support: Handle Rust's Result<T, E> and Option<T> types\nString support: Pass Julia strings to Rust functions expecting C strings\nCompilation caching: SHA256-based caching system for compiled libraries","category":"section"},{"location":"#Phase-2:-LLVM-IR-Integration","page":"Home","title":"Phase 2: LLVM IR Integration ✅","text":"@rust_llvm macro: Direct LLVM IR integration (experimental)\nLLVM optimization: Configurable optimization passes\nOwnership types: RustBox, RustRc, RustArc, RustVec, RustSlice\nArray operations: Indexing, iteration, Julia ↔ Rust conversion\nGenerics support: Automatic monomorphization and type parameter inference\nError handling: RustError exception type with result_to_exception\nFunction registration: Register and cache compiled Rust functions","category":"section"},{"location":"#Phase-6:-External-Crate-Bindings-(Maturin-like)","page":"Home","title":"Phase 6: External Crate Bindings (Maturin-like) ✅","text":"juliacall_macros crate: Proc-macro crate for #[julia] attribute\n@rust_crate macro: Generate Julia bindings for external Rust crates\nCrate scanning: Detect #[julia] marked functions and structs\nAutomatic building: Build crates and generate Julia modules","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"RustCall\")\n\nRequirements:\n\nJulia 1.12 or later\nRust toolchain (rustc and cargo) installed and available in PATH\n\nTo install Rust, visit rustup.rs.","category":"section"},{"location":"#Building-Rust-Helpers-Library","page":"Home","title":"Building Rust Helpers Library","text":"For full functionality including ownership types (Box, Rc, Arc), you need to build the Rust helpers library:\n\nusing Pkg\nPkg.build(\"RustCall\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"using RustCall\n\n# Define and compile Rust code with #[julia] attribute\nrust\"\"\"\n#[julia]\nfn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\"\"\"\n\n# Call the Rust function directly (wrapper auto-generated)\nresult = add(10, 20)\nprintln(result)  # => 30","category":"section"},{"location":"#Type-Mapping","page":"Home","title":"Type Mapping","text":"RustCall.jl automatically maps Rust types to Julia types:\n\nRust Type Julia Type\ni8 Int8\ni16 Int16\ni32 Int32\ni64 Int64\nu8 UInt8\nu16 UInt16\nu32 UInt32\nu64 UInt64\nf32 Float32\nf64 Float64\nbool Bool\nusize UInt\nisize Int\n() Cvoid\n*const u8 Cstring / String\n*mut u8 Ptr{UInt8}","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Pages = [\n    \"tutorial.md\",\n    \"examples.md\",\n    \"struct_mapping.md\",\n    \"crate_bindings.md\",\n    \"generics.md\",\n    \"performance.md\",\n    \"troubleshooting.md\",\n    \"api.md\",\n    \"status.md\",\n]\nDepth = 2","category":"section"}]
}
