<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · RustCall.jl</title><meta name="title" content="API Reference · RustCall.jl"/><meta property="og:title" content="API Reference · RustCall.jl"/><meta property="twitter:title" content="API Reference · RustCall.jl"/><meta name="description" content="Documentation for RustCall.jl."/><meta property="og:description" content="Documentation for RustCall.jl."/><meta property="twitter:description" content="Documentation for RustCall.jl."/><meta property="og:url" content="https://atelierarith.github.io/RustCall.jl/api/"/><meta property="twitter:url" content="https://atelierarith.github.io/RustCall.jl/api/"/><link rel="canonical" href="https://atelierarith.github.io/RustCall.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RustCall.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../struct_mapping/">Struct Mapping</a></li><li><a class="tocitem" href="../generics/">Generics</a></li><li><a class="tocitem" href="../crate_bindings/">External Crate Bindings</a></li><li><a class="tocitem" href="../precompilation/">Precompilation</a></li><li><a class="tocitem" href="../troubleshooting/">Troubleshooting</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Macros"><span>Macros</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Type-Conversion-Functions"><span>Type Conversion Functions</span></a></li><li><a class="tocitem" href="#Result/Option-Operations"><span>Result/Option Operations</span></a></li><li><a class="tocitem" href="#String-Conversion-Functions"><span>String Conversion Functions</span></a></li><li><a class="tocitem" href="#Error-Handling"><span>Error Handling</span></a></li><li><a class="tocitem" href="#Compiler-Functions"><span>Compiler Functions</span></a></li><li><a class="tocitem" href="#Ownership-Type-Operations"><span>Ownership Type Operations</span></a></li><li><a class="tocitem" href="#RustVec-Operations"><span>RustVec Operations</span></a></li><li><a class="tocitem" href="#Cache-Management"><span>Cache Management</span></a></li><li><a class="tocitem" href="#LLVM-Optimization"><span>LLVM Optimization</span></a></li><li><a class="tocitem" href="#LLVM-Function-Registration"><span>LLVM Function Registration</span></a></li><li><a class="tocitem" href="#Generics-Support"><span>Generics Support</span></a></li><li><a class="tocitem" href="#Generic-Constraints"><span>Generic Constraints</span></a></li><li><a class="tocitem" href="#External-Library-Integration"><span>External Library Integration</span></a></li><li><a class="tocitem" href="#Crate-Bindings"><span>Crate Bindings</span></a></li><li><a class="tocitem" href="#Hot-Reload"><span>Hot Reload</span></a></li><li><a class="tocitem" href="#Type-System"><span>Type System</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li><li><a class="tocitem" href="#Internal-Functions-and-Types"><span>Internal Functions and Types</span></a></li></ul></li><li><a class="tocitem" href="../status/">Project Status</a></li></ul></li><li><span class="tocitem">Design</span><ul><li><a class="tocitem" href="../design/Phase1/">Phase 1</a></li><li><a class="tocitem" href="../design/Phase2/">Phase 2</a></li><li><a class="tocitem" href="../design/INTERNAL/">Internal</a></li><li><a class="tocitem" href="../design/LLVMCALL/">LLVM Call</a></li></ul></li><li><span class="tocitem">Platforms</span><ul><li><a class="tocitem" href="../platforms/windows/">Windows</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AtelierArith/RustCall.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/docs/src/api.md" title="View source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><p>This page provides the API documentation for RustCall.jl.</p><h2 id="Macros"><a class="docs-heading-anchor" href="#Macros">Macros</a><a id="Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Macros" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RustCall.@rust"><a class="docstring-binding" href="#RustCall.@rust"><code>RustCall.@rust</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@rust expr</code></pre><p>Call a Rust function from Julia.</p><p><strong>Syntax</strong></p><ul><li><code>@rust func(args...)</code> - Call a function with automatic type inference</li><li><code>@rust func(args...)::RetType</code> - Call with explicit return type</li><li><code>@rust lib::func(args...)</code> - Call from a specific library</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Simple call (types inferred from arguments)
@rust add(10i32, 20i32)

# With explicit return type
@rust add(10, 20)::Int32

# From specific library
@rust mylib::multiply(3.0, 4.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/rustmacro.jl#L3-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.@rust_str"><a class="docstring-binding" href="#RustCall.@rust_str"><code>RustCall.@rust_str</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@rust_str(code)</code></pre><p>Compile Rust code and load it as a shared library.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">rust&quot;&quot;&quot;
#[no_mangle]
pub extern &quot;C&quot; fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
&quot;&quot;&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L126-L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.@irust"><a class="docstring-binding" href="#RustCall.@irust"><code>RustCall.@irust</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@irust(code, args...)
@irust(code)</code></pre><p>Execute Rust code at function scope.</p><p>This macro compiles Rust code into a temporary function and calls it. Julia variables can be referenced using <code>$var</code> syntax or passed as arguments.</p><p><strong>Features</strong></p><ul><li>Automatic variable binding with <code>$var</code> syntax</li><li>Improved type inference from code</li><li>Better error messages</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Using $var syntax (recommended)
function myfunc(x)
    @irust(&quot;$x * 2&quot;)
end

# Using explicit arguments (legacy, still supported)
function myfunc(x)
    @irust(&quot;arg1 * 2&quot;, x)
end

# Multiple variables
function add_and_multiply(a, b, c)
    @irust(&quot;$a + $b * $c&quot;)
end</code></pre><p>For more complex cases, use <code>rust&quot;&quot;&quot;</code> to define functions explicitly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L908-L941">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.@irust_str"><a class="docstring-binding" href="#RustCall.@irust_str"><code>RustCall.@irust_str</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@irust_str(code)</code></pre><p>String literal form of @irust. Use @irust(&quot;code&quot;, args...) for better syntax.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">@irust_str(&quot;arg1 * 2&quot;)  # Note: arguments must be passed separately</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L973-L982">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.@rust_llvm"><a class="docstring-binding" href="#RustCall.@rust_llvm"><code>RustCall.@rust_llvm</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@rust_llvm func_name(args...)</code></pre><p>Call a Rust function using LLVM IR integration (Phase 2). This uses @generated functions to produce optimized code at compile time.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">rust&quot;&quot;&quot;
#[no_mangle]
pub extern &quot;C&quot; fn add_optimized(a: i32, b: i32) -&gt; i32 {
    a + b
}
&quot;&quot;&quot;

# Use llvmcall path (experimental)
result = @rust_llvm add_optimized(10, 20)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmcodegen.jl#L254-L272">source</a></section></details></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><h3 id="Result-and-Option-Types"><a class="docs-heading-anchor" href="#Result-and-Option-Types">Result and Option Types</a><a id="Result-and-Option-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Result-and-Option-Types" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="RustCall.RustResult"><a class="docstring-binding" href="#RustCall.RustResult"><code>RustCall.RustResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustResult{T, E}</code></pre><p>Represents Rust&#39;s <code>Result&lt;T, E&gt;</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L59-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.RustOption"><a class="docstring-binding" href="#RustCall.RustOption"><code>RustCall.RustOption</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustOption{T}</code></pre><p>Represents Rust&#39;s <code>Option&lt;T&gt;</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L109-L113">source</a></section></details></article><h3 id="Ownership-Types"><a class="docs-heading-anchor" href="#Ownership-Types">Ownership Types</a><a id="Ownership-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Ownership-Types" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="RustCall.RustBox"><a class="docstring-binding" href="#RustCall.RustBox"><code>RustCall.RustBox</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustBox{T}</code></pre><p>Represents Rust&#39;s <code>Box&lt;T&gt;</code> type - a heap-allocated value with single ownership. The memory is owned by this wrapper and should be dropped when no longer needed.</p><p><strong>Memory Management</strong></p><ul><li><code>RustBox</code> owns its data and is responsible for calling drop</li><li>Use <code>drop!</code> to explicitly release the memory</li><li>Finalizers can be attached for automatic cleanup</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create a Box (typically from Rust)
box = RustBox{Int32}(ptr)

# Access the value
value = deref(box)

# Drop when done
drop!(box)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L306-L328">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.RustRc"><a class="docstring-binding" href="#RustCall.RustRc"><code>RustCall.RustRc</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustRc{T}</code></pre><p>Represents Rust&#39;s <code>Rc&lt;T&gt;</code> type - a reference-counted pointer (single-threaded). Multiple <code>RustRc</code> instances can share ownership of the same data.</p><p><strong>Memory Management</strong></p><ul><li>Reference counting is managed by Rust</li><li>Julia side should call <code>clone</code> to create new references</li><li>Call <code>drop!</code> to decrement reference count</li></ul><p><strong>Note</strong></p><p><code>Rc&lt;T&gt;</code> is not thread-safe. For multi-threaded scenarios, use <code>RustArc{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L366-L379">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.RustArc"><a class="docstring-binding" href="#RustCall.RustArc"><code>RustCall.RustArc</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustArc{T}</code></pre><p>Represents Rust&#39;s <code>Arc&lt;T&gt;</code> type - an atomically reference-counted pointer (thread-safe). Multiple <code>RustArc</code> instances can share ownership across threads.</p><p><strong>Memory Management</strong></p><ul><li>Atomic reference counting is managed by Rust</li><li>Safe to share across Julia tasks/threads</li><li>Call <code>drop!</code> to decrement reference count</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create an Arc (from Rust)
arc = RustArc{MyData}(ptr)

# Clone for another owner
arc2 = clone(arc)

# Safe to use in different tasks
@spawn begin
    # Use arc2
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L407-L431">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.RustVec"><a class="docstring-binding" href="#RustCall.RustVec"><code>RustCall.RustVec</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustVec{T}</code></pre><p>Represents Rust&#39;s <code>Vec&lt;T&gt;</code> type - a growable array.</p><p><strong>Fields</strong></p><ul><li><code>ptr</code>: Pointer to the data</li><li><code>len</code>: Number of elements</li><li><code>cap</code>: Capacity (number of elements that can be stored without reallocation)</li></ul><p><strong>Memory Management</strong></p><ul><li>The vector owns its data</li><li>Use <code>drop!</code> to release memory when done</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Create from Rust
vec = RustVec{Int32}(ptr, len, cap)

# Access length
length(vec)  # =&gt; len

# Convert to Julia array (copies data)
julia_arr = collect(vec)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L463-L488">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.RustSlice"><a class="docstring-binding" href="#RustCall.RustSlice"><code>RustCall.RustSlice</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustSlice{T}</code></pre><p>Represents Rust&#39;s slice type <code>&amp;[T]</code> - a borrowed view into a contiguous sequence.</p><p><strong>Fields</strong></p><ul><li><code>ptr</code>: Pointer to the first element</li><li><code>len</code>: Number of elements</li></ul><p><strong>Note</strong></p><p>This is a borrowed reference; the underlying data must outlive the slice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L529-L540">source</a></section></details></article><h3 id="Pointer-Types"><a class="docs-heading-anchor" href="#Pointer-Types">Pointer Types</a><a id="Pointer-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Pointer-Types" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="RustCall.RustPtr"><a class="docstring-binding" href="#RustCall.RustPtr"><code>RustCall.RustPtr</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustPtr{T}</code></pre><p>A pointer to a Rust value of type T. Corresponds to <code>*const T</code> or <code>*mut T</code> in Rust.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L32-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.RustRef"><a class="docstring-binding" href="#RustCall.RustRef"><code>RustCall.RustRef</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustRef{T}</code></pre><p>A reference to a Rust value of type T. Corresponds to <code>&amp;T</code> or <code>&amp;mut T</code> in Rust. Note: In C ABI, references are passed as pointers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L45-L51">source</a></section></details></article><h3 id="String-Types"><a class="docs-heading-anchor" href="#String-Types">String Types</a><a id="String-Types-1"></a><a class="docs-heading-anchor-permalink" href="#String-Types" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="RustCall.RustString"><a class="docstring-binding" href="#RustCall.RustString"><code>RustCall.RustString</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustString</code></pre><p>Represents Rust&#39;s owned <code>String</code> type. This is a wrapper around a pointer to a Rust String. The memory is managed by Rust (via Box or similar).</p><p><strong>Memory Management</strong></p><p>When a Rust function returns a <code>String</code>, it should be freed using <code>drop_rust_string</code> or similar function provided by the Rust side.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L174-L184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.RustStr"><a class="docstring-binding" href="#RustCall.RustStr"><code>RustCall.RustStr</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustStr</code></pre><p>Represents Rust&#39;s string slice <code>&amp;str</code>. This is a borrowed reference, so the memory is managed elsewhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L195-L200">source</a></section></details></article><h3 id="Error-Types"><a class="docs-heading-anchor" href="#Error-Types">Error Types</a><a id="Error-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Types" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="RustCall.RustError"><a class="docstring-binding" href="#RustCall.RustError"><code>RustCall.RustError</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustError &lt;: Exception</code></pre><p>Exception type for Rust-related errors.</p><p><strong>Fields</strong></p><ul><li><code>message::String</code>: Error message</li><li><code>code::Int32</code>: Optional error code (default: 0)</li><li><code>original_error::Any</code>: Original typed error value from Rust (default: nothing)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L3-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.CompilationError"><a class="docstring-binding" href="#RustCall.CompilationError"><code>RustCall.CompilationError</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CompilationError &lt;: Exception</code></pre><p>Exception type for Rust compilation errors.</p><p><strong>Fields</strong></p><ul><li><code>message::String</code>: Formatted error message</li><li><code>raw_stderr::String</code>: Raw stderr output from rustc</li><li><code>source_code::String</code>: The Rust source code that failed to compile</li><li><code>command::String</code>: The rustc command that was executed</li><li><code>file_path::String</code>: Source file path (if available)</li><li><code>line_number::Int</code>: Line number where error occurred (if available)</li><li><code>context::Dict{String, Any}</code>: Additional debugging context</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L23-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.RuntimeError"><a class="docstring-binding" href="#RustCall.RuntimeError"><code>RustCall.RuntimeError</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RuntimeError &lt;: Exception</code></pre><p>Exception type for Rust runtime errors.</p><p><strong>Fields</strong></p><ul><li><code>message::String</code>: Error message</li><li><code>function_name::String</code>: Name of the function that failed</li><li><code>stack_trace::String</code>: Optional stack trace (default: &quot;&quot;)</li><li><code>arguments::Vector{Any}</code>: Function arguments that caused the error</li><li><code>library_name::String</code>: Name of the library containing the function</li><li><code>context::Dict{String, Any}</code>: Additional debugging context</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L52-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.CargoBuildError"><a class="docstring-binding" href="#RustCall.CargoBuildError"><code>RustCall.CargoBuildError</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CargoBuildError &lt;: Exception</code></pre><p>Exception type for Cargo build failures.</p><p><strong>Fields</strong></p><ul><li><code>message::String</code>: Error message</li><li><code>stderr::String</code>: Raw stderr output from cargo</li><li><code>project_path::String</code>: Path to the Cargo project that failed to build</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L81-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.DependencyResolutionError"><a class="docstring-binding" href="#RustCall.DependencyResolutionError"><code>RustCall.DependencyResolutionError</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DependencyResolutionError &lt;: Exception</code></pre><p>Exception type for dependency resolution failures.</p><p><strong>Fields</strong></p><ul><li><code>dependency::String</code>: Name of the problematic dependency</li><li><code>message::String</code>: Error message describing the resolution failure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L101-L109">source</a></section></details></article><h2 id="Type-Conversion-Functions"><a class="docs-heading-anchor" href="#Type-Conversion-Functions">Type Conversion Functions</a><a id="Type-Conversion-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Conversion-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RustCall.rusttype_to_julia"><a class="docstring-binding" href="#RustCall.rusttype_to_julia"><code>RustCall.rusttype_to_julia</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rusttype_to_julia(rust_type::Symbol) -&gt; Type</code></pre><p>Convert a Rust type name to the corresponding Julia type.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">rusttype_to_julia(:i32)  # =&gt; Int32
rusttype_to_julia(:f64)  # =&gt; Float64
rusttype_to_julia(:bool) # =&gt; Bool</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/typetranslation.jl#L78-L89">source</a></section><section><div><pre><code class="language-julia hljs">rusttype_to_julia(rust_type::String) -&gt; Type</code></pre><p>Convert a Rust type name string to the corresponding Julia type. Handles pointer types like <code>*const i32</code> and <code>*mut i32</code>. Also handles string types like <code>String</code> and <code>&amp;str</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/typetranslation.jl#L97-L103">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.juliatype_to_rust"><a class="docstring-binding" href="#RustCall.juliatype_to_rust"><code>RustCall.juliatype_to_rust</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">juliatype_to_rust(julia_type::Type) -&gt; String</code></pre><p>Convert a Julia type to the corresponding Rust type name.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">juliatype_to_rust(Int32)   # =&gt; &quot;i32&quot;
juliatype_to_rust(Float64) # =&gt; &quot;f64&quot;
juliatype_to_rust(Bool)    # =&gt; &quot;bool&quot;
juliatype_to_rust(String)  # =&gt; &quot;*const u8&quot; (for FFI)
juliatype_to_rust(Cstring) # =&gt; &quot;*const u8&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/typetranslation.jl#L148-L161">source</a></section></details></article><h2 id="Result/Option-Operations"><a class="docs-heading-anchor" href="#Result/Option-Operations">Result/Option Operations</a><a id="Result/Option-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Result/Option-Operations" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RustCall.unwrap"><a class="docstring-binding" href="#RustCall.unwrap"><code>RustCall.unwrap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unwrap(result::RustResult)</code></pre><p>Unwrap a RustResult, returning the Ok value or throwing an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L73-L77">source</a></section><section><div><pre><code class="language-julia hljs">unwrap(option::RustOption)</code></pre><p>Unwrap a RustOption, returning the Some value or throwing an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L123-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.unwrap_or"><a class="docstring-binding" href="#RustCall.unwrap_or"><code>RustCall.unwrap_or</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unwrap_or(result::RustResult{T, E}, default::T)</code></pre><p>Unwrap a RustResult, returning the Ok value or the provided default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L86-L90">source</a></section><section><div><pre><code class="language-julia hljs">unwrap_or(option::RustOption{T}, default::T)</code></pre><p>Unwrap a RustOption, returning the Some value or the provided default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L136-L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.is_ok"><a class="docstring-binding" href="#RustCall.is_ok"><code>RustCall.is_ok</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_ok(result::RustResult)</code></pre><p>Check if a RustResult is Ok.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L95-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.is_err"><a class="docstring-binding" href="#RustCall.is_err"><code>RustCall.is_err</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_err(result::RustResult)</code></pre><p>Check if a RustResult is Err.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L102-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.is_some"><a class="docstring-binding" href="#RustCall.is_some"><code>RustCall.is_some</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_some(option::RustOption)</code></pre><p>Check if a RustOption is Some.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L145-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.is_none"><a class="docstring-binding" href="#RustCall.is_none"><code>RustCall.is_none</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_none(option::RustOption)</code></pre><p>Check if a RustOption is None.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L152-L156">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.result_to_exception"><a class="docstring-binding" href="#RustCall.result_to_exception"><code>RustCall.result_to_exception</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">result_to_exception(result::RustResult{T, E}) where {T, E}</code></pre><p>Convert a RustResult to either return the Ok value or throw a RustError.</p><p><strong>Arguments</strong></p><ul><li><code>result::RustResult{T, E}</code>: The Rust result to convert</li></ul><p><strong>Returns</strong></p><ul><li>The Ok value of type <code>T</code> if the result is Ok</li></ul><p><strong>Throws</strong></p><ul><li><code>RustError</code> if the result is Err</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">result = RustResult{Int32, String}(false, &quot;division by zero&quot;)
try
    value = result_to_exception(result)
catch e
    @assert e isa RustError
    println(e.message)  # =&gt; &quot;division by zero&quot;
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L604-L628">source</a></section><section><div><pre><code class="language-julia hljs">result_to_exception(result::RustResult{T, E}, code::Int32) where {T, E}</code></pre><p>Convert a RustResult to either return the Ok value or throw a RustError with a specific error code.</p><p><strong>Arguments</strong></p><ul><li><code>result::RustResult{T, E}</code>: The Rust result to convert</li><li><code>code::Int32</code>: Error code to use if the result is Err</li></ul><p><strong>Returns</strong></p><ul><li>The Ok value of type <code>T</code> if the result is Ok</li></ul><p><strong>Throws</strong></p><ul><li><code>RustError</code> with the specified code if the result is Err</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L643-L657">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.unwrap_or_throw"><a class="docstring-binding" href="#RustCall.unwrap_or_throw"><code>RustCall.unwrap_or_throw</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unwrap_or_throw(result::RustResult{T, E}) where {T, E}</code></pre><p>Alias for <code>result_to_exception</code> that throws a RustError on Err.</p><p>This is a convenience function that provides a more Rust-like naming convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L668-L674">source</a></section><section><div><pre><code class="language-julia hljs">unwrap_or_throw(result::RustResult{T, E}, code::Int32) where {T, E}</code></pre><p>Alias for <code>result_to_exception</code> with error code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L677-L681">source</a></section></details></article><h2 id="String-Conversion-Functions"><a class="docs-heading-anchor" href="#String-Conversion-Functions">String Conversion Functions</a><a id="String-Conversion-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#String-Conversion-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RustCall.rust_string_to_julia"><a class="docstring-binding" href="#RustCall.rust_string_to_julia"><code>RustCall.rust_string_to_julia</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rust_string_to_julia(rs::RustString) -&gt; String</code></pre><p>Convert a RustString to a Julia String. This copies the data from Rust memory to Julia memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L222-L227">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.rust_str_to_julia"><a class="docstring-binding" href="#RustCall.rust_str_to_julia"><code>RustCall.rust_str_to_julia</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rust_str_to_julia(rs::RustStr) -&gt; String</code></pre><p>Convert a RustStr (string slice) to a Julia String. This copies the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L241-L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.julia_string_to_rust"><a class="docstring-binding" href="#RustCall.julia_string_to_rust"><code>RustCall.julia_string_to_rust</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">julia_string_to_rust(s::String) -&gt; RustStr</code></pre><p>Convert a Julia String to a RustStr (borrowed reference). Note: The returned RustStr is only valid while the Julia String exists. For FFI, you typically want to use Cstring instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L260-L266">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.julia_string_to_cstring"><a class="docstring-binding" href="#RustCall.julia_string_to_cstring"><code>RustCall.julia_string_to_cstring</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">julia_string_to_cstring(s::String) -&gt; String</code></pre><p>Prepare a Julia String for FFI (to be converted to Cstring by ccall). Note: The actual conversion happens at ccall time via cconvert/unsafe_convert.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L279-L284">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.cstring_to_julia_string"><a class="docstring-binding" href="#RustCall.cstring_to_julia_string"><code>RustCall.cstring_to_julia_string</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cstring_to_julia_string(cs::Cstring) -&gt; String</code></pre><p>Convert a Cstring (from Rust) to a Julia String. This copies the data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L289-L294">source</a></section></details></article><h2 id="Error-Handling"><a class="docs-heading-anchor" href="#Error-Handling">Error Handling</a><a id="Error-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Handling" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RustCall.format_rustc_error"><a class="docstring-binding" href="#RustCall.format_rustc_error"><code>RustCall.format_rustc_error</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">format_rustc_error(stderr::String) -&gt; String</code></pre><p>Format rustc error output to be more readable. Removes redundant information and highlights important parts.</p><p><strong>Improvements</strong></p><ul><li>Better error line highlighting</li><li>Context-aware formatting</li><li>Suggestion extraction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L412-L422">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.suggest_fix_for_error"><a class="docstring-binding" href="#RustCall.suggest_fix_for_error"><code>RustCall.suggest_fix_for_error</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">suggest_fix_for_error(stderr::String, source_code::String) -&gt; Vector{String}</code></pre><p>Analyze compilation error and suggest potential fixes.</p><p><strong>Returns</strong></p><ul><li>Vector of suggested fixes (strings)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L537-L544">source</a></section></details></article><h2 id="Compiler-Functions"><a class="docs-heading-anchor" href="#Compiler-Functions">Compiler Functions</a><a id="Compiler-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Compiler-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RustCall.RustCompiler"><a class="docstring-binding" href="#RustCall.RustCompiler"><code>RustCall.RustCompiler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustCompiler</code></pre><p>Configuration for the Rust compiler.</p><p><strong>Fields</strong></p><ul><li><code>target_triple::String</code>: Target triple for compilation</li><li><code>optimization_level::Int</code>: Optimization level 0-3</li><li><code>emit_debug_info::Bool</code>: Whether to emit debug info</li><li><code>debug_mode::Bool</code>: Enable debug mode (keep intermediate files, verbose output)</li><li><code>debug_dir::Union{String, Nothing}</code>: Directory to keep debug files (default: nothing = use temp dir)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/compiler.jl#L8-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.compile_with_recovery"><a class="docstring-binding" href="#RustCall.compile_with_recovery"><code>RustCall.compile_with_recovery</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compile_with_recovery(code::String, compiler::RustCompiler;
                      retry_count::Int=1) -&gt; String</code></pre><p>Compile Rust code with error recovery support. If compilation fails, attempts to retry with different compiler settings.</p><p><strong>Arguments</strong></p><ul><li><code>code::String</code>: Rust source code</li><li><code>compiler::RustCompiler</code>: Compiler configuration</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>retry_count::Int</code>: Number of retry attempts (default: 1)</li></ul><p><strong>Returns</strong></p><ul><li>Path to the generated shared library</li></ul><p><strong>Throws</strong></p><ul><li><code>CompilationError</code> if all recovery attempts fail</li></ul><p><strong>Note</strong></p><p>Cache recovery should be handled by the caller (e.g., in <code>ruststr.jl</code>). This function only handles retry with different compiler settings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/compiler.jl#L480-L503">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.check_rustc_available"><a class="docstring-binding" href="#RustCall.check_rustc_available"><code>RustCall.check_rustc_available</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">check_rustc_available() -&gt; Bool</code></pre><p>Check if rustc is available using RustToolChain.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/compiler.jl#L84-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_rustc_version"><a class="docstring-binding" href="#RustCall.get_rustc_version"><code>RustCall.get_rustc_version</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_rustc_version() -&gt; String</code></pre><p>Get the version of rustc using RustToolChain.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/compiler.jl#L98-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_default_compiler"><a class="docstring-binding" href="#RustCall.get_default_compiler"><code>RustCall.get_default_compiler</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_default_compiler() -&gt; RustCompiler</code></pre><p>Get or create the default RustCompiler instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/compiler.jl#L114-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.set_default_compiler"><a class="docstring-binding" href="#RustCall.set_default_compiler"><code>RustCall.set_default_compiler</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_default_compiler(compiler::RustCompiler)</code></pre><p>Set the default RustCompiler instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/compiler.jl#L126-L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.compile_rust_to_shared_lib"><a class="docstring-binding" href="#RustCall.compile_rust_to_shared_lib"><code>RustCall.compile_rust_to_shared_lib</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compile_rust_to_shared_lib(code::String; compiler=get_default_compiler()) -&gt; String</code></pre><p>Compile Rust code to a shared library and return the path.</p><p><strong>Arguments</strong></p><ul><li><code>code::String</code>: Rust source code</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>compiler::RustCompiler</code>: Compiler configuration (default: default compiler)</li></ul><p><strong>Returns</strong></p><ul><li>Path to the generated shared library</li></ul><p><strong>Throws</strong></p><ul><li><code>CompilationError</code> if compilation fails</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/compiler.jl#L304-L320">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.compile_rust_to_llvm_ir"><a class="docstring-binding" href="#RustCall.compile_rust_to_llvm_ir"><code>RustCall.compile_rust_to_llvm_ir</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compile_rust_to_llvm_ir(code::String; compiler=get_default_compiler()) -&gt; String</code></pre><p>Compile Rust code to LLVM IR and return the path to the generated .ll file.</p><p><strong>Arguments</strong></p><ul><li><code>code::String</code>: Rust source code</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>compiler::RustCompiler</code>: Compiler configuration (default: default compiler)</li></ul><p><strong>Returns</strong></p><ul><li>Path to the generated LLVM IR file (.ll)</li></ul><p><strong>Throws</strong></p><ul><li><code>CompilationError</code> if compilation fails</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/compiler.jl#L150-L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.load_llvm_ir"><a class="docstring-binding" href="#RustCall.load_llvm_ir"><code>RustCall.load_llvm_ir</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">load_llvm_ir(ir_file::String) -&gt; RustModule</code></pre><p>Load an LLVM IR file and create a RustModule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmintegration.jl#L28-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.wrap_rust_code"><a class="docstring-binding" href="#RustCall.wrap_rust_code"><code>RustCall.wrap_rust_code</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">wrap_rust_code(code::String) -&gt; String</code></pre><p>Wrap Rust code to ensure it has the necessary FFI exports. This adds common imports and ensures extern &quot;C&quot; functions are properly exposed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/compiler.jl#L459-L464">source</a></section></details></article><h2 id="Ownership-Type-Operations"><a class="docs-heading-anchor" href="#Ownership-Type-Operations">Ownership Type Operations</a><a id="Ownership-Type-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Ownership-Type-Operations" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RustCall.drop!"><a class="docstring-binding" href="#RustCall.drop!"><code>RustCall.drop!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">drop!(x::Union{RustBox, RustRc, RustArc, RustVec})</code></pre><p>Mark an ownership type as dropped. The actual memory deallocation should be handled by Rust-side drop functions.</p><p>Note: This sets the dropped flag to prevent double-drop but does not actually free memory. Call the appropriate Rust drop function for that.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L830-L838">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.is_dropped"><a class="docstring-binding" href="#RustCall.is_dropped"><code>RustCall.is_dropped</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_dropped(x::Union{RustBox, RustRc, RustArc, RustVec}) -&gt; Bool</code></pre><p>Check if an ownership type has been dropped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L845-L849">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.is_valid"><a class="docstring-binding" href="#RustCall.is_valid"><code>RustCall.is_valid</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_valid(box::RustBox) -&gt; Bool</code></pre><p>Check if a RustBox is still valid (not dropped and not null).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L359-L363">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.clone"><a class="docstring-binding" href="#RustCall.clone"><code>RustCall.clone</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">clone(rc::RustRc{T}) -&gt; RustRc{T} where T</code></pre><p>Clone a RustRc, incrementing the reference count.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L426-L430">source</a></section><section><div><pre><code class="language-julia hljs">clone(arc::RustArc{T}) -&gt; RustArc{T} where T</code></pre><p>Clone a RustArc, incrementing the atomic reference count.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L548-L552">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.is_rust_helpers_available"><a class="docstring-binding" href="#RustCall.is_rust_helpers_available"><code>RustCall.is_rust_helpers_available</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_rust_helpers_available() -&gt; Bool</code></pre><p>Check if the Rust helpers library is available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L146-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_rust_helpers_lib"><a class="docstring-binding" href="#RustCall.get_rust_helpers_lib"><code>RustCall.get_rust_helpers_lib</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_rust_helpers_lib() -&gt; Union{Ptr{Cvoid}, Nothing}</code></pre><p>Get or load the Rust helpers library. This library provides FFI functions for Box, Rc, Arc operations. Returns nothing if the library is not available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L135-L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_rust_helpers_lib_path"><a class="docstring-binding" href="#RustCall.get_rust_helpers_lib_path"><code>RustCall.get_rust_helpers_lib_path</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_rust_helpers_lib_path() -&gt; Union{String, Nothing}</code></pre><p>Get the path to the Rust helpers library if it exists (either built or in a standard location). Returns nothing if the library is not found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L177-L182">source</a></section></details></article><h2 id="RustVec-Operations"><a class="docs-heading-anchor" href="#RustVec-Operations">RustVec Operations</a><a id="RustVec-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#RustVec-Operations" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RustCall.create_rust_vec"><a class="docstring-binding" href="#RustCall.create_rust_vec"><code>RustCall.create_rust_vec</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_rust_vec(v::Vector{T}) -&gt; RustVec{T}</code></pre><p>Create a <code>RustVec</code> from a Julia <code>Vector</code> by copying data to Rust-managed memory.</p><p><strong>Arguments</strong></p><ul><li><code>v::Vector{T}</code>: A Julia Vector to convert. Supported types: <code>Int32</code>, <code>Int64</code>, <code>Float32</code>, <code>Float64</code></li></ul><p><strong>Returns</strong></p><ul><li><code>RustVec{T}</code>: A new RustVec containing a copy of the data</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If the Rust helpers library is not loaded</li><li><code>ErrorException</code>: If the element type is not supported</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia_vec = Int32[1, 2, 3, 4, 5]
rust_vec = create_rust_vec(julia_vec)
@assert length(rust_vec) == 5
drop!(rust_vec)  # Clean up when done</code></pre><p><strong>Note</strong></p><p>The data is copied to Rust-managed memory. The original Julia array is not modified. Remember to call <code>drop!(rust_vec)</code> when done to free Rust memory.</p><p>See also: <a href="#RustCall.to_julia_vector"><code>to_julia_vector</code></a>, <a href="#RustCall.drop!"><code>drop!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L710-L738">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.rust_vec_get"><a class="docstring-binding" href="#RustCall.rust_vec_get"><code>RustCall.rust_vec_get</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rust_vec_get(vec::RustVec{T}, index::Integer) -&gt; T</code></pre><p>Get an element from <code>RustVec</code> using Rust FFI with <strong>0-based indexing</strong>.</p><p><strong>Arguments</strong></p><ul><li><code>vec::RustVec{T}</code>: The RustVec to access</li><li><code>index::Integer</code>: 0-based index of the element to retrieve</li></ul><p><strong>Returns</strong></p><ul><li><code>T</code>: The element at the specified index</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If the vec has been dropped</li><li><code>BoundsError</code>: If index is out of bounds</li><li><code>ErrorException</code>: If the Rust helpers library is not loaded</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">rust_vec = create_rust_vec(Int32[10, 20, 30])
value = rust_vec_get(rust_vec, 0)  # Returns 10
value = rust_vec_get(rust_vec, 2)  # Returns 30
drop!(rust_vec)</code></pre><p><strong>Note</strong></p><p>This function uses <strong>0-based indexing</strong> to match Rust&#39;s convention. For 1-based indexing, use <code>vec[i]</code> syntax instead.</p><p>See also: <a href="#RustCall.rust_vec_set!"><code>rust_vec_set!</code></a>, <code>getindex</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L771-L801">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.rust_vec_set!"><a class="docstring-binding" href="#RustCall.rust_vec_set!"><code>RustCall.rust_vec_set!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rust_vec_set!(vec::RustVec{T}, index::Integer, value::T) -&gt; Bool</code></pre><p>Set an element in RustVec using Rust FFI (0-indexed). Returns true if successful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L834-L839">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.copy_to_julia!"><a class="docstring-binding" href="#RustCall.copy_to_julia!"><code>RustCall.copy_to_julia!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">copy_to_julia!(vec::RustVec{T}, dest::Vector{T}) -&gt; Int</code></pre><p>Copy <code>RustVec</code> contents to a pre-allocated Julia <code>Vector</code> using efficient Rust FFI.</p><p>This is the most efficient way to transfer data from Rust to Julia when you already have a destination buffer allocated.</p><p><strong>Arguments</strong></p><ul><li><code>vec::RustVec{T}</code>: Source RustVec to copy from</li><li><code>dest::Vector{T}</code>: Pre-allocated destination Julia Vector</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Number of elements actually copied (min of source and dest lengths)</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If the vec has been dropped</li><li><code>ErrorException</code>: If the Rust helpers library is not loaded</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">rust_vec = create_rust_vec(Int32[1, 2, 3, 4, 5])

# Copy all elements
dest = Vector{Int32}(undef, 5)
n = copy_to_julia!(rust_vec, dest)
@assert n == 5 &amp;&amp; dest == Int32[1, 2, 3, 4, 5]

# Copy to smaller buffer (partial copy)
small_dest = Vector{Int32}(undef, 3)
n = copy_to_julia!(rust_vec, small_dest)
@assert n == 3 &amp;&amp; small_dest == Int32[1, 2, 3]

drop!(rust_vec)</code></pre><p><strong>Performance</strong></p><p>This function uses a single FFI call to copy all data, making it much more efficient than element-by-element access for large vectors.</p><p>See also: <a href="#RustCall.to_julia_vector"><code>to_julia_vector</code></a>, <a href="#RustCall.create_rust_vec"><code>create_rust_vec</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L926-L967">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.to_julia_vector"><a class="docstring-binding" href="#RustCall.to_julia_vector"><code>RustCall.to_julia_vector</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">to_julia_vector(vec::RustVec{T}) -&gt; Vector{T}</code></pre><p>Convert a <code>RustVec</code> to a new Julia <code>Vector</code> using efficient Rust FFI copy.</p><p>This is the recommended way to convert <code>RustVec</code> data to Julia when you don&#39;t have a pre-allocated buffer.</p><p><strong>Arguments</strong></p><ul><li><code>vec::RustVec{T}</code>: The RustVec to convert</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{T}</code>: A new Julia Vector containing a copy of the data</li></ul><p><strong>Throws</strong></p><ul><li><code>ErrorException</code>: If the vec has been dropped</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">rust_vec = create_rust_vec(Int32[1, 2, 3, 4, 5])
julia_vec = to_julia_vector(rust_vec)
@assert julia_vec == Int32[1, 2, 3, 4, 5]
drop!(rust_vec)</code></pre><p><strong>Note</strong></p><p>This function allocates a new Julia Vector. If you already have a buffer, use <code>copy_to_julia!</code> instead for better performance.</p><p>See also: <a href="#RustCall.copy_to_julia!"><code>copy_to_julia!</code></a>, <a href="#RustCall.create_rust_vec"><code>create_rust_vec</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L999-L1029">source</a></section></details></article><h2 id="Cache-Management"><a class="docs-heading-anchor" href="#Cache-Management">Cache Management</a><a id="Cache-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Cache-Management" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RustCall.clear_cache"><a class="docstring-binding" href="#RustCall.clear_cache"><code>RustCall.clear_cache</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">clear_cache()</code></pre><p>Clear all cached libraries and metadata. On Windows, some files may be locked and cannot be deleted immediately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cache.jl#L249-L254">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_cache_size"><a class="docstring-binding" href="#RustCall.get_cache_size"><code>RustCall.get_cache_size</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_cache_size() -&gt; Int64</code></pre><p>Get the total size of the cache directory in bytes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cache.jl#L294-L298">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.list_cached_libraries"><a class="docstring-binding" href="#RustCall.list_cached_libraries"><code>RustCall.list_cached_libraries</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">list_cached_libraries() -&gt; Vector{String}</code></pre><p>List all cache keys for cached libraries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cache.jl#L318-L322">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.cleanup_old_cache"><a class="docstring-binding" href="#RustCall.cleanup_old_cache"><code>RustCall.cleanup_old_cache</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cleanup_old_cache(max_age_days::Int = 30)</code></pre><p>Remove cache entries older than max<em>age</em>days.</p><p><strong>Arguments</strong></p><ul><li><code>max_age_days::Int</code>: Maximum age in days (default: 30)</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Number of removed cache entries</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Remove cache entries older than 7 days
count = cleanup_old_cache(7)
println(&quot;Removed $count old cache entries&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cache.jl#L343-L360">source</a></section></details></article><h2 id="LLVM-Optimization"><a class="docs-heading-anchor" href="#LLVM-Optimization">LLVM Optimization</a><a id="LLVM-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#LLVM-Optimization" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RustCall.OptimizationConfig"><a class="docstring-binding" href="#RustCall.OptimizationConfig"><code>RustCall.OptimizationConfig</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OptimizationConfig</code></pre><p>Configuration for LLVM optimization passes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmoptimization.jl#L6-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.optimize_module!"><a class="docstring-binding" href="#RustCall.optimize_module!"><code>RustCall.optimize_module!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">optimize_module!(mod::LLVM.Module; config=get_default_opt_config())</code></pre><p>Apply optimization passes to an LLVM module using LLVM&#39;s New Pass Manager. Returns the optimized module (modified in place).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmoptimization.jl#L53-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.optimize_for_speed!"><a class="docstring-binding" href="#RustCall.optimize_for_speed!"><code>RustCall.optimize_for_speed!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">optimize_for_speed!(mod::LLVM.Module)</code></pre><p>Apply optimizations focused on execution speed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmoptimization.jl#L200-L204">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.optimize_for_size!"><a class="docstring-binding" href="#RustCall.optimize_for_size!"><code>RustCall.optimize_for_size!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">optimize_for_size!(mod::LLVM.Module)</code></pre><p>Apply optimizations focused on code size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmoptimization.jl#L217-L221">source</a></section></details></article><h2 id="LLVM-Function-Registration"><a class="docs-heading-anchor" href="#LLVM-Function-Registration">LLVM Function Registration</a><a id="LLVM-Function-Registration-1"></a><a class="docs-heading-anchor-permalink" href="#LLVM-Function-Registration" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RustCall.RustFunctionInfo"><a class="docstring-binding" href="#RustCall.RustFunctionInfo"><code>RustCall.RustFunctionInfo</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustFunctionInfo</code></pre><p>Information about a compiled Rust function for llvmcall.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmcodegen.jl#L37-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.compile_and_register_rust_function"><a class="docstring-binding" href="#RustCall.compile_and_register_rust_function"><code>RustCall.compile_and_register_rust_function</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compile_and_register_rust_function(code::String, func_name::String)</code></pre><p>Compile Rust code and register the function for llvmcall usage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmcodegen.jl#L192-L196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.julia_type_to_llvm_ir_string"><a class="docstring-binding" href="#RustCall.julia_type_to_llvm_ir_string"><code>RustCall.julia_type_to_llvm_ir_string</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">julia_type_to_llvm_ir_string(t::Type) -&gt; String</code></pre><p>Convert a Julia type to its LLVM IR string representation. Supports basic types, pointers, tuples, and structs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmcodegen.jl#L98-L103">source</a></section></details></article><h2 id="Generics-Support"><a class="docs-heading-anchor" href="#Generics-Support">Generics Support</a><a id="Generics-Support-1"></a><a class="docs-heading-anchor-permalink" href="#Generics-Support" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RustCall.register_generic_function"><a class="docstring-binding" href="#RustCall.register_generic_function"><code>RustCall.register_generic_function</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">register_generic_function(func_name, code, type_params, constraints, context)</code></pre><p>Register a generic Rust function for later monomorphization.</p><p><strong>Arguments</strong></p><ul><li><code>func_name</code>: Name of the function</li><li><code>code</code>: Rust function code (with generics)</li><li><code>type_params</code>: List of type parameter symbols</li><li><code>constraints</code>: Trait bounds for type parameters (TypeConstraints or legacy Dict{Symbol, String})</li><li><code>context</code>: Additional code (e.g. struct definitions) needed for compilation</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># With TypeConstraints (recommended)
constraints = Dict(:T =&gt; TypeConstraints([TraitBound(&quot;Copy&quot;, []), TraitBound(&quot;Clone&quot;, [])]))
register_generic_function(&quot;identity&quot;, code, [:T], constraints)

# Legacy format (still supported)
register_generic_function(&quot;identity&quot;, code, [:T], Dict(:T =&gt; &quot;Copy + Clone&quot;))

# No constraints
register_generic_function(&quot;identity&quot;, code, [:T])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L869-L893">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.call_generic_function"><a class="docstring-binding" href="#RustCall.call_generic_function"><code>RustCall.call_generic_function</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">call_generic_function(func_name::String, args...)</code></pre><p>Call a generic Rust function, automatically monomorphizing if needed.</p><p><strong>Arguments</strong></p><ul><li><code>func_name</code>: Name of the generic function</li><li><code>args...</code>: Arguments (types will be inferred from these)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Assuming identity&lt;T&gt; is registered
result = call_generic_function(&quot;identity&quot;, Int32(42))
# Automatically monomorphizes to identity&lt;Int32&gt; and calls it</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L924-L939">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.is_generic_function"><a class="docstring-binding" href="#RustCall.is_generic_function"><code>RustCall.is_generic_function</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_generic_function(func_name::String) -&gt; Bool</code></pre><p>Check if a function is registered as a generic function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L956-L960">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.monomorphize_function"><a class="docstring-binding" href="#RustCall.monomorphize_function"><code>RustCall.monomorphize_function</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">monomorphize_function(func_name::String, type_params::Dict{Symbol, Type}) -&gt; FunctionInfo</code></pre><p>Monomorphize a generic function with specific type parameters.</p><p><strong>Arguments</strong></p><ul><li><code>func_name</code>: Name of the generic function</li><li><code>type_params</code>: Mapping from type parameter symbols to concrete types</li></ul><p><strong>Returns</strong></p><ul><li>FunctionInfo for the monomorphized function</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Register generic function
register_generic_function(&quot;identity&quot;, &quot;pub fn identity&lt;T&gt;(x: T) -&gt; T { x }&quot;, [:T])

# Monomorphize with Int32
info = monomorphize_function(&quot;identity&quot;, Dict{Symbol, Type}(:T =&gt; Int32))
# Returns FunctionInfo for identity_i32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L677-L698">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.specialize_generic_code"><a class="docstring-binding" href="#RustCall.specialize_generic_code"><code>RustCall.specialize_generic_code</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">specialize_generic_code(code::String, type_params::Dict{Symbol, Type}) -&gt; String</code></pre><p>Specialize a generic Rust function by replacing type parameters with concrete types.</p><p><strong>Arguments</strong></p><ul><li><code>code</code>: The generic Rust function code</li><li><code>type_params</code>: Mapping from type parameter symbols to concrete Julia types</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">code = &quot;pub fn identity&lt;T&gt;(x: T) -&gt; T { x }&quot;
type_params = Dict(:T =&gt; Int32)
specialize_generic_code(code, type_params)
# Returns: &quot;pub fn identity(x: i32) -&gt; i32 { x }&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L557-L573">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.infer_type_parameters"><a class="docstring-binding" href="#RustCall.infer_type_parameters"><code>RustCall.infer_type_parameters</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">infer_type_parameters(func_name::String, arg_types::Vector{Type}) -&gt; Dict{Symbol, Type}</code></pre><p>Infer type parameters for a generic function from argument types.</p><p><strong>Arguments</strong></p><ul><li><code>func_name</code>: Name of the generic function</li><li><code>arg_types</code>: Types of the arguments passed to the function</li></ul><p><strong>Returns</strong></p><ul><li>Dictionary mapping type parameter symbols to concrete types</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># For function: fn identity&lt;T&gt;(x: T) -&gt; T
# Called with: identity(Int32(42))
# Returns: Dict(:T =&gt; Int32)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L629-L647">source</a></section></details></article><h2 id="Generic-Constraints"><a class="docs-heading-anchor" href="#Generic-Constraints">Generic Constraints</a><a id="Generic-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-Constraints" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RustCall.TraitBound"><a class="docstring-binding" href="#RustCall.TraitBound"><code>RustCall.TraitBound</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TraitBound</code></pre><p>Represents a single trait bound with optional type parameters.</p><p><strong>Fields</strong></p><ul><li><code>trait_name::String</code>: Name of the trait (e.g., &quot;Copy&quot;, &quot;Add&quot;)</li><li><code>type_params::Vector{String}</code>: Type parameters for the trait (e.g., [&quot;Output = T&quot;] for Add&lt;Output = T&gt;)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L7-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.TypeConstraints"><a class="docstring-binding" href="#RustCall.TypeConstraints"><code>RustCall.TypeConstraints</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TypeConstraints</code></pre><p>Represents all trait bounds for a type parameter.</p><p><strong>Fields</strong></p><ul><li><code>bounds::Vector{TraitBound}</code>: List of trait bounds (e.g., [Copy, Clone, Add&lt;Output = T&gt;])</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L33-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.GenericFunctionInfo"><a class="docstring-binding" href="#RustCall.GenericFunctionInfo"><code>RustCall.GenericFunctionInfo</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GenericFunctionInfo</code></pre><p>Information about a generic Rust function that needs monomorphization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L59-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_trait_bounds"><a class="docstring-binding" href="#RustCall.parse_trait_bounds"><code>RustCall.parse_trait_bounds</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">parse_trait_bounds(bounds_str::AbstractString) -&gt; TypeConstraints</code></pre><p>Parse a trait bounds string like &quot;Copy + Clone + Add&lt;Output = T&gt;&quot;.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">parse_trait_bounds(&quot;Copy + Clone&quot;)
# =&gt; TypeConstraints([TraitBound(&quot;Copy&quot;, []), TraitBound(&quot;Clone&quot;, [])])

parse_trait_bounds(&quot;Copy + Add&lt;Output = T&gt;&quot;)
# =&gt; TypeConstraints([TraitBound(&quot;Copy&quot;, []), TraitBound(&quot;Add&quot;, [&quot;Output = T&quot;])])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L174-L187">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_single_trait"><a class="docstring-binding" href="#RustCall.parse_single_trait"><code>RustCall.parse_single_trait</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">parse_single_trait(trait_str::String) -&gt; TraitBound</code></pre><p>Parse a single trait bound string like &quot;Copy&quot;, &quot;Add&lt;Output = T&gt;&quot;, or &quot;Into&lt;String&gt;&quot;.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">parse_single_trait(&quot;Copy&quot;)
# =&gt; TraitBound(&quot;Copy&quot;, [])

parse_single_trait(&quot;Add&lt;Output = T&gt;&quot;)
# =&gt; TraitBound(&quot;Add&quot;, [&quot;Output = T&quot;])

parse_single_trait(&quot;Into&lt;String&gt;&quot;)
# =&gt; TraitBound(&quot;Into&quot;, [&quot;String&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L88-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_where_clause"><a class="docstring-binding" href="#RustCall.parse_where_clause"><code>RustCall.parse_where_clause</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">parse_where_clause(code::AbstractString) -&gt; Dict{Symbol, TypeConstraints}</code></pre><p>Parse a where clause from Rust code.</p><p><strong>Supported formats</strong></p><ul><li><code>where T: Copy + Clone, U: Debug</code></li><li><code>where T: Copy + Clone</code></li></ul><p><strong>Returns</strong></p><ul><li>Dictionary mapping type parameters to their constraints</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">code = &quot;fn foo&lt;T, U&gt;(x: T) -&gt; U where T: Copy + Clone, U: Debug { ... }&quot;
parse_where_clause(code)
# =&gt; Dict(:T =&gt; TypeConstraints([Copy, Clone]), :U =&gt; TypeConstraints([Debug]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L296-L314">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_inline_constraints"><a class="docstring-binding" href="#RustCall.parse_inline_constraints"><code>RustCall.parse_inline_constraints</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">parse_inline_constraints(type_params_str::AbstractString) -&gt; Tuple{Vector{Symbol}, Dict{Symbol, TypeConstraints}}</code></pre><p>Parse inline type parameters with constraints like &quot;T: Copy + Clone, U: Debug&quot;.</p><p><strong>Returns</strong></p><ul><li>Tuple of (type_params, constraints)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">parse_inline_constraints(&quot;T: Copy + Clone, U: Debug&quot;)
# =&gt; ([:T, :U], Dict(:T =&gt; TypeConstraints([Copy, Clone]), :U =&gt; TypeConstraints([Debug])))

parse_inline_constraints(&quot;T, U&quot;)
# =&gt; ([:T, :U], Dict())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L224-L240">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_generic_function"><a class="docstring-binding" href="#RustCall.parse_generic_function"><code>RustCall.parse_generic_function</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">parse_generic_function(code::AbstractString, func_name::AbstractString) -&gt; Union{GenericFunctionInfo, Nothing}</code></pre><p>Parse a Rust function to detect if it&#39;s generic and extract type parameters with trait bounds.</p><p><strong>Supported formats</strong></p><ol><li>Inline bounds: <code>fn foo&lt;T: Copy + Clone, U: Debug&gt;(x: T) -&gt; U</code></li><li>Where clause: <code>fn foo&lt;T, U&gt;(x: T) -&gt; U where T: Copy + Clone, U: Debug</code></li><li>Mixed: <code>fn foo&lt;T: Copy, U&gt;(x: T) -&gt; U where U: Debug</code></li></ol><p><strong>Example</strong></p><pre><code class="language-rust hljs">pub fn identity&lt;T: Copy + Clone&gt;(x: T) -&gt; T { x }</code></pre><p>This would be parsed as:</p><ul><li>name: &quot;identity&quot;</li><li>type_params: [:T]</li><li>constraints: Dict(:T =&gt; TypeConstraints([Copy, Clone]))</li></ul><pre><code class="language-rust hljs">pub fn transform&lt;T, U&gt;(x: T) -&gt; U where T: Copy, U: From&lt;T&gt; { ... }</code></pre><p>This would be parsed as:</p><ul><li>name: &quot;transform&quot;</li><li>type_params: [:T, :U]</li><li>constraints: Dict(:T =&gt; TypeConstraints([Copy]), :U =&gt; TypeConstraints([From&lt;T&gt;]))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L438-L464">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.constraints_to_rust_string"><a class="docstring-binding" href="#RustCall.constraints_to_rust_string"><code>RustCall.constraints_to_rust_string</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">constraints_to_rust_string(constraints::Dict{Symbol, TypeConstraints}) -&gt; String</code></pre><p>Convert constraints back to Rust syntax for code generation.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">constraints = Dict(:T =&gt; TypeConstraints([TraitBound(&quot;Copy&quot;, []), TraitBound(&quot;Clone&quot;, [])]))
constraints_to_rust_string(constraints)
# =&gt; &quot;T: Copy + Clone&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L399-L410">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.merge_constraints"><a class="docstring-binding" href="#RustCall.merge_constraints"><code>RustCall.merge_constraints</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">merge_constraints(c1::Dict{Symbol, TypeConstraints}, c2::Dict{Symbol, TypeConstraints}) -&gt; Dict{Symbol, TypeConstraints}</code></pre><p>Merge two constraint dictionaries. If a type parameter exists in both, merge their bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L368-L372">source</a></section></details></article><h2 id="External-Library-Integration"><a class="docs-heading-anchor" href="#External-Library-Integration">External Library Integration</a><a id="External-Library-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#External-Library-Integration" title="Permalink"></a></h2><h3 id="Dependency-Management"><a class="docs-heading-anchor" href="#Dependency-Management">Dependency Management</a><a id="Dependency-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Dependency-Management" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="RustCall.DependencySpec"><a class="docstring-binding" href="#RustCall.DependencySpec"><code>RustCall.DependencySpec</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DependencySpec</code></pre><p>Represents a single Rust crate dependency specification.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Crate name</li><li><code>version::Union{String, Nothing}</code>: Version specification (e.g., &quot;0.15&quot;, &quot;1.0&quot;)</li><li><code>features::Vector{String}</code>: List of crate features to enable</li><li><code>git::Union{String, Nothing}</code>: Git repository URL (for git dependencies)</li><li><code>path::Union{String, Nothing}</code>: Local path (for path dependencies)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependencies.jl#L6-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_dependencies_from_code"><a class="docstring-binding" href="#RustCall.parse_dependencies_from_code"><code>RustCall.parse_dependencies_from_code</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">parse_dependencies_from_code(code::String) -&gt; Vector{DependencySpec}</code></pre><p>Parse dependencies from Rust code that contains rustscript-style dependency specifications.</p><p>Supports two formats:</p><ol><li><p>Document comment format:</p><pre><code class="nohighlight hljs">//! ```cargo
//! [dependencies]
//! ndarray = &quot;0.15&quot;
//! serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
//! ```</code></pre></li><li><p>Single-line comment format:</p><pre><code class="nohighlight hljs">// cargo-deps: ndarray=&quot;0.15&quot;, serde=&quot;1.0&quot;</code></pre></li></ol><p><strong>Arguments</strong></p><ul><li><code>code::String</code>: Rust source code potentially containing dependency specifications</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{DependencySpec}</code>: List of parsed dependencies (empty if none found)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependencies.jl#L52-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.has_dependencies"><a class="docstring-binding" href="#RustCall.has_dependencies"><code>RustCall.has_dependencies</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_dependencies(code::String) -&gt; Bool</code></pre><p>Check if code contains any dependency specifications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependencies.jl#L471-L475">source</a></section></details></article><h3 id="Cargo-Project-Management"><a class="docs-heading-anchor" href="#Cargo-Project-Management">Cargo Project Management</a><a id="Cargo-Project-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Cargo-Project-Management" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="RustCall.CargoProject"><a class="docstring-binding" href="#RustCall.CargoProject"><code>RustCall.CargoProject</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CargoProject</code></pre><p>Represents a temporary Cargo project for building Rust code with dependencies.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Project/crate name</li><li><code>version::String</code>: Project version (default &quot;0.1.0&quot;)</li><li><code>dependencies::Vector{DependencySpec}</code>: List of dependencies</li><li><code>edition::String</code>: Rust edition (default &quot;2021&quot;)</li><li><code>path::String</code>: Path to the project directory</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargoproject.jl#L21-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.create_cargo_project"><a class="docstring-binding" href="#RustCall.create_cargo_project"><code>RustCall.create_cargo_project</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_cargo_project(name::String, dependencies::Vector{DependencySpec}; kwargs...) -&gt; CargoProject</code></pre><p>Create a temporary Cargo project with the specified dependencies.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: Project name (used as crate name)</li><li><code>dependencies::Vector{DependencySpec}</code>: List of dependencies</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>edition::String</code>: Rust edition (default: &quot;2021&quot;)</li><li><code>path::Union{String, Nothing}</code>: Project path (default: auto-generated temp directory)</li></ul><p><strong>Returns</strong></p><ul><li><code>CargoProject</code>: The created project</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">deps = [DependencySpec(&quot;ndarray&quot;, version=&quot;0.15&quot;)]
project = create_cargo_project(&quot;my_project&quot;, deps)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargoproject.jl#L41-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.build_cargo_project"><a class="docstring-binding" href="#RustCall.build_cargo_project"><code>RustCall.build_cargo_project</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">build_cargo_project(project::CargoProject; release::Bool = true) -&gt; String</code></pre><p>Build a Cargo project and return the path to the compiled library.</p><p><strong>Arguments</strong></p><ul><li><code>project::CargoProject</code>: The Cargo project to build</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>release::Bool</code>: Build in release mode (default: true for better performance)</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Path to the compiled shared library</li></ul><p><strong>Throws</strong></p><ul><li><code>CargoBuildError</code> if the build fails</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargobuild.jl#L8-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.clear_cargo_cache"><a class="docstring-binding" href="#RustCall.clear_cargo_cache"><code>RustCall.clear_cargo_cache</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">clear_cargo_cache()</code></pre><p>Clear all cached Cargo-built libraries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargobuild.jl#L268-L272">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_cargo_cache_size"><a class="docstring-binding" href="#RustCall.get_cargo_cache_size"><code>RustCall.get_cargo_cache_size</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_cargo_cache_size() -&gt; Int64</code></pre><p>Get the total size of the Cargo cache in bytes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargobuild.jl#L281-L285">source</a></section></details></article><h2 id="Crate-Bindings"><a class="docs-heading-anchor" href="#Crate-Bindings">Crate Bindings</a><a id="Crate-Bindings-1"></a><a class="docs-heading-anchor-permalink" href="#Crate-Bindings" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RustCall.CrateInfo"><a class="docstring-binding" href="#RustCall.CrateInfo"><code>RustCall.CrateInfo</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CrateInfo</code></pre><p>Information about a Rust crate for binding generation.</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: Crate name from Cargo.toml</li><li><code>path::String</code>: Path to the crate root directory</li><li><code>version::String</code>: Crate version</li><li><code>dependencies::Vector{DependencySpec}</code>: Crate dependencies</li><li><code>julia_functions::Vector{RustFunctionSignature}</code>: Functions marked with #[julia]</li><li><code>julia_structs::Vector{RustStructInfo}</code>: Structs marked with #[julia]</li><li><code>source_files::Vector{String}</code>: Paths to .rs source files</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L23-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.CrateBindingOptions"><a class="docstring-binding" href="#RustCall.CrateBindingOptions"><code>RustCall.CrateBindingOptions</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CrateBindingOptions</code></pre><p>Options for binding generation.</p><p><strong>Fields</strong></p><ul><li><code>output_module_name::Union{String, Nothing}</code>: Name for the generated module (default: crate name)</li><li><code>output_path::Union{String, Nothing}</code>: Path to write generated Julia code</li><li><code>use_wrapper_crate::Bool</code>: Whether to create a wrapper crate for building</li><li><code>build_release::Bool</code>: Build in release mode</li><li><code>cache_enabled::Bool</code>: Enable caching of compiled libraries</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L47-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.scan_crate"><a class="docstring-binding" href="#RustCall.scan_crate"><code>RustCall.scan_crate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">scan_crate(crate_path::String) -&gt; CrateInfo</code></pre><p>Scan a Rust crate and extract information about #[julia] marked items.</p><p><strong>Arguments</strong></p><ul><li><code>crate_path::String</code>: Path to the crate root directory (containing Cargo.toml)</li></ul><p><strong>Returns</strong></p><ul><li><code>CrateInfo</code>: Information about the crate including functions and structs</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">info = scan_crate(&quot;/path/to/my_crate&quot;)
println(&quot;Found $(length(info.julia_functions)) Julia functions&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L86-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.generate_bindings"><a class="docstring-binding" href="#RustCall.generate_bindings"><code>RustCall.generate_bindings</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">generate_bindings(crate_path::String; kwargs...) -&gt; Expr</code></pre><p>Generate Julia bindings for an external Rust crate.</p><p>This is the main entry point for the Maturin-like feature. It scans the crate, creates a wrapper crate if needed, builds it, and generates Julia bindings.</p><p><strong>Arguments</strong></p><ul><li><code>crate_path::String</code>: Path to the Rust crate root directory</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>output_module_name::Union{String, Nothing}</code>: Name for the generated module</li><li><code>build_release::Bool</code>: Build in release mode (default: true)</li><li><code>cache_enabled::Bool</code>: Enable caching (default: true)</li></ul><p><strong>Returns</strong></p><ul><li><code>Expr</code>: A module expression containing all bindings</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">bindings = generate_bindings(&quot;/path/to/my_crate&quot;)
eval(bindings)
# Now MyCrate module is available
MyCrate.add(1, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L976-L1002">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.write_bindings_to_file"><a class="docstring-binding" href="#RustCall.write_bindings_to_file"><code>RustCall.write_bindings_to_file</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">write_bindings_to_file(crate_path::String, output_path::String; kwargs...) -&gt; String</code></pre><p>Generate Julia bindings for a Rust crate and write them to a file.</p><p>This function is designed for package development workflow where bindings should be generated once and then included in the package for precompilation.</p><p><strong>Arguments</strong></p><ul><li><code>crate_path::String</code>: Path to the Rust crate root directory</li><li><code>output_path::String</code>: Path to write the generated Julia code</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>output_module_name::Union{String, Nothing}</code>: Name for the generated module</li><li><code>build_release::Bool</code>: Build in release mode (default: true)</li><li><code>relative_lib_path::Union{String, Nothing}</code>: Path to library relative to the generated file If not provided, uses the absolute path to the compiled library.</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Path to the generated Julia file</li></ul><p><strong>Workflow for Package Development</strong></p><ol><li><p>During development, call <code>write_bindings_to_file</code> to generate bindings:</p><pre><code class="language-julia hljs">using RustCall
write_bindings_to_file(
    &quot;deps/my_rust_crate&quot;,
    &quot;src/generated/MyRustBindings.jl&quot;,
    relative_lib_path = &quot;../deps/lib&quot;
)</code></pre></li><li><p>Include the generated file in your package:</p><pre><code class="language-julia hljs"># In src/MyPackage.jl
include(&quot;generated/MyRustBindings.jl&quot;)</code></pre></li><li><p>The generated module will be precompiled with your package.</p></li></ol><p><strong>Example</strong></p><pre><code class="language-julia hljs">using RustCall

# Generate bindings to a file
write_bindings_to_file(
    &quot;/path/to/my_crate&quot;,
    &quot;src/MyCrateBindings.jl&quot;,
    output_module_name = &quot;MyCrate&quot;
)

# The file can now be included in your package</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L1198-L1252">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.@rust_crate"><a class="docstring-binding" href="#RustCall.@rust_crate"><code>RustCall.@rust_crate</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@rust_crate(path)
@rust_crate(path, options...)</code></pre><p>Generate and load bindings for an external Rust crate.</p><p><strong>Arguments</strong></p><ul><li><code>path</code>: Path to the Rust crate (string literal)</li></ul><p><strong>Options</strong></p><ul><li><code>name=&quot;ModuleName&quot;</code>: Override the generated module name</li><li><code>release=true/false</code>: Build in release mode (default: true)</li><li><code>cache=true/false</code>: Enable caching (default: true)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Basic usage
@rust_crate &quot;/path/to/my_crate&quot;

# With options
@rust_crate &quot;/path/to/my_crate&quot; name=&quot;MyBindings&quot; release=true

# After loading, use the module
MyCrate.add(1, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L1136-L1161">source</a></section></details></article><h2 id="Hot-Reload"><a class="docs-heading-anchor" href="#Hot-Reload">Hot Reload</a><a id="Hot-Reload-1"></a><a class="docs-heading-anchor-permalink" href="#Hot-Reload" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RustCall.HotReloadState"><a class="docstring-binding" href="#RustCall.HotReloadState"><code>RustCall.HotReloadState</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HotReloadState</code></pre><p>State for a hot-reloadable Rust crate.</p><p><strong>Fields</strong></p><ul><li><code>crate_path::String</code>: Path to the Rust crate</li><li><code>lib_path::String</code>: Path to the compiled library</li><li><code>lib_name::String</code>: Name used to register the library</li><li><code>source_files::Vector{String}</code>: Tracked .rs source files</li><li><code>last_modified::Dict{String, Float64}</code>: Last modification times</li><li><code>watch_task::Union{Task, Nothing}</code>: File watching task</li><li><code>enabled::Bool</code>: Whether hot reload is enabled</li><li><code>rebuild_callback::Union{Function, Nothing}</code>: Callback after rebuild</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L10-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.enable_hot_reload"><a class="docstring-binding" href="#RustCall.enable_hot_reload"><code>RustCall.enable_hot_reload</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">enable_hot_reload(lib_name::String, crate_path::String; kwargs...) -&gt; HotReloadState</code></pre><p>Enable hot reload for a Rust crate.</p><p><strong>Arguments</strong></p><ul><li><code>lib_name::String</code>: Name of the loaded library</li><li><code>crate_path::String</code>: Path to the Rust crate root</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>interval::Float64</code>: Check interval in seconds (default: 1.0)</li><li><code>callback::Union{Function, Nothing}</code>: Callback after rebuild (receives lib_name, success, error)</li></ul><p><strong>Returns</strong></p><ul><li><code>HotReloadState</code>: The hot reload state for the crate</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Load a Rust crate
rust&quot;&quot;&quot;
// cargo-deps: my_crate = { path = &quot;./my_rust_crate&quot; }
use my_crate::*;
&quot;&quot;&quot;

# Enable hot reload
state = enable_hot_reload(&quot;my_crate&quot;, &quot;./my_rust_crate&quot;)

# Now modify Rust code and it will automatically reload!

# When done, disable hot reload
disable_hot_reload(&quot;my_crate&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L351-L383">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.disable_hot_reload"><a class="docstring-binding" href="#RustCall.disable_hot_reload"><code>RustCall.disable_hot_reload</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">disable_hot_reload(lib_name::String)</code></pre><p>Disable hot reload for a Rust crate.</p><p><strong>Arguments</strong></p><ul><li><code>lib_name::String</code>: Name of the library to disable hot reload for</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L444-L451">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.disable_all_hot_reload"><a class="docstring-binding" href="#RustCall.disable_all_hot_reload"><code>RustCall.disable_all_hot_reload</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">disable_all_hot_reload()</code></pre><p>Disable hot reload for all registered crates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L465-L469">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.is_hot_reload_enabled"><a class="docstring-binding" href="#RustCall.is_hot_reload_enabled"><code>RustCall.is_hot_reload_enabled</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_hot_reload_enabled(lib_name::String) -&gt; Bool</code></pre><p>Check if hot reload is enabled for a library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L476-L480">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.list_hot_reload_crates"><a class="docstring-binding" href="#RustCall.list_hot_reload_crates"><code>RustCall.list_hot_reload_crates</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">list_hot_reload_crates() -&gt; Vector{String}</code></pre><p>List all crates with hot reload enabled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L488-L492">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.trigger_reload"><a class="docstring-binding" href="#RustCall.trigger_reload"><code>RustCall.trigger_reload</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">trigger_reload(lib_name::String) -&gt; Bool</code></pre><p>Manually trigger a reload for a library.</p><p>Returns true if successful, false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L497-L503">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.set_hot_reload_global"><a class="docstring-binding" href="#RustCall.set_hot_reload_global"><code>RustCall.set_hot_reload_global</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_hot_reload_global(enabled::Bool)</code></pre><p>Enable or disable hot reload functionality globally.</p><p>When disabled, all watch tasks will stop.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L513-L519">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.enable_hot_reload_for_crate"><a class="docstring-binding" href="#RustCall.enable_hot_reload_for_crate"><code>RustCall.enable_hot_reload_for_crate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">enable_hot_reload_for_crate(crate_path::String; kwargs...) -&gt; HotReloadState</code></pre><p>Enable hot reload for a crate loaded via @rust_crate.</p><p>This is a convenience function that determines the library name from the crate.</p><p><strong>Arguments</strong></p><ul><li><code>crate_path::String</code>: Path to the Rust crate</li></ul><p><strong>Keyword Arguments</strong></p><ul><li>Same as <code>enable_hot_reload</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">@rust_crate &quot;/path/to/my_crate&quot;

# Enable hot reload
enable_hot_reload_for_crate(&quot;/path/to/my_crate&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L534-L554">source</a></section></details></article><h2 id="Type-System"><a class="docs-heading-anchor" href="#Type-System">Type System</a><a id="Type-System-1"></a><a class="docs-heading-anchor-permalink" href="#Type-System" title="Permalink"></a></h2><h3 id="Type-Mapping-Constants"><a class="docs-heading-anchor" href="#Type-Mapping-Constants">Type Mapping Constants</a><a id="Type-Mapping-Constants-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Mapping-Constants" title="Permalink"></a></h3><p>The following constants define the mapping between Rust types and Julia types:</p><pre><code class="language-julia hljs"># Rust to Julia type mapping
const RUST_TO_JULIA_TYPE_MAP = Dict{Symbol, Type}(
    :i8 =&gt; Int8,
    :i16 =&gt; Int16,
    :i32 =&gt; Int32,
    :i64 =&gt; Int64,
    :u8 =&gt; UInt8,
    :u16 =&gt; UInt16,
    :u32 =&gt; UInt32,
    :u64 =&gt; UInt64,
    :f32 =&gt; Float32,
    :f64 =&gt; Float64,
    :bool =&gt; Bool,
    :usize =&gt; UInt,
    :isize =&gt; Int,
    Symbol(&quot;()&quot;) =&gt; Cvoid,
)

# Julia to Rust type mapping
const JULIA_TO_RUST_TYPE_MAP = Dict{Type, String}(
    Int8 =&gt; &quot;i8&quot;,
    Int16 =&gt; &quot;i16&quot;,
    Int32 =&gt; &quot;i32&quot;,
    Int64 =&gt; &quot;i64&quot;,
    UInt8 =&gt; &quot;u8&quot;,
    UInt16 =&gt; &quot;u16&quot;,
    UInt32 =&gt; &quot;u32&quot;,
    UInt64 =&gt; &quot;u64&quot;,
    Float32 =&gt; &quot;f32&quot;,
    Float64 =&gt; &quot;f64&quot;,
    Bool =&gt; &quot;bool&quot;,
    Cvoid =&gt; &quot;()&quot;,
)</code></pre><h3 id="Internal-Registries"><a class="docs-heading-anchor" href="#Internal-Registries">Internal Registries</a><a id="Internal-Registries-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Registries" title="Permalink"></a></h3><p>The following registries are used internally by RustCall.jl:</p><article><details class="docstring" open="true"><summary id="RustCall.GENERIC_FUNCTION_REGISTRY"><a class="docstring-binding" href="#RustCall.GENERIC_FUNCTION_REGISTRY"><code>RustCall.GENERIC_FUNCTION_REGISTRY</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>Registry for generic functions. Maps function name to GenericFunctionInfo.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L72-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.MONOMORPHIZED_FUNCTIONS"><a class="docstring-binding" href="#RustCall.MONOMORPHIZED_FUNCTIONS"><code>RustCall.MONOMORPHIZED_FUNCTIONS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>Registry for monomorphized function instances. Maps (function<em>name, type</em>params_tuple) to FunctionInfo.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L78-L81">source</a></section></details></article><p>The following registries and constants are not exported but are available for advanced usage.</p><p>Note: These constants are internal implementation details. They are documented here for completeness but should not be accessed directly by users.</p><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><h3 id="Testing-and-Debugging"><a class="docs-heading-anchor" href="#Testing-and-Debugging">Testing and Debugging</a><a id="Testing-and-Debugging-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-and-Debugging" title="Permalink"></a></h3><p>These functions are exported for testing purposes but are considered internal. They are wrappers around internal implementation functions.</p><h2 id="Internal-Functions-and-Types"><a class="docs-heading-anchor" href="#Internal-Functions-and-Types">Internal Functions and Types</a><a id="Internal-Functions-and-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions-and-Types" title="Permalink"></a></h2><p>The following functions and types are internal implementation details and are not part of the public API. They are documented here for completeness but should not be used directly by users.</p><article><details class="docstring" open="true"><summary id="RustCall.RustCall"><a class="docstring-binding" href="#RustCall.RustCall"><code>RustCall.RustCall</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">RustCall.jl</code></pre><p>A Foreign Function Interface (FFI) package for calling Rust code from Julia using LLVM IR integration.</p><p><strong>Exported Macros</strong></p><ul><li><code>@rust</code>: Call a registered Rust function</li><li><code>@rust_str</code>: Compile and register Rust code (rust&quot;&quot; string literal)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">using RustCall

# Define Rust code
rust&quot;&quot;&quot;
#[no_mangle]
pub extern &quot;C&quot; fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
&quot;&quot;&quot;

# Call the function
result = @rust add(10i32, 20i32)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/RustCall.jl#L1-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.Vector-Union{Tuple{RustVec{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#Base.Vector-Union{Tuple{RustVec{T}}, Tuple{T}} where T"><code>Base.Vector</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Vector(vec::RustVec{T}) -&gt; Vector{T}</code></pre><p>Convert a RustVec to a Julia Vector by copying the data.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">vec = RustVec{Int32}(ptr, 10, 20)
julia_vec = Vector(vec)  # Creates a new Julia array</code></pre><p><strong>Note</strong></p><p>This creates a copy of the data. Modifications to the returned Vector will not affect the original RustVec.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L720-L734">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.COptionType"><a class="docstring-binding" href="#RustCall.COptionType"><code>RustCall.COptionType</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">COptionType{T}</code></pre><p>C-compatible struct for Option&lt;T&gt; returned by FFI functions. Generated by #[julia] proc-macro as <code>COption_&lt;function_name&gt;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L454-L459">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.CResultType"><a class="docstring-binding" href="#RustCall.CResultType"><code>RustCall.CResultType</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CResultType{T, E}</code></pre><p>C-compatible struct for Result&lt;T, E&gt; returned by FFI functions. Generated by #[julia] proc-macro as <code>CResult_&lt;function_name&gt;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L442-L447">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.CacheMetadata"><a class="docstring-binding" href="#RustCall.CacheMetadata"><code>RustCall.CacheMetadata</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CacheMetadata</code></pre><p>Metadata stored with cached libraries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cache.jl#L7-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.FunctionInfo"><a class="docstring-binding" href="#RustCall.FunctionInfo"><code>RustCall.FunctionInfo</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FunctionInfo</code></pre><p>Information about a registered Rust function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/codegen.jl#L3-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.LLVMCodeGenerator"><a class="docstring-binding" href="#RustCall.LLVMCodeGenerator"><code>RustCall.LLVMCodeGenerator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LLVMCodeGenerator</code></pre><p>Configuration for LLVM-based code generation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmcodegen.jl#L6-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.LLVMCodeGenerator-Tuple{}"><a class="docstring-binding" href="#RustCall.LLVMCodeGenerator-Tuple{}"><code>RustCall.LLVMCodeGenerator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">LLVMCodeGenerator(; kwargs...)</code></pre><p>Create an LLVMCodeGenerator with specified settings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmcodegen.jl#L17-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.OptionTypeInfo"><a class="docstring-binding" href="#RustCall.OptionTypeInfo"><code>RustCall.OptionTypeInfo</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OptionTypeInfo</code></pre><p>Parsed information about an Option&lt;T&gt; return type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L344-L348">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.ResultTypeInfo"><a class="docstring-binding" href="#RustCall.ResultTypeInfo"><code>RustCall.ResultTypeInfo</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ResultTypeInfo</code></pre><p>Parsed information about a Result&lt;T, E&gt; return type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L334-L338">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.RustFunctionSignature"><a class="docstring-binding" href="#RustCall.RustFunctionSignature"><code>RustCall.RustFunctionSignature</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustFunctionSignature</code></pre><p>Represents a parsed Rust function signature marked with #[julia].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L5-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.RustMethod"><a class="docstring-binding" href="#RustCall.RustMethod"><code>RustCall.RustMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustMethod</code></pre><p>Represents a Rust method found in an impl block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/structs.jl#L4-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.RustModule"><a class="docstring-binding" href="#RustCall.RustModule"><code>RustCall.RustModule</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustModule</code></pre><p>A wrapper around an LLVM module containing compiled Rust code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmintegration.jl#L5-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.RustStructInfo"><a class="docstring-binding" href="#RustCall.RustStructInfo"><code>RustCall.RustStructInfo</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RustStructInfo</code></pre><p>Represents a Rust struct and its associated implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/structs.jl#L18-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.collect-Union{Tuple{RustVec{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#Base.collect-Union{Tuple{RustVec{T}}, Tuple{T}} where T"><code>Base.collect</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">collect(vec::RustVec{T}) -&gt; Vector{T}</code></pre><p>Alias for <code>Vector(vec::RustVec{T})</code>. Convert a RustVec to a Julia Vector.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">vec = RustVec{Int32}(ptr, 10, 20)
julia_vec = collect(vec)  # Creates a new Julia array</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L751-L761">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Union{Tuple{T}, Tuple{RustSlice{T}, Int64}} where T"><a class="docstring-binding" href="#Base.getindex-Union{Tuple{T}, Tuple{RustSlice{T}, Int64}} where T"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getindex(slice::RustSlice{T}, i::Int) -&gt; T</code></pre><p>Get the element at index <code>i</code> in a RustSlice.</p><p><strong>Arguments</strong></p><ul><li><code>slice</code>: The RustSlice to index into</li><li><code>i</code>: The index (1-based, like Julia arrays)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">slice = RustSlice{Int32}(ptr, 10)
value = slice[1]  # Get first element</code></pre><p><strong>Note</strong></p><p>This performs bounds checking. The index must be between 1 and <code>length(slice)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L633-L650">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Union{Tuple{T}, Tuple{RustVec{T}, Int64}} where T"><a class="docstring-binding" href="#Base.getindex-Union{Tuple{T}, Tuple{RustVec{T}, Int64}} where T"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getindex(vec::RustVec{T}, i::Int) -&gt; T</code></pre><p>Get the element at index <code>i</code> in a RustVec.</p><p><strong>Arguments</strong></p><ul><li><code>vec</code>: The RustVec to index into</li><li><code>i</code>: The index (1-based, like Julia arrays)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">vec = RustVec{Int32}(ptr, 10, 20)
value = vec[1]  # Get first element</code></pre><p><strong>Note</strong></p><p>This performs bounds checking. The index must be between 1 and <code>length(vec)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L566-L583">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.iterate-Union{Tuple{RustSlice{T}}, Tuple{T}, Tuple{RustSlice{T}, Int64}} where T"><a class="docstring-binding" href="#Base.iterate-Union{Tuple{RustSlice{T}}, Tuple{T}, Tuple{RustSlice{T}, Int64}} where T"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">iterate(slice::RustSlice{T}, state=1) -&gt; Union{Tuple{T, Int}, Nothing}</code></pre><p>Iterate over elements in a RustSlice.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">slice = RustSlice{Int32}(ptr, 10)
for x in slice
    println(x)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L686-L698">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.iterate-Union{Tuple{RustVec{T}}, Tuple{T}, Tuple{RustVec{T}, Int64}} where T"><a class="docstring-binding" href="#Base.iterate-Union{Tuple{RustVec{T}}, Tuple{T}, Tuple{RustVec{T}, Int64}} where T"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">iterate(vec::RustVec{T}, state=1) -&gt; Union{Tuple{T, Int}, Nothing}</code></pre><p>Iterate over elements in a RustVec.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">vec = RustVec{Int32}(ptr, 10, 20)
for x in vec
    println(x)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L664-L676">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.push!-Union{Tuple{T}, Tuple{RustVec{T}, T}} where T"><a class="docstring-binding" href="#Base.push!-Union{Tuple{T}, Tuple{RustVec{T}, T}} where T"><code>Base.push!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">push!(vec::RustVec{T}, value::T) -&gt; RustVec{T}</code></pre><p>Push a value to RustVec. Note: This modifies the vec in place by updating its internal pointer, length, and capacity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L880-L885">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.setindex!-Union{Tuple{T}, Tuple{RustVec{T}, Any, Int64}} where T"><a class="docstring-binding" href="#Base.setindex!-Union{Tuple{T}, Tuple{RustVec{T}, Any, Int64}} where T"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">setindex!(vec::RustVec{T}, value, i::Int) -&gt; value</code></pre><p>Set the element at index <code>i</code> in a RustVec to <code>value</code>.</p><p><strong>Arguments</strong></p><ul><li><code>vec</code>: The RustVec to modify</li><li><code>value</code>: The value to set (must be convertible to type T)</li><li><code>i</code>: The index (1-based, like Julia arrays)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">vec = RustVec{Int32}(ptr, 10, 20)
vec[1] = 42  # Set first element to 42</code></pre><p><strong>Note</strong></p><p>This performs bounds checking. The index must be between 1 and <code>length(vec)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L597-L615">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.showerror-Tuple{IO, CargoBuildError}"><a class="docstring-binding" href="#Base.showerror-Tuple{IO, CargoBuildError}"><code>Base.showerror</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.showerror(io::IO, e::CargoBuildError)</code></pre><p>Display a CargoBuildError in a user-friendly format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L379-L383">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.showerror-Tuple{IO, CompilationError}"><a class="docstring-binding" href="#Base.showerror-Tuple{IO, CompilationError}"><code>Base.showerror</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.showerror(io::IO, e::CompilationError)</code></pre><p>Display a CompilationError in a user-friendly format with formatted rustc output. Enhanced with more context and debugging information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L135-L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.showerror-Tuple{IO, DependencyResolutionError}"><a class="docstring-binding" href="#Base.showerror-Tuple{IO, DependencyResolutionError}"><code>Base.showerror</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.showerror(io::IO, e::DependencyResolutionError)</code></pre><p>Display a DependencyResolutionError in a user-friendly format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L400-L404">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.showerror-Tuple{IO, RuntimeError}"><a class="docstring-binding" href="#Base.showerror-Tuple{IO, RuntimeError}"><code>Base.showerror</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.showerror(io::IO, e::RuntimeError)</code></pre><p>Display a RuntimeError in a user-friendly format with enhanced stack trace. Enhanced with argument information and debugging context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L300-L305">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.showerror-Tuple{IO, RustError}"><a class="docstring-binding" href="#Base.showerror-Tuple{IO, RustError}"><code>Base.showerror</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.showerror(io::IO, e::RustError)</code></pre><p>Display a RustError in a user-friendly format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L119-L123">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._call_irust_function-Tuple{String, String, Type, Vararg{Any}}"><a class="docstring-binding" href="#RustCall._call_irust_function-Tuple{String, String, Type, Vararg{Any}}"><code>RustCall._call_irust_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_call_irust_function(lib_name::String, func_name::String, ret_type::Type, args...)
_call_irust_function(lib_name::String, func_name::String, args...)</code></pre><p>Call an irust function with Julia arguments.</p><p><strong>Error Handling</strong></p><p>Provides improved error messages for function call failures.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L1291-L1299">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._check_not_freed-Tuple{Any, String}"><a class="docstring-binding" href="#RustCall._check_not_freed-Tuple{Any, String}"><code>RustCall._check_not_freed</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_check_not_freed(obj, type_name::String)</code></pre><p>Check that a wrapped Rust object has not been freed. Throws an error if the internal pointer is C_NULL, preventing use-after-free crashes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L860-L865">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._compile_and_call_irust-Tuple{String, Vararg{Any}}"><a class="docstring-binding" href="#RustCall._compile_and_call_irust-Tuple{String, Vararg{Any}}"><code>RustCall._compile_and_call_irust</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_compile_and_call_irust(code::String, args...)</code></pre><p>Internal function to compile and execute Rust code at function scope.</p><p><strong>Error Handling</strong></p><p>This function provides improved error messages for:</p><ul><li>Type mismatches</li><li>Compilation failures</li><li>Missing variables</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L1036-L1046">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._compile_and_load_rust-Tuple{String, String, Int64}"><a class="docstring-binding" href="#RustCall._compile_and_load_rust-Tuple{String, String, Int64}"><code>RustCall._compile_and_load_rust</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_compile_and_load_rust(code::String, source_file::String, source_line::Int)</code></pre><p>Internal function to compile Rust code and load the resulting shared library. Uses caching to avoid recompilation when possible.</p><p>Phase 3: Automatically detects dependencies in the code and uses Cargo for building when external crates are required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L201-L209">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._compile_and_load_rust_with_cargo-Tuple{String, String, Int64}"><a class="docstring-binding" href="#RustCall._compile_and_load_rust_with_cargo-Tuple{String, String, Int64}"><code>RustCall._compile_and_load_rust_with_cargo</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_compile_and_load_rust_with_cargo(code::String, source_file::String, source_line::Int)</code></pre><p>Internal function to compile Rust code that has external dependencies using Cargo. Phase 3: Supports rustscript-style dependency specifications.</p><p><strong>Dependency Specification Formats</strong></p><ol><li><p>Document comment format:</p><pre><code class="language-rust hljs">//! ```cargo
//! [dependencies]
//! ndarray = &quot;0.15&quot;
//! ```</code></pre></li><li><p>Single-line comment format:</p><pre><code class="language-rust hljs">// cargo-deps: ndarray=&quot;0.15&quot;, serde=&quot;1.0&quot;</code></pre></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L353-L372">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._convert_args_for_rust-Tuple"><a class="docstring-binding" href="#RustCall._convert_args_for_rust-Tuple"><code>RustCall._convert_args_for_rust</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_convert_args_for_rust(args...)</code></pre><p>Convert Julia arguments to Rust-compatible types. String arguments are passed directly and converted by ccall.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/rustmacro.jl#L247-L252">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._count_trailing_backslashes-Tuple{AbstractString}"><a class="docstring-binding" href="#RustCall._count_trailing_backslashes-Tuple{AbstractString}"><code>RustCall._count_trailing_backslashes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_count_trailing_backslashes(s::AbstractString) -&gt; Int</code></pre><p>Count consecutive trailing backslash characters. Used to determine whether a quote is escaped: the quote is escaped only if preceded by an odd number of backslashes (e.g., <code>\&quot;</code> is escaped, <code>\\&quot;</code> is not).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependencies.jl#L279-L285">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._defer_drop-Tuple{Ptr{Nothing}, String, Symbol}"><a class="docstring-binding" href="#RustCall._defer_drop-Tuple{Ptr{Nothing}, String, Symbol}"><code>RustCall._defer_drop</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_defer_drop(ptr::Ptr{Cvoid}, type_name::String, drop_symbol::Symbol)</code></pre><p>Record a pointer for deferred deallocation when the Rust helpers library becomes available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L45-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._defer_vec_drop-Tuple{Ptr{Nothing}, UInt64, UInt64, String, Symbol}"><a class="docstring-binding" href="#RustCall._defer_vec_drop-Tuple{Ptr{Nothing}, UInt64, UInt64, String, Symbol}"><code>RustCall._defer_vec_drop</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_defer_vec_drop(ptr::Ptr{Cvoid}, len::UInt, cap::UInt, type_name::String, drop_symbol::Symbol)</code></pre><p>Record a RustVec pointer for deferred deallocation (needs len/cap for CRustVec reconstruction).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L58-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._detect_and_register_generic_functions-Tuple{String, String}"><a class="docstring-binding" href="#RustCall._detect_and_register_generic_functions-Tuple{String, String}"><code>RustCall._detect_and_register_generic_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_detect_and_register_generic_functions(code::String, lib_name::String)</code></pre><p>Detect generic functions in Rust code and register them for monomorphization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L689-L693">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._emit_function_code-Tuple{RustCall.RustFunctionSignature}"><a class="docstring-binding" href="#RustCall._emit_function_code-Tuple{RustCall.RustFunctionSignature}"><code>RustCall._emit_function_code</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_emit_function_code(func::RustFunctionSignature) -&gt; String</code></pre><p>Generate Julia code for a function wrapper as a string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L1412-L1416">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._emit_method_code-Tuple{RustCall.RustStructInfo, RustCall.RustMethod}"><a class="docstring-binding" href="#RustCall._emit_method_code-Tuple{RustCall.RustStructInfo, RustCall.RustMethod}"><code>RustCall._emit_method_code</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_emit_method_code(struct_info::RustStructInfo, method::RustMethod) -&gt; String</code></pre><p>Generate Julia code for a method wrapper as a string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L1600-L1604">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._emit_struct_code-Tuple{RustCall.RustStructInfo}"><a class="docstring-binding" href="#RustCall._emit_struct_code-Tuple{RustCall.RustStructInfo}"><code>RustCall._emit_struct_code</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_emit_struct_code(info::RustStructInfo) -&gt; String</code></pre><p>Generate Julia code for a struct wrapper as a string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L1508-L1512">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._extract_error_line_numbers_impl-Tuple{String}"><a class="docstring-binding" href="#RustCall._extract_error_line_numbers_impl-Tuple{String}"><code>RustCall._extract_error_line_numbers_impl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_extract_error_line_numbers_impl(stderr::String) -&gt; Vector{Int}</code></pre><p>Extract line numbers from rustc error output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L244-L248">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._extract_suggestions_impl-Tuple{String}"><a class="docstring-binding" href="#RustCall._extract_suggestions_impl-Tuple{String}"><code>RustCall._extract_suggestions_impl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_extract_suggestions_impl(stderr::String) -&gt; Vector{String}</code></pre><p>Extract helpful suggestions from rustc error output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/exceptions.jl#L262-L266">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._find_matching_angle_bracket-Tuple{AbstractString, Int64}"><a class="docstring-binding" href="#RustCall._find_matching_angle_bracket-Tuple{AbstractString, Int64}"><code>RustCall._find_matching_angle_bracket</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_find_matching_angle_bracket(s::AbstractString, open_pos::Int) -&gt; Int</code></pre><p>Find the position of the matching closing <code>&gt;</code> for an opening <code>&lt;</code> at <code>open_pos</code>, correctly handling nested angle brackets like <code>Vec&lt;Option&lt;T&gt;&gt;</code>. Returns 0 if no matching bracket is found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L488-L494">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._generate_irust_function-Tuple{String, String, Vector{String}, String}"><a class="docstring-binding" href="#RustCall._generate_irust_function-Tuple{String, String, Vector{String}, String}"><code>RustCall._generate_irust_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_generate_irust_function(func_name::String, code::String, arg_types::Vector{String}, ret_type::String) -&gt; String</code></pre><p>Generate a complete Rust function from the code snippet. The code should use arg1, arg2, etc. to reference arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L1258-L1263">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._generate_option_function_wrapper-Tuple{RustCall.RustFunctionSignature, RustCall.OptionTypeInfo, Vector{Symbol}, Vector}"><a class="docstring-binding" href="#RustCall._generate_option_function_wrapper-Tuple{RustCall.RustFunctionSignature, RustCall.OptionTypeInfo, Vector{Symbol}, Vector}"><code>RustCall._generate_option_function_wrapper</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_generate_option_function_wrapper(func, option_info, arg_syms, converted_args) -&gt; Expr</code></pre><p>Generate a Julia wrapper for a function that returns Option&lt;T&gt;. The wrapper will return RustOption{T}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L664-L669">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._generate_property_accessors-Tuple{RustCall.RustStructInfo}"><a class="docstring-binding" href="#RustCall._generate_property_accessors-Tuple{RustCall.RustStructInfo}"><code>RustCall._generate_property_accessors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_generate_property_accessors(info::RustStructInfo) -&gt; Union{Expr, Nothing}</code></pre><p>Generate Base.getproperty and Base.setproperty! methods for natural field access. This allows <code>obj.field</code> and <code>obj.field = value</code> syntax.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L780-L785">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._generate_result_function_wrapper-Tuple{RustCall.RustFunctionSignature, RustCall.ResultTypeInfo, Vector{Symbol}, Vector}"><a class="docstring-binding" href="#RustCall._generate_result_function_wrapper-Tuple{RustCall.RustFunctionSignature, RustCall.ResultTypeInfo, Vector{Symbol}, Vector}"><code>RustCall._generate_result_function_wrapper</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_generate_result_function_wrapper(func, result_info, arg_syms, converted_args) -&gt; Expr</code></pre><p>Generate a Julia wrapper for a function that returns Result&lt;T, E&gt;. The wrapper will return RustResult{T, E}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L618-L623">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._generate_single_wrapper-Tuple{RustCall.RustFunctionSignature}"><a class="docstring-binding" href="#RustCall._generate_single_wrapper-Tuple{RustCall.RustFunctionSignature}"><code>RustCall._generate_single_wrapper</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_generate_single_wrapper(sig::RustFunctionSignature) -&gt; Union{Expr, Nothing}</code></pre><p>Generate a Julia wrapper function for a single Rust function signature. Uses direct function call instead of @rust macro for better scope handling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L228-L233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._get_library_filename-Tuple{String}"><a class="docstring-binding" href="#RustCall._get_library_filename-Tuple{String}"><code>RustCall._get_library_filename</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_library_filename(crate_name::String) -&gt; String</code></pre><p>Get the platform-specific library filename for a crate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L279-L283">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._get_reload_lock-Tuple{String}"><a class="docstring-binding" href="#RustCall._get_reload_lock-Tuple{String}"><code>RustCall._get_reload_lock</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_reload_lock(lib_name::String) -&gt; ReentrantLock</code></pre><p>Get or create a per-library lock for serializing reload operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L54-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._infer_return_type-Tuple{String}"><a class="docstring-binding" href="#RustCall._infer_return_type-Tuple{String}"><code>RustCall._infer_return_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_infer_return_type(code::String) -&gt; String</code></pre><p>Infer return type from Rust code (legacy function, kept for compatibility).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L1249-L1253">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._infer_return_type_improved-Tuple{String, Vector{&lt;:Type}, Vector{String}}"><a class="docstring-binding" href="#RustCall._infer_return_type_improved-Tuple{String, Vector{&lt;:Type}, Vector{String}}"><code>RustCall._infer_return_type_improved</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_infer_return_type_improved(code::String, arg_types::Vector{Type}, rust_arg_types::Vector{String}) -&gt; String</code></pre><p>Infer return type from Rust code with improved heuristics.</p><p><strong>Strategy</strong></p><ol><li>Look for explicit return statements with literals</li><li>Analyze arithmetic operations (int vs float)</li><li>Use argument types as hints</li><li>Fall back to first argument type if available</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L1193-L1203">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._julia_to_rust_type-Tuple{Type}"><a class="docstring-binding" href="#RustCall._julia_to_rust_type-Tuple{Type}"><code>RustCall._julia_to_rust_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_julia_to_rust_type(julia_type::Type) -&gt; String</code></pre><p>Convert Julia type to Rust type string.</p><p><strong>Supported Types</strong></p><ul><li>Integer types: Int8, Int16, Int32, Int64, UInt8, UInt16, UInt32, UInt64</li><li>Floating point: Float32, Float64</li><li>Boolean: Bool</li></ul><p><strong>Error Handling</strong></p><p>Unsupported types throw an error to prevent ABI mismatches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L1150-L1162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._parse_function_return_type-Tuple{String, String}"><a class="docstring-binding" href="#RustCall._parse_function_return_type-Tuple{String, String}"><code>RustCall._parse_function_return_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_parse_function_return_type(code::String, func_name::String) -&gt; Union{Type, Nothing}</code></pre><p>Parse the return type of a function from Rust code. Returns the Julia type corresponding to the Rust return type, or nothing if not found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L740-L745">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._parse_irust_variables-Tuple{String}"><a class="docstring-binding" href="#RustCall._parse_irust_variables-Tuple{String}"><code>RustCall._parse_irust_variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_parse_irust_variables(code::String) -&gt; (Vector{Symbol}, String)</code></pre><p>Parse <code>$var</code> syntax in irust code and extract variable names. Returns (list of variable symbols, processed code with var replaced by argN).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">vars, code = _parse_irust_variables(&quot;$x + $y * 2&quot;)
# vars = [:x, :y]
# code = &quot;arg1 + arg2 * 2&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L990-L1002">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._parse_qualified_call-Tuple{Any}"><a class="docstring-binding" href="#RustCall._parse_qualified_call-Tuple{Any}"><code>RustCall._parse_qualified_call</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_parse_qualified_call(expr) -&gt; Union{Tuple{Any, Expr}, Nothing}</code></pre><p>Parse <code>lib::func(args...)</code> into <code>(lib, call_expr)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/rustmacro.jl#L220-L224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._parse_single_arg!-Tuple{Vector{String}, Vector{String}, AbstractString}"><a class="docstring-binding" href="#RustCall._parse_single_arg!-Tuple{Vector{String}, Vector{String}, AbstractString}"><code>RustCall._parse_single_arg!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_parse_single_arg!(names::Vector{String}, types::Vector{String}, arg::AbstractString)</code></pre><p>Parse a single function argument &quot;name: type&quot; and add to the vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L109-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._register_function_signatures-Tuple{String, String}"><a class="docstring-binding" href="#RustCall._register_function_signatures-Tuple{String, String}"><code>RustCall._register_function_signatures</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_register_function_signatures(code::String, lib_name::String)</code></pre><p>Register function return types from Rust code for type inference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L781-L785">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._reload_library_locked-Tuple{HotReloadState}"><a class="docstring-binding" href="#RustCall._reload_library_locked-Tuple{HotReloadState}"><code>RustCall._reload_library_locked</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_reload_library_locked(state::HotReloadState) -&gt; Bool</code></pre><p>Internal implementation of reload_library, called while holding the per-library lock.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L161-L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._remove_generic_params_from_fns-Tuple{AbstractString}"><a class="docstring-binding" href="#RustCall._remove_generic_params_from_fns-Tuple{AbstractString}"><code>RustCall._remove_generic_params_from_fns</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_remove_generic_params_from_fns(code::AbstractString) -&gt; String</code></pre><p>Remove generic parameter lists from function signatures (e.g., <code>fn name&lt;T, Vec&lt;U&gt;&gt;(</code> -&gt; <code>fn name(</code>), correctly handling nested angle brackets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L513-L518">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._remove_generic_params_from_impls-Tuple{AbstractString}"><a class="docstring-binding" href="#RustCall._remove_generic_params_from_impls-Tuple{AbstractString}"><code>RustCall._remove_generic_params_from_impls</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_remove_generic_params_from_impls(code::AbstractString) -&gt; String</code></pre><p>Remove generic parameter lists from impl blocks (e.g., <code>impl&lt;T&gt;</code> -&gt; <code>impl</code>), correctly handling nested angle brackets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L537-L542">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._resolve_lib-Tuple{Module, String}"><a class="docstring-binding" href="#RustCall._resolve_lib-Tuple{Module, String}"><code>RustCall._resolve_lib</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_resolve_lib(mod::Module, lib_name::String)</code></pre><p>Resolve the actual library name to use, handling session-aware reloading for precompiled modules.</p><p>When a module has multiple <code>rust&quot;&quot;&quot;</code> blocks, all libraries are loaded to enable the fallback function lookup across libraries in <code>get_function_pointer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/rustmacro.jl#L144-L151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._rust_call_dynamic-Tuple{String, String, Vararg{Any}}"><a class="docstring-binding" href="#RustCall._rust_call_dynamic-Tuple{String, String, Vararg{Any}}"><code>RustCall._rust_call_dynamic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_rust_call_dynamic(lib_name::String, func_name::String, args...)</code></pre><p>Call a Rust function with dynamic type dispatch. Automatically handles generic functions by monomorphizing them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/rustmacro.jl#L258-L263">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._rust_call_from_lib-Tuple{String, String, Vararg{Any}}"><a class="docstring-binding" href="#RustCall._rust_call_from_lib-Tuple{String, String, Vararg{Any}}"><code>RustCall._rust_call_from_lib</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_rust_call_from_lib(lib_name::String, func_name::String, args...)</code></pre><p>Call a Rust function from a specific library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/rustmacro.jl#L329-L333">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._rust_call_typed-Tuple{String, String, Type, Vararg{Any}}"><a class="docstring-binding" href="#RustCall._rust_call_typed-Tuple{String, String, Type, Vararg{Any}}"><code>RustCall._rust_call_typed</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_rust_call_typed(lib_name::String, func_name::String, ret_type::Type, args...)</code></pre><p>Call a Rust function with explicit return type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/rustmacro.jl#L304-L308">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._rust_comparison_operand-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#RustCall._rust_comparison_operand-Tuple{Any, Any, Any}"><code>RustCall._rust_comparison_operand</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_rust_comparison_operand(mod, expr, source)</code></pre><p>Process an operand of a comparison in <code>@rust</code>.  If the expression looks like a Rust call (or qualified call), expand it via <code>rust_impl</code>; otherwise just escape it so plain Julia values pass through unchanged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/rustmacro.jl#L41-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._rust_llvm_call-Tuple{String, Vararg{Any}}"><a class="docstring-binding" href="#RustCall._rust_llvm_call-Tuple{String, Vararg{Any}}"><code>RustCall._rust_llvm_call</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_rust_llvm_call(func_name::String, args...)</code></pre><p>Internal function to call a Rust function via LLVM integration. Falls back to ccall if llvmcall is not available.</p><p><strong>Errors</strong></p><ul><li><code>ArgumentError</code>: If function is not registered and cannot be found in current library</li><li><code>TypeError</code>: If argument types don&#39;t match expected signature</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmcodegen.jl#L289-L298">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._rust_to_julia_type-Tuple{String}"><a class="docstring-binding" href="#RustCall._rust_to_julia_type-Tuple{String}"><code>RustCall._rust_to_julia_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_rust_to_julia_type(rust_type::String) -&gt; Type</code></pre><p>Convert Rust type string to Julia type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L1184-L1188">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._rust_type_to_julia_conversion_type-Tuple{String}"><a class="docstring-binding" href="#RustCall._rust_type_to_julia_conversion_type-Tuple{String}"><code>RustCall._rust_type_to_julia_conversion_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_rust_type_to_julia_conversion_type(rust_type::String) -&gt; Union{Symbol, Nothing}</code></pre><p>Get the Julia type to use for argument conversion from Rust type. Returns Nothing if no conversion is needed or type is unknown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L276-L281">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._rust_type_to_julia_type_symbol-Tuple{String}"><a class="docstring-binding" href="#RustCall._rust_type_to_julia_type_symbol-Tuple{String}"><code>RustCall._rust_type_to_julia_type_symbol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_rust_type_to_julia_type_symbol(rust_type::String) -&gt; Union{Symbol, Nothing}</code></pre><p>Get the Julia type symbol for return type annotation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L302-L306">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._struct_type_to_llvm_ir-Tuple{Type}"><a class="docstring-binding" href="#RustCall._struct_type_to_llvm_ir-Tuple{Type}"><code>RustCall._struct_type_to_llvm_ir</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_struct_type_to_llvm_ir(t::Type) -&gt; String</code></pre><p>Convert a Julia struct type to LLVM IR struct representation. Extracts field types from the struct definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmcodegen.jl#L156-L161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall._tuple_type_to_llvm_ir-Tuple{Type{&lt;:Tuple}}"><a class="docstring-binding" href="#RustCall._tuple_type_to_llvm_ir-Tuple{Type{&lt;:Tuple}}"><code>RustCall._tuple_type_to_llvm_ir</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_tuple_type_to_llvm_ir(t::Type{&lt;:Tuple}) -&gt; String</code></pre><p>Convert a Julia Tuple type to LLVM IR struct representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmcodegen.jl#L141-L145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.build_cargo_project_cached-Tuple{CargoProject, AbstractString}"><a class="docstring-binding" href="#RustCall.build_cargo_project_cached-Tuple{CargoProject, AbstractString}"><code>RustCall.build_cargo_project_cached</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">build_cargo_project_cached(
    project::CargoProject,
    code_hash::UInt64;
    release::Bool = true
) -&gt; String</code></pre><p>Build a Cargo project with caching support.</p><p>If a cached library exists with matching code and dependency hashes, returns the cached library path. Otherwise, builds the project and caches the result.</p><p><strong>Arguments</strong></p><ul><li><code>project::CargoProject</code>: The Cargo project to build</li><li><code>code_hash::AbstractString</code>: SHA256 hex digest of the Rust source code</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>release::Bool</code>: Build in release mode (default: true)</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Path to the compiled shared library (may be cached)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargobuild.jl#L161-L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.build_crate_directly-Tuple{CrateInfo, Bool}"><a class="docstring-binding" href="#RustCall.build_crate_directly-Tuple{CrateInfo, Bool}"><code>RustCall.build_crate_directly</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">build_crate_directly(info::CrateInfo, release::Bool) -&gt; String</code></pre><p>Build the crate directly using cargo and return the path to the library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L1084-L1088">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.build_llvmcall_expr-Tuple{Ptr{Nothing}, Type, Any, Any}"><a class="docstring-binding" href="#RustCall.build_llvmcall_expr-Tuple{Ptr{Nothing}, Type, Any, Any}"><code>RustCall.build_llvmcall_expr</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">build_llvmcall_expr(func_ptr::Ptr{Cvoid}, ret_type::Type, arg_types::Tuple, args::Tuple)</code></pre><p>Build an expression that uses llvmcall to invoke a function. This is used internally by @generated functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmcodegen.jl#L177-L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.call_rust_function-Tuple{Ptr{Nothing}, Type, Type{&lt;:Tuple}, Vararg{Any}}"><a class="docstring-binding" href="#RustCall.call_rust_function-Tuple{Ptr{Nothing}, Type, Type{&lt;:Tuple}, Vararg{Any}}"><code>RustCall.call_rust_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">call_rust_function(func_ptr::Ptr{Cvoid}, ret_type::Type, argt::Type{&lt;:Tuple}, args...)</code></pre><p>Call a Rust function with a tuple type for arguments.</p><p><strong>Arguments</strong></p><ul><li><code>func_ptr::Ptr{Cvoid}</code>: Function pointer to the Rust function</li><li><code>ret_type::Type</code>: Expected return type</li><li><code>argt::Type{&lt;:Tuple}</code>: Tuple type containing argument types</li><li><code>args...</code>: Arguments to pass to the function</li></ul><p><strong>Returns</strong></p><ul><li>The return value of the Rust function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/codegen.jl#L277-L290">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.call_rust_function-Tuple{Ptr{Nothing}, Type, Vararg{Any}}"><a class="docstring-binding" href="#RustCall.call_rust_function-Tuple{Ptr{Nothing}, Type, Vararg{Any}}"><code>RustCall.call_rust_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">call_rust_function(func_ptr::Ptr{Cvoid}, ret_type::Type, args...)</code></pre><p>Call a Rust function with the given return type. Uses a generated ccall based on normalized argument types.</p><p><strong>Arguments</strong></p><ul><li><code>func_ptr::Ptr{Cvoid}</code>: Function pointer to the Rust function</li><li><code>ret_type::Type</code>: Expected return type of the function</li><li><code>args...</code>: Arguments to pass to the function</li></ul><p><strong>Returns</strong></p><ul><li>The return value of the Rust function, converted to the specified <code>ret_type</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">func_ptr = get_function_pointer(&quot;mylib&quot;, &quot;add&quot;)
result = call_rust_function(func_ptr, Int32, 10, 20)  # Returns Int32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/codegen.jl#L224-L243">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.call_rust_function-Tuple{Ptr{Nothing}, Type, Vector{Type}, Vararg{Any}}"><a class="docstring-binding" href="#RustCall.call_rust_function-Tuple{Ptr{Nothing}, Type, Vector{Type}, Vararg{Any}}"><code>RustCall.call_rust_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">call_rust_function(func_ptr::Ptr{Cvoid}, ret_type::Type, arg_types::Vector{Type}, args...)</code></pre><p>Call a Rust function with explicit argument types.</p><p><strong>Arguments</strong></p><ul><li><code>func_ptr::Ptr{Cvoid}</code>: Function pointer to the Rust function</li><li><code>ret_type::Type</code>: Expected return type</li><li><code>arg_types::Vector{Type}</code>: Vector of argument types</li><li><code>args...</code>: Arguments to pass to the function</li></ul><p><strong>Returns</strong></p><ul><li>The return value of the Rust function</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">func_ptr = get_function_pointer(&quot;mylib&quot;, &quot;multiply&quot;)
result = call_rust_function(func_ptr, Float64, [Float64, Float64], 3.14, 2.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/codegen.jl#L249-L268">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.call_rust_function_infer-Tuple{Ptr{Nothing}, Vararg{Any}}"><a class="docstring-binding" href="#RustCall.call_rust_function_infer-Tuple{Ptr{Nothing}, Vararg{Any}}"><code>RustCall.call_rust_function_infer</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">call_rust_function_infer(func_ptr::Ptr{Cvoid}, args...)</code></pre><p>Call a Rust function, inferring the return type from the first argument type. Uses @generated function for compile-time optimization based on argument types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/codegen.jl#L298-L303">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.check_dependency_availability-Tuple{Vector{DependencySpec}}"><a class="docstring-binding" href="#RustCall.check_dependency_availability-Tuple{Vector{DependencySpec}}"><code>RustCall.check_dependency_availability</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_dependency_availability(deps::Vector{DependencySpec}) -&gt; Bool</code></pre><p>Check if dependencies are likely to be available on crates.io. This is a heuristic check - actual availability is confirmed during cargo build.</p><p><strong>Returns</strong></p><ul><li><code>true</code> if dependencies appear valid</li><li>Emits warnings for potentially problematic dependencies</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependency_resolution.jl#L237-L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.check_for_changes-Tuple{HotReloadState}"><a class="docstring-binding" href="#RustCall.check_for_changes-Tuple{HotReloadState}"><code>RustCall.check_for_changes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">check_for_changes(state::HotReloadState) -&gt; Bool</code></pre><p>Check if any source files have been modified since last check. Updates the last_modified times if changes are detected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L109-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.cleanup_cargo_project-Tuple{CargoProject}"><a class="docstring-binding" href="#RustCall.cleanup_cargo_project-Tuple{CargoProject}"><code>RustCall.cleanup_cargo_project</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cleanup_cargo_project(project::CargoProject)</code></pre><p>Remove the temporary Cargo project directory.</p><p><strong>Arguments</strong></p><ul><li><code>project::CargoProject</code>: The project to clean up</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargoproject.jl#L258-L265">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.compute_crate_hash-Tuple{CrateInfo}"><a class="docstring-binding" href="#RustCall.compute_crate_hash-Tuple{CrateInfo}"><code>RustCall.compute_crate_hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_crate_hash(info::CrateInfo) -&gt; String</code></pre><p>Compute a hash for caching based on crate contents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L1102-L1106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.convert_c_option_to_rust_option-Union{Tuple{T}, Tuple{Any, Type{T}}} where T"><a class="docstring-binding" href="#RustCall.convert_c_option_to_rust_option-Union{Tuple{T}, Tuple{Any, Type{T}}} where T"><code>RustCall.convert_c_option_to_rust_option</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">convert_c_option_to_rust_option(c_option, inner_type::Type) -&gt; RustOption</code></pre><p>Convert a C-compatible option struct to RustOption{T}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L509-L513">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.convert_c_result_to_rust_result-Union{Tuple{E}, Tuple{T}, Tuple{Any, Type{T}, Type{E}}} where {T, E}"><a class="docstring-binding" href="#RustCall.convert_c_result_to_rust_result-Union{Tuple{E}, Tuple{T}, Tuple{Any, Type{T}, Type{E}}} where {T, E}"><code>RustCall.convert_c_result_to_rust_result</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">convert_c_result_to_rust_result(c_result, ok_type::Type, err_type::Type) -&gt; RustResult</code></pre><p>Convert a C-compatible result struct to RustResult{T, E}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L496-L500">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.crate_has_cdylib-Tuple{String}"><a class="docstring-binding" href="#RustCall.crate_has_cdylib-Tuple{String}"><code>RustCall.crate_has_cdylib</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">crate_has_cdylib(crate_path::String) -&gt; Bool</code></pre><p>Check if the crate has cdylib in its crate-type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L1066-L1070">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.create_rust_arc-Tuple{T} where T"><a class="docstring-binding" href="#RustCall.create_rust_arc-Tuple{T} where T"><code>RustCall.create_rust_arc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_rust_arc(value::T) -&gt; RustArc{T} where T</code></pre><p>Create a RustArc from a Julia value. Automatically calls the appropriate Rust Arc::new function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L514-L519">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.create_rust_box-Tuple{T} where T"><a class="docstring-binding" href="#RustCall.create_rust_box-Tuple{T} where T"><code>RustCall.create_rust_box</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_rust_box(value::T) -&gt; RustBox{T} where T</code></pre><p>Create a RustBox from a Julia value. Automatically calls the appropriate Rust Box::new function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L300-L305">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.create_rust_rc-Tuple{T} where T"><a class="docstring-binding" href="#RustCall.create_rust_rc-Tuple{T} where T"><code>RustCall.create_rust_rc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_rust_rc(value::T) -&gt; RustRc{T} where T</code></pre><p>Create a RustRc from a Julia value. Automatically calls the appropriate Rust Rc::new function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L392-L397">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.create_wrapper_crate-Tuple{CrateInfo, CrateBindingOptions}"><a class="docstring-binding" href="#RustCall.create_wrapper_crate-Tuple{CrateInfo, CrateBindingOptions}"><code>RustCall.create_wrapper_crate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_wrapper_crate(info::CrateInfo, opts::CrateBindingOptions) -&gt; String</code></pre><p>Create a wrapper crate that depends on the target crate and re-exports #[julia] items.</p><p><strong>Returns</strong></p><ul><li><code>String</code>: Path to the created wrapper crate directory</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L392-L399">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.deferred_drop_count-Tuple{}"><a class="docstring-binding" href="#RustCall.deferred_drop_count-Tuple{}"><code>RustCall.deferred_drop_count</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">deferred_drop_count() -&gt; Int</code></pre><p>Return the number of pointers awaiting deferred deallocation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L124-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.dispose_module-Tuple{RustCall.RustModule}"><a class="docstring-binding" href="#RustCall.dispose_module-Tuple{RustCall.RustModule}"><code>RustCall.dispose_module</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">dispose_module(mod::RustModule)</code></pre><p>Dispose of the LLVM resources associated with a RustModule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmintegration.jl#L193-L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.drop_rust_arc-Union{Tuple{RustArc{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RustCall.drop_rust_arc-Union{Tuple{RustArc{T}}, Tuple{T}} where T"><code>RustCall.drop_rust_arc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">drop_rust_arc(arc::RustArc{T}) where T</code></pre><p>Drop a RustArc, decrementing the atomic reference count.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L586-L590">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.drop_rust_box-Union{Tuple{RustBox{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RustCall.drop_rust_box-Union{Tuple{RustBox{T}}, Tuple{T}} where T"><code>RustCall.drop_rust_box</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">drop_rust_box(box::RustBox{T}) where T</code></pre><p>Drop a RustBox, calling the appropriate Rust drop function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L339-L343">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.drop_rust_rc-Union{Tuple{RustRc{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RustCall.drop_rust_rc-Union{Tuple{RustRc{T}}, Tuple{T}} where T"><code>RustCall.drop_rust_rc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">drop_rust_rc(rc::RustRc{T}) where T</code></pre><p>Drop a RustRc, decrementing the reference count.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L464-L468">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.drop_rust_vec-Union{Tuple{RustVec{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#RustCall.drop_rust_vec-Union{Tuple{RustVec{T}}, Tuple{T}} where T"><code>RustCall.drop_rust_vec</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">drop_rust_vec(vec::RustVec{T}) -&gt; Nothing</code></pre><p>Drop a RustVec by calling the Rust-side drop function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L659-L663">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.emit_crate_module-Tuple{CrateInfo, String}"><a class="docstring-binding" href="#RustCall.emit_crate_module-Tuple{CrateInfo, String}"><code>RustCall.emit_crate_module</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">emit_crate_module(info::CrateInfo, lib_path::String; module_name::Union{String, Nothing}=nothing) -&gt; Expr</code></pre><p>Generate a Julia module expression containing bindings for the crate.</p><p><strong>Arguments</strong></p><ul><li><code>info::CrateInfo</code>: Crate information from scan_crate</li><li><code>lib_path::String</code>: Path to the compiled shared library</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>module_name::Union{String, Nothing}</code>: Name for the module (default: crate name with first letter capitalized)</li></ul><p><strong>Returns</strong></p><ul><li><code>Expr</code>: A module expression that can be evaluated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L490-L504">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.emit_crate_module_code-Tuple{CrateInfo, String}"><a class="docstring-binding" href="#RustCall.emit_crate_module_code-Tuple{CrateInfo, String}"><code>RustCall.emit_crate_module_code</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">emit_crate_module_code(info::CrateInfo, lib_path::String; kwargs...) -&gt; String</code></pre><p>Generate Julia module code as a string, suitable for writing to a file.</p><p><strong>Arguments</strong></p><ul><li><code>info::CrateInfo</code>: Crate information from scan_crate</li><li><code>lib_path::String</code>: Path to the compiled shared library (or relative path)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>module_name::Union{String, Nothing}</code>: Name for the module</li><li><code>use_relative_path::Bool</code>: If true, treat lib_path as relative to @<strong>DIR</strong></li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Julia source code for the module</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L1321-L1336">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.emit_julia_definitions-Tuple{RustCall.RustStructInfo}"><a class="docstring-binding" href="#RustCall.emit_julia_definitions-Tuple{RustCall.RustStructInfo}"><code>RustCall.emit_julia_definitions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">emit_julia_definitions(info::RustStructInfo)</code></pre><p>Generate Julia code to define a corresponding mutable struct and its methods. Only generates definitions for structs marked with #[derive(JuliaStruct)] or #[julia].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/structs.jl#L744-L749">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.emit_julia_function_wrappers-Tuple{Vector{RustCall.RustFunctionSignature}}"><a class="docstring-binding" href="#RustCall.emit_julia_function_wrappers-Tuple{Vector{RustCall.RustFunctionSignature}}"><code>RustCall.emit_julia_function_wrappers</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">emit_julia_function_wrappers(signatures::Vector{RustFunctionSignature}) -&gt; Expr</code></pre><p>Generate Julia wrapper functions for the given Rust function signatures.</p><p>For a function like:</p><pre><code class="language-rust hljs">#[julia]
fn add(a: i32, b: i32) -&gt; i32 { ... }</code></pre><p>Generates:</p><pre><code class="language-julia hljs">add(a, b) = @rust add(Int32(a), Int32(b))::Int32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L188-L203">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.ensure_loaded-Tuple{String, String}"><a class="docstring-binding" href="#RustCall.ensure_loaded-Tuple{String, String}"><code>RustCall.ensure_loaded</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ensure_loaded(lib_name::String, code::String)</code></pre><p>Ensure that a Rust library is loaded in the current session. Useful for precompiled modules that need to reload libraries at runtime.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L185-L190">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.escape_toml_string-Tuple{AbstractString}"><a class="docstring-binding" href="#RustCall.escape_toml_string-Tuple{AbstractString}"><code>RustCall.escape_toml_string</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">escape_toml_string(s::AbstractString) -&gt; String</code></pre><p>Escape special characters in a string for safe TOML value interpolation. Prevents TOML injection by escaping backslashes, quotes, and control characters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargoproject.jl#L6-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.extract_block_at-Tuple{String, Int64}"><a class="docstring-binding" href="#RustCall.extract_block_at-Tuple{String, Int64}"><code>RustCall.extract_block_at</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_block_at(code::String, start_idx::Int) -&gt; Union{String, Nothing}</code></pre><p>Extract a balanced brace block starting near start<em>idx. Searches for the first &#39;{&#39; at or after start</em>idx.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/structs.jl#L307-L312">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.extract_cargo_block-Tuple{String}"><a class="docstring-binding" href="#RustCall.extract_cargo_block-Tuple{String}"><code>RustCall.extract_cargo_block</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_cargo_block(code::String) -&gt; Union{String, Nothing}</code></pre><p>Extract the cargo TOML block from Rust code.</p><p>Looks for patterns like:</p><pre><code class="language-julia hljs">//! ```cargo
//! [dependencies]
//! ndarray = &quot;0.15&quot;
//! ```</code></pre><p><strong>Returns</strong></p><ul><li>The content inside the cargo block (without //! prefixes), or <code>nothing</code> if not found</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependencies.jl#L103-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.extract_cargo_deps_line-Tuple{String}"><a class="docstring-binding" href="#RustCall.extract_cargo_deps_line-Tuple{String}"><code>RustCall.extract_cargo_deps_line</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_cargo_deps_line(code::String) -&gt; Union{String, Nothing}</code></pre><p>Extract the cargo-deps line from Rust code.</p><p>Looks for patterns like:</p><pre><code class="language-julia hljs">// cargo-deps: ndarray=&quot;0.15&quot;, serde=&quot;1.0&quot;</code></pre><p><strong>Returns</strong></p><ul><li>The content after &quot;cargo-deps:&quot;, or <code>nothing</code> if not found</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependencies.jl#L220-L232">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.extract_crate_dependencies-Tuple{Dict}"><a class="docstring-binding" href="#RustCall.extract_crate_dependencies-Tuple{Dict}"><code>RustCall.extract_crate_dependencies</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_crate_dependencies(cargo_toml::Dict) -&gt; Vector{DependencySpec}</code></pre><p>Extract dependencies from parsed Cargo.toml.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L361-L365">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.extract_function_code-Tuple{String, String}"><a class="docstring-binding" href="#RustCall.extract_function_code-Tuple{String, String}"><code>RustCall.extract_function_code</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_function_code(code::String, func_name::String) -&gt; Union{String, Nothing}</code></pre><p>Extract the full code for a function from Rust source code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L544-L548">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.extract_function_ir-Tuple{RustCall.RustModule, String}"><a class="docstring-binding" href="#RustCall.extract_function_ir-Tuple{RustCall.RustModule, String}"><code>RustCall.extract_function_ir</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_function_ir(mod::RustModule, func_name::String) -&gt; String</code></pre><p>Extract the LLVM IR for a specific function from a RustModule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmcodegen.jl#L53-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.find_rust_source_files-Tuple{String}"><a class="docstring-binding" href="#RustCall.find_rust_source_files-Tuple{String}"><code>RustCall.find_rust_source_files</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_rust_source_files(crate_path::String) -&gt; Vector{String}</code></pre><p>Find all .rs files in a crate&#39;s src directory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L69-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.find_rust_sources-Tuple{String}"><a class="docstring-binding" href="#RustCall.find_rust_sources-Tuple{String}"><code>RustCall.find_rust_sources</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_rust_sources(crate_path::String) -&gt; Vector{String}</code></pre><p>Find all .rs files in a crate&#39;s src directory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L160-L164">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.flush_deferred_drops-Tuple{}"><a class="docstring-binding" href="#RustCall.flush_deferred_drops-Tuple{}"><code>RustCall.flush_deferred_drops</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">flush_deferred_drops() -&gt; Int</code></pre><p>Attempt to free all deferred pointers using the Rust helpers library. Returns the number of successfully freed pointers. Call this after rebuilding/reloading the helpers library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L71-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.format_dependency_line-Tuple{DependencySpec}"><a class="docstring-binding" href="#RustCall.format_dependency_line-Tuple{DependencySpec}"><code>RustCall.format_dependency_line</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">format_dependency_line(dep::DependencySpec) -&gt; String</code></pre><p>Format a single dependency for Cargo.toml.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">format_dependency_line(DependencySpec(&quot;ndarray&quot;, version=&quot;0.15&quot;))
# =&gt; &quot;ndarray = &quot;0.15&quot;&quot;

format_dependency_line(DependencySpec(&quot;serde&quot;, version=&quot;1.0&quot;, features=[&quot;derive&quot;]))
# =&gt; &quot;serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargoproject.jl#L133-L146">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.free_rust_obj-Tuple{Ptr{Nothing}, String}"><a class="docstring-binding" href="#RustCall.free_rust_obj-Tuple{Ptr{Nothing}, String}"><code>RustCall.free_rust_obj</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">free_rust_obj(ptr::Ptr{Cvoid}, lib_func::String)</code></pre><p>Helper to safely call the Rust destructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/structs.jl#L1215-L1219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.generate_c_option_struct_type-Tuple{String, Symbol}"><a class="docstring-binding" href="#RustCall.generate_c_option_struct_type-Tuple{String, Symbol}"><code>RustCall.generate_c_option_struct_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_c_option_struct_type(func_name::String, inner_type::Symbol) -&gt; Expr</code></pre><p>Generate a Julia struct definition for the C-compatible Option type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L481-L485">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.generate_c_result_struct_type-Tuple{String, Symbol, Symbol}"><a class="docstring-binding" href="#RustCall.generate_c_result_struct_type-Tuple{String, Symbol, Symbol}"><code>RustCall.generate_c_result_struct_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_c_result_struct_type(func_name::String, ok_type::Symbol, err_type::Symbol) -&gt; Expr</code></pre><p>Generate a Julia struct definition for the C-compatible Result type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L465-L469">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.generate_cache_key-Tuple{String, RustCompiler}"><a class="docstring-binding" href="#RustCall.generate_cache_key-Tuple{String, RustCompiler}"><code>RustCall.generate_cache_key</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_cache_key(code::String, compiler::RustCompiler) -&gt; String</code></pre><p>Generate a cache key based on code hash, compiler settings, and target triple. Uses SHA256 for collision resistance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cache.jl#L45-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.generate_cargo_toml-Tuple{String, Vector{DependencySpec}, String}"><a class="docstring-binding" href="#RustCall.generate_cargo_toml-Tuple{String, Vector{DependencySpec}, String}"><code>RustCall.generate_cargo_toml</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_cargo_toml(name::String, deps::Vector{DependencySpec}, edition::String) -&gt; String</code></pre><p>Generate Cargo.toml content for a project.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: Project name</li><li><code>deps::Vector{DependencySpec}</code>: Dependencies</li><li><code>edition::String</code>: Rust edition</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Cargo.toml content</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargoproject.jl#L89-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.generate_crate_function_wrappers-Tuple{CrateInfo, String}"><a class="docstring-binding" href="#RustCall.generate_crate_function_wrappers-Tuple{CrateInfo, String}"><code>RustCall.generate_crate_function_wrappers</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_crate_function_wrappers(info::CrateInfo, lib_path::String) -&gt; Expr</code></pre><p>Generate Julia wrapper functions for all #[julia] functions in the crate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L547-L551">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.generate_crate_struct_wrappers-Tuple{CrateInfo, String}"><a class="docstring-binding" href="#RustCall.generate_crate_struct_wrappers-Tuple{CrateInfo, String}"><code>RustCall.generate_crate_struct_wrappers</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_crate_struct_wrappers(info::CrateInfo, lib_path::String) -&gt; Expr</code></pre><p>Generate Julia struct definitions and wrappers for all #[julia] structs in the crate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L705-L709">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.generate_llvmcall_ir-Tuple{String, Type, Vector{Type}}"><a class="docstring-binding" href="#RustCall.generate_llvmcall_ir-Tuple{String, Type, Vector{Type}}"><code>RustCall.generate_llvmcall_ir</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_llvmcall_ir(func_name::String, ret_type::Type, arg_types::Vector{Type}) -&gt; String</code></pre><p>Generate LLVM IR string suitable for llvmcall based on function signature. This creates a simple wrapper that calls the actual function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmcodegen.jl#L70-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.generate_struct_wrappers-Tuple{RustCall.RustStructInfo}"><a class="docstring-binding" href="#RustCall.generate_struct_wrappers-Tuple{RustCall.RustStructInfo}"><code>RustCall.generate_struct_wrappers</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_struct_wrappers(info::RustStructInfo) -&gt; String</code></pre><p>Generate &quot;extern C&quot; C-FFI wrappers for a given struct. For generic structs, registers them as generic functions instead of returning static wrappers. Only generates wrappers for structs marked with #[derive(JuliaStruct)] or #[julia].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/structs.jl#L479-L485">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.generate_wrapper_cargo_toml-Tuple{CrateInfo, CrateBindingOptions}"><a class="docstring-binding" href="#RustCall.generate_wrapper_cargo_toml-Tuple{CrateInfo, CrateBindingOptions}"><code>RustCall.generate_wrapper_cargo_toml</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_wrapper_cargo_toml(info::CrateInfo, opts::CrateBindingOptions) -&gt; String</code></pre><p>Generate Cargo.toml content for the wrapper crate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L417-L421">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.generate_wrapper_lib_rs-Tuple{CrateInfo}"><a class="docstring-binding" href="#RustCall.generate_wrapper_lib_rs-Tuple{CrateInfo}"><code>RustCall.generate_wrapper_lib_rs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_wrapper_lib_rs(info::CrateInfo) -&gt; String</code></pre><p>Generate lib.rs content for the wrapper crate that re-exports #[julia] items.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L458-L462">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_built_library_path-Tuple{CargoProject, Bool}"><a class="docstring-binding" href="#RustCall.get_built_library_path-Tuple{CargoProject, Bool}"><code>RustCall.get_built_library_path</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_built_library_path(project::CargoProject, release::Bool) -&gt; String</code></pre><p>Get the path to the built library for a Cargo project.</p><p><strong>Arguments</strong></p><ul><li><code>project::CargoProject</code>: The Cargo project</li><li><code>release::Bool</code>: Whether release mode was used</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Path to the shared library</li></ul><p><strong>Note</strong></p><p>The path follows Cargo&#39;s target directory structure:</p><ul><li>Release: target/release/libname.dylib (or .so, .dll)</li><li>Debug: target/debug/libname.dylib</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargobuild.jl#L99-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_cache_dir-Tuple{}"><a class="docstring-binding" href="#RustCall.get_cache_dir-Tuple{}"><code>RustCall.get_cache_dir</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_cache_dir() -&gt; String</code></pre><p>Get the cache directory for RustCall.jl compiled libraries. Uses Julia&#39;s standard cache directory structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cache.jl#L21-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_cached_library-Tuple{String}"><a class="docstring-binding" href="#RustCall.get_cached_library-Tuple{String}"><code>RustCall.get_cached_library</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_cached_library(cache_key::String) -&gt; Union{String, Nothing}</code></pre><p>Check if a cached library exists for the given cache key. Returns the path to the cached library if it exists, nothing otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cache.jl#L63-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_cached_llvm_ir-Tuple{String}"><a class="docstring-binding" href="#RustCall.get_cached_llvm_ir-Tuple{String}"><code>RustCall.get_cached_llvm_ir</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_cached_llvm_ir(cache_key::String) -&gt; Union{String, Nothing}</code></pre><p>Check if a cached LLVM IR file exists for the given cache key. Returns the path to the cached IR file if it exists, nothing otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cache.jl#L81-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_cargo_cache_dir-Tuple{}"><a class="docstring-binding" href="#RustCall.get_cargo_cache_dir-Tuple{}"><code>RustCall.get_cargo_cache_dir</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_cargo_cache_dir() -&gt; String</code></pre><p>Get the cache directory for Cargo-built libraries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargobuild.jl#L216-L220">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_cargo_cached_library-Tuple{String}"><a class="docstring-binding" href="#RustCall.get_cargo_cached_library-Tuple{String}"><code>RustCall.get_cargo_cached_library</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_cargo_cached_library(cache_key::String) -&gt; Union{String, Nothing}</code></pre><p>Get a cached Cargo library by cache key.</p><p><strong>Returns</strong></p><ul><li>Path to cached library, or <code>nothing</code> if not found</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargobuild.jl#L228-L235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_current_library-Tuple{}"><a class="docstring-binding" href="#RustCall.get_current_library-Tuple{}"><code>RustCall.get_current_library</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_current_library() -&gt; String</code></pre><p>Get the name of the currently active Rust library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L25-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_default_target-Tuple{}"><a class="docstring-binding" href="#RustCall.get_default_target-Tuple{}"><code>RustCall.get_default_target</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_default_target() -&gt; String</code></pre><p>Get the default target triple for the current platform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/compiler.jl#L61-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_file_mtime-Tuple{String}"><a class="docstring-binding" href="#RustCall.get_file_mtime-Tuple{String}"><code>RustCall.get_file_mtime</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_file_mtime(path::String) -&gt; Float64</code></pre><p>Get the modification time of a file as a Float64 timestamp. Returns 0.0 if the file doesn&#39;t exist.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L95-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_function-Tuple{RustCall.RustModule, String}"><a class="docstring-binding" href="#RustCall.get_function-Tuple{RustCall.RustModule, String}"><code>RustCall.get_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_function(mod::RustModule, name::String) -&gt; Union{LLVM.Function, Nothing}</code></pre><p>Get a function by name from the RustModule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmintegration.jl#L74-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_function_info-Tuple{String, String}"><a class="docstring-binding" href="#RustCall.get_function_info-Tuple{String, String}"><code>RustCall.get_function_info</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_function_info(lib_name::String, name::String) -&gt; Union{FunctionInfo, Nothing}</code></pre><p>Get registered function info scoped to a library. Falls back to name-only registry for backward compatibility.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/codegen.jl#L62-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_function_info-Tuple{String}"><a class="docstring-binding" href="#RustCall.get_function_info-Tuple{String}"><code>RustCall.get_function_info</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_function_info(name::String) -&gt; Union{FunctionInfo, Nothing}</code></pre><p>Get the registered function info for a function name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/codegen.jl#L53-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_function_pointer-Tuple{String, String}"><a class="docstring-binding" href="#RustCall.get_function_pointer-Tuple{String, String}"><code>RustCall.get_function_pointer</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_function_pointer(lib_name::String, func_name::String) -&gt; Ptr{Cvoid}</code></pre><p>Get a function pointer from a loaded library.</p><p>If the function is not found in the specified library, searches all other loaded libraries as a fallback. This enables using functions from multiple <code>rust&quot;&quot;&quot;</code> blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L53-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_function_pointer_from_lib-Tuple{Ptr{Nothing}, String}"><a class="docstring-binding" href="#RustCall.get_function_pointer_from_lib-Tuple{Ptr{Nothing}, String}"><code>RustCall.get_function_pointer_from_lib</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_function_pointer_from_lib(lib_handle::Ptr{Cvoid}, func_name::String) -&gt; Ptr{Cvoid}</code></pre><p>Get a function pointer from a loaded library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L1123-L1127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_function_return_type-Tuple{String, String}"><a class="docstring-binding" href="#RustCall.get_function_return_type-Tuple{String, String}"><code>RustCall.get_function_return_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_function_return_type(lib_name::String, func_name::String) -&gt; Union{Type, Nothing}</code></pre><p>Get a registered return type for a function in a specific library. Falls back to global function-name mapping for backward compatibility.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/codegen.jl#L72-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_function_signature-Tuple{LLVM.Function}"><a class="docstring-binding" href="#RustCall.get_function_signature-Tuple{LLVM.Function}"><code>RustCall.get_function_signature</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_function_signature(fn::LLVM.Function) -&gt; Tuple{Type, Vector{Type}}</code></pre><p>Get the Julia return type and argument types for an LLVM function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmintegration.jl#L92-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_library_extension-Tuple{}"><a class="docstring-binding" href="#RustCall.get_library_extension-Tuple{}"><code>RustCall.get_library_extension</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_library_extension() -&gt; String</code></pre><p>Get the shared library extension for the current platform.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/compiler.jl#L135-L139">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_library_handle-Tuple{String}"><a class="docstring-binding" href="#RustCall.get_library_handle-Tuple{String}"><code>RustCall.get_library_handle</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_library_handle(name::String) -&gt; Ptr{Cvoid}</code></pre><p>Get the library handle for a named library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L39-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_metadata_dir-Tuple{}"><a class="docstring-binding" href="#RustCall.get_metadata_dir-Tuple{}"><code>RustCall.get_metadata_dir</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_metadata_dir() -&gt; String</code></pre><p>Get the directory for cache metadata files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cache.jl#L33-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_monomorphized_function-Tuple{String, Dict{Symbol, &lt;:Type}}"><a class="docstring-binding" href="#RustCall.get_monomorphized_function-Tuple{String, Dict{Symbol, &lt;:Type}}"><code>RustCall.get_monomorphized_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_monomorphized_function(func_name::String, type_params::Dict{Symbol, Type}) -&gt; Union{FunctionInfo, Nothing}</code></pre><p>Get a monomorphized function instance if it exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L968-L972">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_optimization_stats-Tuple{LLVM.Module}"><a class="docstring-binding" href="#RustCall.get_optimization_stats-Tuple{LLVM.Module}"><code>RustCall.get_optimization_stats</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_optimization_stats(mod::LLVM.Module) -&gt; Dict{String, Any}</code></pre><p>Get statistics about an LLVM module for optimization analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmoptimization.jl#L136-L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_or_compile_function-Tuple{RustCall.RustModule, String}"><a class="docstring-binding" href="#RustCall.get_or_compile_function-Tuple{RustCall.RustModule, String}"><code>RustCall.get_or_compile_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_or_compile_function(mod::RustModule, name::String) -&gt; Ptr{Cvoid}</code></pre><p>Get a compiled function pointer, compiling if necessary using Julia&#39;s JIT.</p><p><strong>Arguments</strong></p><ul><li><code>mod::RustModule</code>: The Rust module containing the function</li><li><code>name::String</code>: Name of the function to compile</li></ul><p><strong>Returns</strong></p><ul><li><code>Ptr{Cvoid}</code>: Function pointer to the compiled function</li></ul><p><strong>Note</strong></p><p>This function is a placeholder for future LLVM JIT compilation support. Currently, it raises an error indicating that direct LLVM JIT compilation is not yet implemented. Use the shared library approach instead.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mod = load_llvm_ir(&quot;path/to/file.ll&quot;)
# Note: This will raise an error until JIT compilation is implemented
# func_ptr = get_or_compile_function(mod, &quot;my_function&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmintegration.jl#L222-L245">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_project_lib_name-Tuple{CargoProject}"><a class="docstring-binding" href="#RustCall.get_project_lib_name-Tuple{CargoProject}"><code>RustCall.get_project_lib_name</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_project_lib_name(project::CargoProject) -&gt; String</code></pre><p>Get the library file name for the project (platform-specific).</p><p><strong>Returns</strong></p><ul><li>Library filename (e.g., &quot;libmy_project.dylib&quot; on macOS)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargoproject.jl#L272-L279">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_registered_function-Tuple{String}"><a class="docstring-binding" href="#RustCall.get_registered_function-Tuple{String}"><code>RustCall.get_registered_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_registered_function(func_name::String) -&gt; Union{RustFunctionInfo, Nothing}</code></pre><p>Get a registered Rust function&#39;s information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmcodegen.jl#L239-L243">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.get_rust_module-Tuple{String}"><a class="docstring-binding" href="#RustCall.get_rust_module-Tuple{String}"><code>RustCall.get_rust_module</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_rust_module(code::String) -&gt; Union{RustModule, Nothing}</code></pre><p>Get the RustModule for a given code string, if available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L820-L824">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.has_julia_attribute-Tuple{String}"><a class="docstring-binding" href="#RustCall.has_julia_attribute-Tuple{String}"><code>RustCall.has_julia_attribute</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_julia_attribute(code::String) -&gt; Bool</code></pre><p>Check if the code contains any <code>#[julia]</code> or <code>#[julia_pyo3]</code> attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L522-L526">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.hash_dependencies-Tuple{Vector{DependencySpec}}"><a class="docstring-binding" href="#RustCall.hash_dependencies-Tuple{Vector{DependencySpec}}"><code>RustCall.hash_dependencies</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hash_dependencies(deps::Vector{DependencySpec}) -&gt; String</code></pre><p>Generate a hash of the dependency specifications for cache keying.</p><p><strong>Arguments</strong></p><ul><li><code>deps::Vector{DependencySpec}</code>: Dependencies to hash</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Hex-encoded hash of the dependencies</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargobuild.jl#L123-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.infer_function_types-Tuple{String, String}"><a class="docstring-binding" href="#RustCall.infer_function_types-Tuple{String, String}"><code>RustCall.infer_function_types</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">infer_function_types(lib_name::String, func_name::String) -&gt; Tuple{Type, Vector{Type}}</code></pre><p>Try to infer the return type and argument types for a function. Uses LLVM IR analysis if available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/codegen.jl#L86-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.is_cache_valid-Tuple{String, String, RustCompiler}"><a class="docstring-binding" href="#RustCall.is_cache_valid-Tuple{String, String, RustCompiler}"><code>RustCall.is_cache_valid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_cache_valid(cache_key::String, code::String, compiler::RustCompiler) -&gt; Bool</code></pre><p>Check if a cached library is still valid for the given code and compiler settings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cache.jl#L398-L402">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.is_option_type-Tuple{String}"><a class="docstring-binding" href="#RustCall.is_option_type-Tuple{String}"><code>RustCall.is_option_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_option_type(rust_type::String) -&gt; Bool</code></pre><p>Check if a Rust type is Option&lt;T&gt;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L433-L437">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.is_result_type-Tuple{String}"><a class="docstring-binding" href="#RustCall.is_result_type-Tuple{String}"><code>RustCall.is_result_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_result_type(rust_type::String) -&gt; Bool</code></pre><p>Check if a Rust type is Result&lt;T, E&gt;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L424-L428">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.julia_to_llvm_type-Tuple{Type}"><a class="docstring-binding" href="#RustCall.julia_to_llvm_type-Tuple{Type}"><code>RustCall.julia_to_llvm_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">julia_to_llvm_type(julia_type::Type) -&gt; String</code></pre><p>Convert a Julia type to the corresponding LLVM IR type string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/typetranslation.jl#L244-L248">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.julia_type_to_llvm-Tuple{Type}"><a class="docstring-binding" href="#RustCall.julia_type_to_llvm-Tuple{Type}"><code>RustCall.julia_type_to_llvm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">julia_type_to_llvm(julia_type::Type) -&gt; LLVM.LLVMType</code></pre><p>Convert a Julia type to the corresponding LLVM type. Note: Must be called within an active LLVM context (use LLVM.Context() do ... end).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmintegration.jl#L158-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.list_functions-Tuple{RustCall.RustModule}"><a class="docstring-binding" href="#RustCall.list_functions-Tuple{RustCall.RustModule}"><code>RustCall.list_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">list_functions(mod::RustModule) -&gt; Vector{String}</code></pre><p>List all exported function names in the module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmintegration.jl#L83-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.list_library_functions-Tuple{String}"><a class="docstring-binding" href="#RustCall.list_library_functions-Tuple{String}"><code>RustCall.list_library_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">list_library_functions(lib_name::String) -&gt; Vector{String}</code></pre><p>List all exported functions in a loaded library. Note: This uses the LLVM IR module if available, otherwise returns an empty list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L841-L846">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.list_loaded_libraries-Tuple{}"><a class="docstring-binding" href="#RustCall.list_loaded_libraries-Tuple{}"><code>RustCall.list_loaded_libraries</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">list_loaded_libraries() -&gt; Vector{String}</code></pre><p>List all currently loaded Rust libraries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L830-L834">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.llvm_to_julia_type-Tuple{String}"><a class="docstring-binding" href="#RustCall.llvm_to_julia_type-Tuple{String}"><code>RustCall.llvm_to_julia_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">llvm_to_julia_type(llvm_type_str::String) -&gt; Type</code></pre><p>Convert an LLVM IR type string to the corresponding Julia type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/typetranslation.jl#L201-L205">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.llvm_type_to_julia-Tuple{LLVM.LLVMType}"><a class="docstring-binding" href="#RustCall.llvm_type_to_julia-Tuple{LLVM.LLVMType}"><code>RustCall.llvm_type_to_julia</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">llvm_type_to_julia(llvm_type::LLVM.LLVMType) -&gt; Type</code></pre><p>Convert an LLVM type to the corresponding Julia type. Uses LLVM.jl 9.x API which uses concrete types for different LLVM types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmintegration.jl#L113-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.load_cache_metadata-Tuple{String}"><a class="docstring-binding" href="#RustCall.load_cache_metadata-Tuple{String}"><code>RustCall.load_cache_metadata</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_cache_metadata(cache_key::String) -&gt; Union{CacheMetadata, Nothing}</code></pre><p>Load cache metadata from a JSON file.</p><p><strong>Arguments</strong></p><ul><li><code>cache_key::String</code>: The cache key identifying the cached library</li></ul><p><strong>Returns</strong></p><ul><li><code>Union{CacheMetadata, Nothing}</code>: The loaded metadata, or <code>nothing</code> if not found</li></ul><p><strong>Note</strong></p><p>This function currently returns <code>nothing</code> as a placeholder. Full JSON parsing will be implemented in a future version.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">meta = load_cache_metadata(&quot;abc123...&quot;)
if meta !== nothing
    println(&quot;Cache created at: $(meta.created_at)&quot;)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cache.jl#L204-L226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.load_cached_library-Tuple{String}"><a class="docstring-binding" href="#RustCall.load_cached_library-Tuple{String}"><code>RustCall.load_cached_library</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_cached_library(cache_key::String) -&gt; Tuple{Ptr{Cvoid}, String}</code></pre><p>Load a cached library and return its handle and library name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cache.jl#L132-L136">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.load_rust_helpers_lib-Tuple{String}"><a class="docstring-binding" href="#RustCall.load_rust_helpers_lib-Tuple{String}"><code>RustCall.load_rust_helpers_lib</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_rust_helpers_lib(lib_path::String)</code></pre><p>Load the Rust helpers library from a file path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L155-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.merge_dependencies-Tuple{Vector{DependencySpec}}"><a class="docstring-binding" href="#RustCall.merge_dependencies-Tuple{Vector{DependencySpec}}"><code>RustCall.merge_dependencies</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">merge_dependencies(deps::Vector{DependencySpec}) -&gt; Vector{DependencySpec}</code></pre><p>Merge dependencies with the same name, combining features.</p><p><strong>Arguments</strong></p><ul><li><code>deps::Vector{DependencySpec}</code>: List of dependencies (may contain duplicates)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{DependencySpec}</code>: Merged dependencies (no duplicates)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependencies.jl#L415-L425">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.merge_two_dependencies-Tuple{DependencySpec, DependencySpec}"><a class="docstring-binding" href="#RustCall.merge_two_dependencies-Tuple{DependencySpec, DependencySpec}"><code>RustCall.merge_two_dependencies</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">merge_two_dependencies(dep1::DependencySpec, dep2::DependencySpec) -&gt; DependencySpec</code></pre><p>Merge two dependencies with the same name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependencies.jl#L444-L448">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.normalize_dependency-Tuple{DependencySpec}"><a class="docstring-binding" href="#RustCall.normalize_dependency-Tuple{DependencySpec}"><code>RustCall.normalize_dependency</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">normalize_dependency(dep::DependencySpec) -&gt; DependencySpec</code></pre><p>Normalize a dependency specification.</p><ul><li>Sorts features alphabetically</li><li>Trims whitespace from strings</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependencies.jl#L398-L404">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.optimize_balanced!-Tuple{LLVM.Module}"><a class="docstring-binding" href="#RustCall.optimize_balanced!-Tuple{LLVM.Module}"><code>RustCall.optimize_balanced!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">optimize_balanced!(mod::LLVM.Module)</code></pre><p>Apply balanced optimizations (default).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmoptimization.jl#L234-L238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.optimize_function!-Tuple{LLVM.Function}"><a class="docstring-binding" href="#RustCall.optimize_function!-Tuple{LLVM.Function}"><code>RustCall.optimize_function!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">optimize_function!(fn::LLVM.Function; config=get_default_opt_config())</code></pre><p>Apply optimization passes to a single LLVM function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmoptimization.jl#L98-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_cargo_deps_line-Tuple{AbstractString}"><a class="docstring-binding" href="#RustCall.parse_cargo_deps_line-Tuple{AbstractString}"><code>RustCall.parse_cargo_deps_line</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_cargo_deps_line(line::AbstractString) -&gt; Vector{DependencySpec}</code></pre><p>Parse a cargo-deps line to extract dependencies.</p><p>Format: name=&quot;version&quot;, name2={version=&quot;1.0&quot;, features=[&quot;f1&quot;]}</p><p><strong>Arguments</strong></p><ul><li><code>line::AbstractString</code>: Content after &quot;cargo-deps:&quot;</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{DependencySpec}</code>: Parsed dependencies</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependencies.jl#L245-L257">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_cargo_toml-Tuple{String}"><a class="docstring-binding" href="#RustCall.parse_cargo_toml-Tuple{String}"><code>RustCall.parse_cargo_toml</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_cargo_toml(path::String) -&gt; Dict</code></pre><p>Parse a Cargo.toml file and return its contents as a dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L151-L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_cargo_toml_block-Tuple{String}"><a class="docstring-binding" href="#RustCall.parse_cargo_toml_block-Tuple{String}"><code>RustCall.parse_cargo_toml_block</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_cargo_toml_block(block::String) -&gt; Vector{DependencySpec}</code></pre><p>Parse a TOML-formatted cargo block to extract dependencies.</p><p><strong>Arguments</strong></p><ul><li><code>block::String</code>: TOML content from a cargo block</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{DependencySpec}</code>: Parsed dependencies</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependencies.jl#L153-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_impl_methods_for_struct-Tuple{String, String}"><a class="docstring-binding" href="#RustCall.parse_impl_methods_for_struct-Tuple{String, String}"><code>RustCall.parse_impl_methods_for_struct</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_impl_methods_for_struct(code::String, struct_name::String) -&gt; Vector{RustMethod}</code></pre><p>Parse impl blocks for a struct and extract methods marked with #[julia] or #[julia<em>pyo3]. If the impl block itself has #[julia</em>pyo3], all pub fn methods are captured.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L241-L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_julia_functions-Tuple{String}"><a class="docstring-binding" href="#RustCall.parse_julia_functions-Tuple{String}"><code>RustCall.parse_julia_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_julia_functions(code::String) -&gt; Vector{RustFunctionSignature}</code></pre><p>Parse Rust code and extract functions marked with <code>#[julia]</code> attribute.</p><p><strong>Example</strong></p><pre><code class="language-rust hljs">#[julia]
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}</code></pre><p>Returns a vector of <code>RustFunctionSignature</code> for each <code>#[julia]</code> marked function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L19-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_julia_structs_from_source-Tuple{String}"><a class="docstring-binding" href="#RustCall.parse_julia_structs_from_source-Tuple{String}"><code>RustCall.parse_julia_structs_from_source</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_julia_structs_from_source(code::String) -&gt; Vector{RustStructInfo}</code></pre><p>Parse Rust source code and extract structs marked with #[julia] or #[julia_pyo3].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L186-L190">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_methods_in_impl-Tuple{AbstractString}"><a class="docstring-binding" href="#RustCall.parse_methods_in_impl-Tuple{AbstractString}"><code>RustCall.parse_methods_in_impl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_methods_in_impl(impl_body::AbstractString) -&gt; Vector{RustMethod}</code></pre><p>Parse function definitions inside an impl block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/structs.jl#L418-L422">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_option_type-Tuple{String}"><a class="docstring-binding" href="#RustCall.parse_option_type-Tuple{String}"><code>RustCall.parse_option_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_option_type(rust_type::String) -&gt; Union{OptionTypeInfo, Nothing}</code></pre><p>Parse an Option&lt;T&gt; type string and extract T. Returns nothing if not an Option type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L394-L399">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_result_type-Tuple{String}"><a class="docstring-binding" href="#RustCall.parse_result_type-Tuple{String}"><code>RustCall.parse_result_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_result_type(rust_type::String) -&gt; Union{ResultTypeInfo, Nothing}</code></pre><p>Parse a Result&lt;T, E&gt; type string and extract T and E. Returns nothing if not a Result type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L353-L358">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_single_cargo_dep-Tuple{String}"><a class="docstring-binding" href="#RustCall.parse_single_cargo_dep-Tuple{String}"><code>RustCall.parse_single_cargo_dep</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_single_cargo_dep(part::String) -&gt; Union{DependencySpec, Nothing}</code></pre><p>Parse a single dependency from cargo-deps format.</p><p>Formats:</p><ul><li>name=&quot;version&quot;</li><li>name={version=&quot;1.0&quot;, features=[&quot;f1&quot;, &quot;f2&quot;]}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependencies.jl#L331-L339">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_structs_and_impls-Tuple{String}"><a class="docstring-binding" href="#RustCall.parse_structs_and_impls-Tuple{String}"><code>RustCall.parse_structs_and_impls</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_structs_and_impls(code::String) -&gt; Vector{RustStructInfo}</code></pre><p>Heuristic parser to find pub structs and their impl blocks. Supports generics (e.g. <code>struct Point&lt;T&gt;</code>) and captures full source context. Now supports #[derive(JuliaStruct)] attribute for automatic mapping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/structs.jl#L100-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_toml_dependency-Tuple{String, Any}"><a class="docstring-binding" href="#RustCall.parse_toml_dependency-Tuple{String, Any}"><code>RustCall.parse_toml_dependency</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_toml_dependency(name::String, spec) -&gt; DependencySpec</code></pre><p>Parse a single dependency from TOML format.</p><p><strong>Arguments</strong></p><ul><li><code>name::String</code>: Crate name</li><li><code>spec</code>: Version string or dict with version, features, git, path</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependencies.jl#L186-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.parse_trait_type_params-Tuple{AbstractString}"><a class="docstring-binding" href="#RustCall.parse_trait_type_params-Tuple{AbstractString}"><code>RustCall.parse_trait_type_params</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parse_trait_type_params(params_str::AbstractString) -&gt; Vector{String}</code></pre><p>Parse type parameters inside trait angle brackets, handling nested generics.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">parse_trait_type_params(&quot;Output = T, Error = E&quot;)
# =&gt; [&quot;Output = T&quot;, &quot;Error = E&quot;]

parse_trait_type_params(&quot;Vec&lt;T&gt;&quot;)
# =&gt; [&quot;Vec&lt;T&gt;&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/generics.jl#L122-L135">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.print_function_ir-Tuple{LLVM.Function}"><a class="docstring-binding" href="#RustCall.print_function_ir-Tuple{LLVM.Function}"><code>RustCall.print_function_ir</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">print_function_ir(fn::LLVM.Function; io::IO=stdout)</code></pre><p>Print the LLVM IR of a function for debugging.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmoptimization.jl#L187-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.print_module_ir-Tuple{LLVM.Module}"><a class="docstring-binding" href="#RustCall.print_module_ir-Tuple{LLVM.Module}"><code>RustCall.print_module_ir</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">print_module_ir(mod::LLVM.Module; io::IO=stdout)</code></pre><p>Print the LLVM IR of a module for debugging.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmoptimization.jl#L178-L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.rebuild_crate-Tuple{String}"><a class="docstring-binding" href="#RustCall.rebuild_crate-Tuple{String}"><code>RustCall.rebuild_crate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rebuild_crate(crate_path::String) -&gt; String</code></pre><p>Rebuild a Rust crate and return the path to the compiled library.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L242-L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.register_function-Tuple{String, String, Type, Vector{Type}}"><a class="docstring-binding" href="#RustCall.register_function-Tuple{String, String, Type, Vector{Type}}"><code>RustCall.register_function</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">register_function(name::String, lib_name::String, ret_type::Type, arg_types::Vector{Type})</code></pre><p>Register a function with its type signature for later calling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/codegen.jl#L40-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.reload_library-Tuple{HotReloadState}"><a class="docstring-binding" href="#RustCall.reload_library-Tuple{HotReloadState}"><code>RustCall.reload_library</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reload_library(state::HotReloadState) -&gt; Bool</code></pre><p>Rebuild and reload a Rust library.</p><p>Returns true if successful, false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L145-L151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.remove_dependency_comments-Tuple{String}"><a class="docstring-binding" href="#RustCall.remove_dependency_comments-Tuple{String}"><code>RustCall.remove_dependency_comments</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">remove_dependency_comments(code::String) -&gt; String</code></pre><p>Remove dependency specification comments from Rust code.</p><p>Removes:</p><ol><li><code>//!</code><span>$cargo ...$</span><code></code> blocks</li><li><code>// cargo-deps: ...</code> lines</li></ol><p><strong>Arguments</strong></p><ul><li><code>code::String</code>: Original Rust code</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Code without dependency comments</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargoproject.jl#L203-L217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.remove_derive_julia_struct_attributes-Tuple{String}"><a class="docstring-binding" href="#RustCall.remove_derive_julia_struct_attributes-Tuple{String}"><code>RustCall.remove_derive_julia_struct_attributes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">remove_derive_julia_struct_attributes(code::String) -&gt; String</code></pre><p>Remove #[derive(JuliaStruct)] and related attributes from Rust code before compilation. This is necessary because JuliaStruct is not a real Rust macro.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/structs.jl#L33-L38">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.resolve_version-Tuple{Union{Nothing, String}, Union{Nothing, String}, String}"><a class="docstring-binding" href="#RustCall.resolve_version-Tuple{Union{Nothing, String}, Union{Nothing, String}, String}"><code>RustCall.resolve_version</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">resolve_version(v1::Union{String, Nothing}, v2::Union{String, Nothing}, name::String) -&gt; Union{String, Nothing}</code></pre><p>Resolve version conflict between two version specifications.</p><p><strong>Strategy</strong></p><ol><li>If both are nothing, return nothing</li><li>If one is nothing, return the other</li><li>If both are the same, return that version</li><li>Prefer more specific version (e.g., &quot;1.0.5&quot; over &quot;1.0&quot;)</li><li>If neither is more specific, use v1 with a warning</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependency_resolution.jl#L84-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.resolve_version_conflict-Tuple{DependencySpec, DependencySpec}"><a class="docstring-binding" href="#RustCall.resolve_version_conflict-Tuple{DependencySpec, DependencySpec}"><code>RustCall.resolve_version_conflict</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">resolve_version_conflict(dep1::DependencySpec, dep2::DependencySpec) -&gt; DependencySpec</code></pre><p>Resolve version conflicts between two dependency specifications.</p><p>When two dependencies with the same name have different versions:</p><ol><li>If one has a stricter (more specific) version, prefer that</li><li>Otherwise, prefer the first one and emit a warning</li></ol><p><strong>Arguments</strong></p><ul><li><code>dep1::DependencySpec</code>: First dependency</li><li><code>dep2::DependencySpec</code>: Second dependency (same name)</li></ul><p><strong>Returns</strong></p><ul><li><code>DependencySpec</code>: Resolved dependency</li></ul><p><strong>Throws</strong></p><ul><li><code>DependencyResolutionError</code> if dependencies have incompatible sources</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependency_resolution.jl#L4-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.rust_call_generated-Union{Tuple{name}, Tuple{Val{name}, Vararg{Any}}} where name"><a class="docstring-binding" href="#RustCall.rust_call_generated-Union{Tuple{name}, Tuple{Val{name}, Vararg{Any}}} where name"><code>RustCall.rust_call_generated</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">@generated function rust_call_generated(::Val{name}, args...) where {name}</code></pre><p>A generated function that emits a typed call for registered Rust functions. The function name is encoded as a type parameter for compile-time dispatch.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmcodegen.jl#L379-L384">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.rust_impl-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#RustCall.rust_impl-Tuple{Any, Any, Any}"><code>RustCall.rust_impl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rust_impl(mod, expr, source)</code></pre><p>Implementation of the @rust macro.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/rustmacro.jl#L55-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.rust_impl_call-NTuple{4, Any}"><a class="docstring-binding" href="#RustCall.rust_impl_call-NTuple{4, Any}"><code>RustCall.rust_impl_call</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rust_impl_call(mod, expr, ret_type, source)</code></pre><p>Handle a simple function call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/rustmacro.jl#L119-L123">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.rust_impl_qualified-NTuple{5, Any}"><a class="docstring-binding" href="#RustCall.rust_impl_qualified-NTuple{5, Any}"><code>RustCall.rust_impl_qualified</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rust_impl_qualified(mod, lib_name, call_expr, ret_type, source)</code></pre><p>Handle a library-qualified function call: lib::func(args...)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/rustmacro.jl#L188-L192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.rust_impl_with_type-NTuple{4, Any}"><a class="docstring-binding" href="#RustCall.rust_impl_with_type-NTuple{4, Any}"><code>RustCall.rust_impl_with_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rust_impl_with_type(mod, call_expr, ret_type, source)</code></pre><p>Handle a function call with explicit return type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/rustmacro.jl#L175-L179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.rust_to_julia_type_sym-Tuple{String}"><a class="docstring-binding" href="#RustCall.rust_to_julia_type_sym-Tuple{String}"><code>RustCall.rust_to_julia_type_sym</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rust_to_julia_type_sym(rust_type::String) -&gt; Symbol</code></pre><p>Map Rust type strings to Julia type symbols for code generation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/structs.jl#L1193-L1197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.safe_dlsym-Tuple{Ptr{Nothing}, Symbol}"><a class="docstring-binding" href="#RustCall.safe_dlsym-Tuple{Ptr{Nothing}, Symbol}"><code>RustCall.safe_dlsym</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">safe_dlsym(lib::Ptr{Cvoid}, sym::Symbol) -&gt; Ptr{Cvoid}</code></pre><p>Look up a symbol in a shared library, raising a clear error instead of returning NULL (which would cause a segfault when passed to <code>ccall</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L9-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.save_cache_metadata-Tuple{String, RustCall.CacheMetadata}"><a class="docstring-binding" href="#RustCall.save_cache_metadata-Tuple{String, RustCall.CacheMetadata}"><code>RustCall.save_cache_metadata</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save_cache_metadata(cache_key::String, metadata::CacheMetadata)</code></pre><p>Save cache metadata to a JSON file.</p><p><strong>Arguments</strong></p><ul><li><code>cache_key::String</code>: The cache key identifying the cached library</li><li><code>metadata::CacheMetadata</code>: Metadata to save</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">metadata = CacheMetadata(
    cache_key=&quot;abc123...&quot;,
    code_hash=0x1234...,
    compiler_config=&quot;2_false_x86_64-unknown-linux-gnu&quot;,
    target_triple=&quot;x86_64-unknown-linux-gnu&quot;,
    created_at=now(),
    functions=[&quot;add&quot;, &quot;multiply&quot;]
)
save_cache_metadata(&quot;abc123...&quot;, metadata)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cache.jl#L155-L176">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.save_cached_library-Tuple{String, String, RustCall.CacheMetadata}"><a class="docstring-binding" href="#RustCall.save_cached_library-Tuple{String, String, RustCall.CacheMetadata}"><code>RustCall.save_cached_library</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save_cached_library(cache_key::String, lib_path::String, metadata::CacheMetadata)</code></pre><p>Save a compiled library to the cache along with its metadata.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cache.jl#L98-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.save_cached_llvm_ir-Tuple{String, String}"><a class="docstring-binding" href="#RustCall.save_cached_llvm_ir-Tuple{String, String}"><code>RustCall.save_cached_llvm_ir</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save_cached_llvm_ir(cache_key::String, ir_path::String)</code></pre><p>Save a compiled LLVM IR file to the cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cache.jl#L117-L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.save_cargo_cached_library-Tuple{String, String}"><a class="docstring-binding" href="#RustCall.save_cargo_cached_library-Tuple{String, String}"><code>RustCall.save_cargo_cached_library</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save_cargo_cached_library(cache_key::String, lib_path::String)</code></pre><p>Save a compiled library to the Cargo cache.</p><p><strong>Arguments</strong></p><ul><li><code>cache_key::String</code>: Cache key</li><li><code>lib_path::String</code>: Path to the compiled library</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargobuild.jl#L248-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.snake_to_pascal-Tuple{AbstractString}"><a class="docstring-binding" href="#RustCall.snake_to_pascal-Tuple{AbstractString}"><code>RustCall.snake_to_pascal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">snake_to_pascal(s::AbstractString) -&gt; String</code></pre><p>Convert a snake<em>case or kebab-case string to PascalCase (CamelCase). Handles both underscore (`</em><code>) and hyphen (</code>-`) as separators.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; snake_to_pascal(&quot;sample_crate&quot;)
&quot;SampleCrate&quot;

julia&gt; snake_to_pascal(&quot;my_rust_lib&quot;)
&quot;MyRustLib&quot;

julia&gt; snake_to_pascal(&quot;sample-rs&quot;)
&quot;SampleRs&quot;

julia&gt; snake_to_pascal(&quot;my-rust-lib&quot;)
&quot;MyRustLib&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/types.jl#L5-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.split_cargo_deps-Tuple{String}"><a class="docstring-binding" href="#RustCall.split_cargo_deps-Tuple{String}"><code>RustCall.split_cargo_deps</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">split_cargo_deps(line::String) -&gt; Vector{String}</code></pre><p>Split cargo-deps line by commas, respecting braces and quotes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependencies.jl#L295-L299">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.start_watch_task-Tuple{HotReloadState}"><a class="docstring-binding" href="#RustCall.start_watch_task-Tuple{HotReloadState}"><code>RustCall.start_watch_task</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">start_watch_task(state::HotReloadState; interval::Float64=1.0)</code></pre><p>Start a background task that watches for file changes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L301-L305">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.stop_watch_task-Tuple{HotReloadState}"><a class="docstring-binding" href="#RustCall.stop_watch_task-Tuple{HotReloadState}"><code>RustCall.stop_watch_task</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">stop_watch_task(state::HotReloadState)</code></pre><p>Stop the file watching task for a crate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/hot_reload.jl#L331-L335">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.transform_julia_attribute-Tuple{String}"><a class="docstring-binding" href="#RustCall.transform_julia_attribute-Tuple{String}"><code>RustCall.transform_julia_attribute</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">transform_julia_attribute(code::String) -&gt; String</code></pre><p>Transform <code>#[julia]</code> attributes in Rust code:</p><ul><li>For functions: <code>#[julia] fn</code> → <code>#[no_mangle] pub extern &quot;C&quot; fn</code></li><li>For structs: <code>#[julia] pub struct</code> → <code>#[derive(JuliaStruct)] pub struct</code></li></ul><p><strong>Example</strong></p><p>Input:</p><pre><code class="language-rust hljs">#[julia]
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[julia]
pub struct Point {
    x: f64,
    y: f64,
}</code></pre><p>Output:</p><pre><code class="language-rust hljs">#[no_mangle]
pub extern &quot;C&quot; fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[derive(JuliaStruct)]
pub struct Point {
    x: f64,
    y: f64,
}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/julia_functions.jl#L132-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.try_load_rust_helpers-Tuple{}"><a class="docstring-binding" href="#RustCall.try_load_rust_helpers-Tuple{}"><code>RustCall.try_load_rust_helpers</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">try_load_rust_helpers() -&gt; Bool</code></pre><p>Try to load the Rust helpers library. Returns true if successful, false otherwise. This function will not throw errors, making it safe to call during module initialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L251-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.unload_all_libraries-Tuple{}"><a class="docstring-binding" href="#RustCall.unload_all_libraries-Tuple{}"><code>RustCall.unload_all_libraries</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">unload_all_libraries()</code></pre><p>Unload all loaded Rust libraries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L886-L890">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.unload_library-Tuple{String}"><a class="docstring-binding" href="#RustCall.unload_library-Tuple{String}"><code>RustCall.unload_library</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">unload_library(lib_name::String)</code></pre><p>Unload a Rust library and free its resources.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/ruststr.jl#L860-L864">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.validate_dependencies-Tuple{Vector{DependencySpec}}"><a class="docstring-binding" href="#RustCall.validate_dependencies-Tuple{Vector{DependencySpec}}"><code>RustCall.validate_dependencies</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">validate_dependencies(deps::Vector{DependencySpec})</code></pre><p>Validate that all dependencies have valid specifications.</p><p><strong>Checks</strong></p><ol><li>Each dependency has a name</li><li>Each dependency has at least one of: version, git, path</li><li>No duplicate names (use merge_dependencies first)</li></ol><p><strong>Throws</strong></p><ul><li><code>DependencyResolutionError</code> if validation fails</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependency_resolution.jl#L151-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.validate_version_format-Tuple{String, String}"><a class="docstring-binding" href="#RustCall.validate_version_format-Tuple{String, String}"><code>RustCall.validate_version_format</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">validate_version_format(version::String, name::String)</code></pre><p>Validate that a version string is well-formed.</p><p><strong>Valid formats</strong></p><ul><li>&quot;1.0&quot;</li><li>&quot;1.0.5&quot;</li><li>&quot;^1.0&quot;</li><li>&quot;~1.0.5&quot;</li><li>&quot;&gt;=1.0, &lt;2.0&quot;</li><li>&quot;*&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependency_resolution.jl#L200-L212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.verify_module-Tuple{LLVM.Module}"><a class="docstring-binding" href="#RustCall.verify_module-Tuple{LLVM.Module}"><code>RustCall.verify_module</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">verify_module(mod::LLVM.Module) -&gt; Bool</code></pre><p>Verify that an LLVM module is well-formed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/llvmoptimization.jl#L169-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.verify_rust_helpers_functions-Tuple{Ptr{Nothing}}"><a class="docstring-binding" href="#RustCall.verify_rust_helpers_functions-Tuple{Ptr{Nothing}}"><code>RustCall.verify_rust_helpers_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">verify_rust_helpers_functions(lib::Ptr{Cvoid}) -&gt; Bool</code></pre><p>Verify that required functions are available in the loaded library. Returns true if all required functions are found, false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/memory.jl#L214-L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.version_specificity-Tuple{String}"><a class="docstring-binding" href="#RustCall.version_specificity-Tuple{String}"><code>RustCall.version_specificity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">version_specificity(version::String) -&gt; Int</code></pre><p>Calculate a specificity score for a version string. Higher score = more specific.</p><p><strong>Examples</strong></p><ul><li>&quot;1&quot; -&gt; 1</li><li>&quot;1.0&quot; -&gt; 2</li><li>&quot;1.0.5&quot; -&gt; 3</li><li>&quot;1.0.5-beta&quot; -&gt; 4</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/dependency_resolution.jl#L123-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.write_rust_code_to_project-Tuple{CargoProject, String}"><a class="docstring-binding" href="#RustCall.write_rust_code_to_project-Tuple{CargoProject, String}"><code>RustCall.write_rust_code_to_project</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_rust_code_to_project(project::CargoProject, code::String)</code></pre><p>Write Rust code to the project&#39;s src/lib.rs, removing dependency comments.</p><p><strong>Arguments</strong></p><ul><li><code>project::CargoProject</code>: The Cargo project</li><li><code>code::String</code>: Rust source code (may contain dependency comments)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/cargoproject.jl#L185-L193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.@rust_ccall-Tuple{Any, Any, Any, Vararg{Any}}"><a class="docstring-binding" href="#RustCall.@rust_ccall-Tuple{Any, Any, Any, Vararg{Any}}"><code>RustCall.@rust_ccall</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@rust_ccall(func_name, ret_type, arg_types, args...)</code></pre><p>Low-level macro for calling a Rust function with explicit types.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">@rust_ccall(add, Int32, (Int32, Int32), 10, 20)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/codegen.jl#L325-L334">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.@rust_crate_static-Tuple{Any, Any}"><a class="docstring-binding" href="#RustCall.@rust_crate_static-Tuple{Any, Any}"><code>RustCall.@rust_crate_static</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@rust_crate_static(lib_path, module_name)</code></pre><p>Load a pre-generated Rust crate binding with a specific library path.</p><p>This macro is for loading bindings that were generated with <code>write_bindings_to_file</code> where the library was placed at a known location.</p><p><strong>Arguments</strong></p><ul><li><code>lib_path</code>: Path to the compiled shared library</li><li><code>module_name</code>: Name of the module to create</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># In a precompiled package
const _RUST_LIB = joinpath(@__DIR__, &quot;..&quot;, &quot;deps&quot;, &quot;libmycrate.so&quot;)
@rust_crate_static _RUST_LIB MyCrate</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/crate_bindings.jl#L1672-L1690">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RustCall.@rust_register-Tuple{Any, Any, Vararg{Any}}"><a class="docstring-binding" href="#RustCall.@rust_register-Tuple{Any, Any, Vararg{Any}}"><code>RustCall.@rust_register</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@rust_register(func_name, ret_type, arg_types...)</code></pre><p>Register a Rust function with its type signature for optimized calling.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">@rust_register(add, Int32, Int32, Int32)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AtelierArith/RustCall.jl/blob/ffbefe1f6f7b1551678b12ffca3539cdc7628991/src/rustmacro.jl#L341-L350">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../troubleshooting/">« Troubleshooting</a><a class="docs-footer-nextpage" href="../status/">Project Status »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 9 February 2026 09:01">Monday 9 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
